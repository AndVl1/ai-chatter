package vibecoding

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"
	"time"

	"ai-chatter/internal/codevalidation"
	"ai-chatter/internal/llm"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// TelegramSender –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
type TelegramSender interface {
	Send(c tgbotapi.Chattable) (tgbotapi.Message, error)
	GetFile(config tgbotapi.FileConfig) (tgbotapi.File, error)
}

// MessageFormatter –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π
type MessageFormatter interface {
	EscapeText(text string) string
	ParseModeValue() string
}

// VibeCodingHandler –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—ã –∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ä–µ–∂–∏–º–µ vibecoding
type VibeCodingHandler struct {
	sessionManager   *SessionManager
	sender           TelegramSender
	formatter        MessageFormatter
	llmClient        llm.Client
	protocolClient   *VibeCodingLLMClient
	awaitingAutoTask map[int64]bool // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏, –æ–∂–∏–¥–∞—é—â–∏–µ –≤–≤–æ–¥–∞ –∑–∞–¥–∞—á–∏ –¥–ª—è –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–π —Ä–∞–±–æ—Ç—ã
}

// NewVibeCodingHandler —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ vibecoding
func NewVibeCodingHandler(sender TelegramSender, formatter MessageFormatter, llmClient llm.Client) *VibeCodingHandler {
	sessionManager := NewSessionManager()
	protocolClient := NewVibeCodingLLMClient(llmClient)

	// –°–æ–∑–¥–∞–µ–º MCP –∫–ª–∏–µ–Ω—Ç –∏ –ø–æ–¥–∫–ª—é—á–∞–µ–º –µ–≥–æ –∫ LLM –∫–ª–∏–µ–Ω—Ç—É
	mcpClient := NewVibeCodingMCPClient()
	protocolClient.SetMCPClient(mcpClient)

	return &VibeCodingHandler{
		sessionManager:   sessionManager,
		sender:           sender,
		formatter:        formatter,
		llmClient:        llmClient,
		protocolClient:   protocolClient,
		awaitingAutoTask: make(map[int64]bool),
	}
}

// HandleArchiveUpload –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∑–∞–≥—Ä—É–∑–∫—É –∞—Ä—Ö–∏–≤–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è vibecoding —Å–µ—Å—Å–∏–∏
func (h *VibeCodingHandler) HandleArchiveUpload(ctx context.Context, userID, chatID int64, archiveData []byte, archiveName, caption string) error {
	log.Printf("üî• HandleArchiveUpload called for user %d", userID)

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∞–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è
	if h.sessionManager.HasActiveSession(userID) {
		text := "[vibecoding] ‚ùå –£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è –≤–∞–π–±–∫–æ–¥–∏–Ω–≥–∞. –ó–∞–≤–µ—Ä—à–∏—Ç–µ –µ—ë –∫–æ–º–∞–Ω–¥–æ–π /vibecoding_end –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º –Ω–æ–≤–æ–π."
		return h.sendMessage(chatID, text)
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –Ω–µ—Ç –≤–æ–ø—Ä–æ—Å–æ–≤ –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ (—É—Å–ª–æ–≤–∏–µ –¥–ª—è vibecoding)
	if strings.TrimSpace(caption) != "" {
		return fmt.Errorf("–¥–ª—è –∑–∞–ø—É—Å–∫–∞ vibecoding —Ä–µ–∂–∏–º–∞ –∞—Ä—Ö–∏–≤ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω –±–µ–∑ –≤–æ–ø—Ä–æ—Å–æ–≤ –≤ –æ–ø–∏—Å–∞–Ω–∏–∏")
	}

	// –ò–∑–≤–ª–µ–∫–∞–µ–º —Ñ–∞–π–ª—ã –∏–∑ –∞—Ä—Ö–∏–≤–∞
	files, projectName, err := ExtractFilesFromArchive(archiveData, archiveName)
	if err != nil {
		text := fmt.Sprintf("[vibecoding] ‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞—Ä—Ö–∏–≤–∞: %s", err.Error())
		h.sendMessage(chatID, text)
		return err
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∞—Ä—Ö–∏–≤ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏–µ —Ñ–∞–π–ª—ã
	if !IsValidProjectArchive(files) {
		text := "[vibecoding] ‚ùå –ê—Ä—Ö–∏–≤ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Ñ–∞–π–ª–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∫–æ–¥–∞."
		h.sendMessage(chatID, text)
		return fmt.Errorf("invalid project archive")
	}

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
	stats := GetProjectStats(files)
	startMsg := fmt.Sprintf(`[vibecoding] üî• –ó–∞–ø—É—Å–∫ —Å–µ—Å—Å–∏–∏ –≤–∞–π–±–∫–æ–¥–∏–Ω–≥–∞

–ü—Ä–æ–µ–∫—Ç: %s
–§–∞–π–ª–æ–≤: %d
–†–∞–∑–º–µ—Ä: %d bytes

üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è... (–¥–æ 3 –ø–æ–ø—ã—Ç–æ–∫)`,
		projectName,
		stats["total_files"].(int),
		stats["total_size"].(int))

	msg := tgbotapi.NewMessage(chatID, h.formatter.EscapeText(startMsg))
	msg.ParseMode = h.formatter.ParseModeValue()
	setupMsg, _ := h.sender.Send(msg)

	// –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é
	session, err := h.sessionManager.CreateSession(userID, chatID, projectName, files, h.llmClient)
	if err != nil {
		errorMsg := fmt.Sprintf("[vibecoding] ‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ—Å—Å–∏–∏: %s", err.Error())
		h.updateMessage(chatID, setupMsg.MessageID, errorMsg)
		return err
	}

	// –ü–æ–¥–∫–ª—é—á–∞–µ–º MCP –∫–ª–∏–µ–Ω—Ç —á–µ—Ä–µ–∑ HTTP –¥–ª—è –ø—Ä—è–º—ã—Ö –≤—ã–∑–æ–≤–æ–≤ –æ—Ç LLM
	if h.protocolClient != nil && h.protocolClient.mcpClient != nil {
		log.Printf("üîó Connecting MCP client for VibeCoding session user %d", userID)
		if err := h.protocolClient.mcpClient.ConnectHTTP(ctx, h.sessionManager); err != nil {
			log.Printf("‚ö†Ô∏è Failed to connect MCP client via HTTP: %v. LLM tools may not work properly.", err)
			// –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Å—Å–∏–∏, —Ç.–∫. MCP –Ω–µ –∫—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è –±–∞–∑–æ–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏
		} else {
			log.Printf("‚úÖ MCP client connected via HTTP for user %d", userID)
		}
	}

	// –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ–∫—Ä—É–∂–µ–Ω–∏–µ
	if err := session.SetupEnvironment(ctx); err != nil {
		// –û—á–∏—â–∞–µ–º —Å–µ—Å—Å–∏—é –ø—Ä–∏ –æ—à–∏–±–∫–µ
		h.sessionManager.EndSession(userID)

		errorMsg := fmt.Sprintf(`[vibecoding] ‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –æ–∫—Ä—É–∂–µ–Ω–∏–µ

–û—à–∏–±–∫–∞: %s

–°–µ—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∞—Ä—Ö–∏–≤–∞ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.`,
			err.Error())

		h.updateMessage(chatID, setupMsg.MessageID, errorMsg)
		return err
	}

	// –û–∫—Ä—É–∂–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ
	successMsg := fmt.Sprintf(`[vibecoding] üî• –°–µ—Å—Å–∏—è –≤–∞–π–±–∫–æ–¥–∏–Ω–≥–∞ –≥–æ—Ç–æ–≤–∞!

–ü—Ä–æ–µ–∫—Ç: %s
–Ø–∑—ã–∫: %s
–ö–æ–º–∞–Ω–¥–∞ —Ç–µ—Å—Ç–æ–≤: %s

üåê –í–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: http://localhost:3000?user=%d

–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
/vibecoding_info - –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Å—Å–∏–∏
/vibecoding_context - –æ–±–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞
/vibecoding_test - –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç—ã
/vibecoding_generate_tests - —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç–µ—Å—Ç—ã
/vibecoding_auto - –∞–≤—Ç–æ–Ω–æ–º–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å –ø—Ä–æ–µ–∫—Ç–æ–º
/vibecoding_end - –∑–∞–≤–µ—Ä—à–∏—Ç—å —Å–µ—Å—Å–∏—é

–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –ø–æ –∫–æ–¥—É –∏ –∑–∞–ø—Ä–∞—à–∏–≤–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è!`,
		session.ProjectName,
		session.Analysis.Language,
		session.TestCommand,
		userID)

	h.updateMessage(chatID, setupMsg.MessageID, successMsg)
	return nil
}

// HandleVibeCodingCommand –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—ã vibecoding —Ä–µ–∂–∏–º–∞
func (h *VibeCodingHandler) HandleVibeCodingCommand(ctx context.Context, userID, chatID int64, command string) error {
	session := h.sessionManager.GetSession(userID)
	if session == nil {
		text := "[vibecoding] ‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Å–µ—Å—Å–∏–∏ –≤–∞–π–±–∫–æ–¥–∏–Ω–≥–∞. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—Ä—Ö–∏–≤ —Å –∫–æ–¥–æ–º –¥–ª—è –Ω–∞—á–∞–ª–∞."
		return h.sendMessage(chatID, text)
	}

	switch command {
	case "/vibecoding_info":
		return h.handleInfoCommand(chatID, session)
	case "/vibecoding_context":
		return h.handleContextCommand(ctx, chatID, session)
	case "/vibecoding_test":
		return h.handleTestCommand(ctx, chatID, session)
	case "/vibecoding_generate_tests":
		return h.handleGenerateTestsCommand(ctx, chatID, session)
	case "/vibecoding_auto":
		return h.handleAutoCommand(ctx, chatID, userID, session)
	case "/vibecoding_end":
		return h.handleEndCommand(ctx, chatID, userID, session)
	default:
		text := "[vibecoding] ‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /vibecoding_info –¥–ª—è —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥."
		return h.sendMessage(chatID, text)
	}
}

// HandleVibeCodingMessage –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ vibecoding —Ä–µ–∂–∏–º–µ
func (h *VibeCodingHandler) HandleVibeCodingMessage(ctx context.Context, userID, chatID int64, messageText string) error {
	session := h.sessionManager.GetSession(userID)
	if session == nil {
		return nil // –ù–µ –Ω–∞—à–∞ –∑–∞–¥–∞—á–∞ –µ—Å–ª–∏ –Ω–µ—Ç —Å–µ—Å—Å–∏–∏
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ–∂–∏–¥–∞–µ—Ç—Å—è –ª–∏ –∑–∞–¥–∞—á–∞ –¥–ª—è –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–π —Ä–∞–±–æ—Ç—ã
	if h.awaitingAutoTask[userID] {
		delete(h.awaitingAutoTask, userID) // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è
		return h.HandleAutoWorkRequest(ctx, userID, chatID, messageText)
	}

	log.Printf("üî• Processing vibecoding message from user %d: %s", userID, messageText)

	// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç —á–µ—Ä–µ–∑ LLM
	response, err := h.generateCodeResponse(ctx, session, messageText)
	if err != nil {
		errorMsg := fmt.Sprintf("[vibecoding] ‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞: %s", err.Error())
		return h.sendMessage(chatID, errorMsg)
	}

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
	return h.sendLongMessage(chatID, fmt.Sprintf("[vibecoding] %s", response))
}

// handleInfoCommand –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–µ—Å—Å–∏–∏
func (h *VibeCodingHandler) handleInfoCommand(chatID int64, session *VibeCodingSession) error {
	info := session.GetSessionInfo()
	duration := time.Since(session.StartTime).Round(time.Second)

	infoMsg := fmt.Sprintf(`[vibecoding] üìä –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Å—Å–∏–∏

–ü—Ä–æ–µ–∫—Ç: %s
–Ø–∑—ã–∫: %s
–ù–∞—á–∞–ª–æ: %s
–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: %s
–§–∞–π–ª–æ–≤: %d –∏—Å—Ö–æ–¥–Ω—ã—Ö + %d —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö
–ö–æ–º–∞–Ω–¥–∞ —Ç–µ—Å—Ç–æ–≤: %s
–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä: %s`,
		info["project_name"].(string),
		info["language"].(string),
		info["start_time"].(time.Time).Format("15:04:05"),
		duration,
		info["files_count"].(int),
		info["generated_count"].(int),
		info["test_command"].(string),
		info["container_id"].(string))

	// –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
	if contextAvailable, exists := info["context_available"].(bool); exists && contextAvailable {
		infoMsg += fmt.Sprintf(`

üìã –ö–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞: –¥–æ—Å—Ç—É–ø–µ–Ω
–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω: %s
–§–∞–π–ª–æ–≤ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ: %d
–ü–æ–ª–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç: PROJECT_CONTEXT.md`,
			info["context_generated_at"].(time.Time).Format("15:04:05"),
			info["context_files_count"].(int))
	} else {
		infoMsg += "\n\nüìã –ö–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞: –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω"
	}

	return h.sendMessage(chatID, infoMsg)
}

// handleContextCommand –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ø—Ä–æ–µ–∫—Ç–∞
func (h *VibeCodingHandler) handleContextCommand(ctx context.Context, chatID int64, session *VibeCodingSession) error {
	text := "[vibecoding] üìã –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ø—Ä–æ–µ–∫—Ç–∞..."
	msg := tgbotapi.NewMessage(chatID, h.formatter.EscapeText(text))
	msg.ParseMode = h.formatter.ParseModeValue()
	sentMsg, _ := h.sender.Send(msg)

	// –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç
	if err := session.RefreshProjectContext(); err != nil {
		errorMsg := fmt.Sprintf("[vibecoding] ‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞: %s", err.Error())
		h.updateMessage(chatID, sentMsg.MessageID, errorMsg)
		return err
	}

	// –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ LLM-–∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
	info := session.GetSessionInfo()
	successMsg := fmt.Sprintf(`[vibecoding] ‚úÖ LLM-–∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω

üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:
–í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: %d
–ö–ª—é—á–µ–≤—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤: %d
–¢–æ–∫–µ–Ω–æ–≤: %d / %d
–û–±–Ω–æ–≤–ª–µ–Ω: %s

üìã –ü–æ–ª–Ω—ã–π LLM-–∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–æ—Å—Ç—É–ø–µ–Ω –≤ —Ñ–∞–π–ª–µ PROJECT_CONTEXT.md
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ MCP tools –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤ –ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é.`,
		info["context_total_files"].(int),
		info["context_files_count"].(int),
		info["context_tokens_used"].(int),
		info["context_tokens_limit"].(int),
		info["context_generated_at"].(time.Time).Format("15:04:05"))

	h.updateMessage(chatID, sentMsg.MessageID, successMsg)
	return nil
}

// handleTestCommand –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É –∑–∞–ø—É—Å–∫–∞ —Ç–µ—Å—Ç–æ–≤ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –ø—Ä–∏ –Ω–µ—É–¥–∞—á–µ
func (h *VibeCodingHandler) handleTestCommand(ctx context.Context, chatID int64, session *VibeCodingSession) error {
	text := "[vibecoding] üß™ –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤..."
	msg := tgbotapi.NewMessage(chatID, h.formatter.EscapeText(text))
	msg.ParseMode = h.formatter.ParseModeValue()
	sentMsg, _ := h.sender.Send(msg)

	maxAttempts := 3
	var lastResult *codevalidation.ValidationResult
	var lastError error

	for attempt := 1; attempt <= maxAttempts; attempt++ {
		log.Printf("üß™ Test execution attempt %d/%d for user %d", attempt, maxAttempts, session.UserID)

		if attempt > 1 {
			// –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –ø–æ–ø—ã—Ç–∫–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è
			progressMsg := fmt.Sprintf("[vibecoding] üß™ –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤... (–ø–æ–ø—ã—Ç–∫–∞ %d/%d)\nüîß –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤ —á–µ—Ä–µ–∑ LLM...", attempt, maxAttempts)
			h.updateMessage(chatID, sentMsg.MessageID, progressMsg)
		}

		// –í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—É —Ç–µ—Å—Ç–æ–≤
		result, err := session.ExecuteCommand(ctx, session.TestCommand)
		if err != nil {
			log.Printf("‚ùå Test execution failed on attempt %d for user %d: %v", attempt, session.UserID, err)
			lastError = err

			if attempt < maxAttempts {
				// –ü—ã—Ç–∞–µ–º—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–æ–±–ª–µ–º—É –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —á–µ—Ä–µ–∑ LLM
				if fixErr := h.fixTestExecutionIssues(ctx, session, err); fixErr != nil {
					log.Printf("‚ö†Ô∏è Could not fix test execution issues: %v", fixErr)
				}
				continue
			}

			errorMsg := fmt.Sprintf("[vibecoding] ‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤ –ø–æ—Å–ª–µ %d –ø–æ–ø—ã—Ç–æ–∫: %s", maxAttempts, err.Error())
			h.updateMessage(chatID, sentMsg.MessageID, errorMsg)
			return err
		}

		lastResult = result
		log.Printf("üß™ Test execution completed on attempt %d for user %d: success=%v, exit_code=%d", attempt, session.UserID, result.Success, result.ExitCode)

		// –ï—Å–ª–∏ —Ç–µ—Å—Ç—ã –ø—Ä–æ—à–ª–∏ —É—Å–ø–µ—à–Ω–æ - –∑–∞–≤–µ—Ä—à–∞–µ–º
		if result.Success {
			log.Printf("‚úÖ Tests passed successfully on attempt %d", attempt)
			break
		}

		// –ï—Å–ª–∏ —Ç–µ—Å—Ç—ã –Ω–µ –ø—Ä–æ—à–ª–∏ –∏ –µ—Å—Ç—å –µ—â–µ –ø–æ–ø—ã—Ç–∫–∏ - –ø—ã—Ç–∞–µ–º—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å
		if attempt < maxAttempts {
			log.Printf("üîß Tests failed on attempt %d, attempting to fix with LLM", attempt)
			if fixErr := h.fixFailingTests(ctx, session, result); fixErr != nil {
				log.Printf("‚ö†Ô∏è Could not fix failing tests on attempt %d: %v", attempt, fixErr)
				lastError = fixErr
			} else {
				log.Printf("‚úÖ Applied test fixes, retrying execution")
			}
		} else {
			log.Printf("‚ùå Tests failed after %d attempts, no more fixes to try", maxAttempts)
			lastError = fmt.Errorf("tests failed after %d attempts", maxAttempts)
		}
	}

	// –§–æ—Ä–º–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
	if lastResult != nil {
		status := "‚úÖ —É—Å–ø–µ—à–Ω–æ"
		attempts := ""
		if maxAttempts > 1 {
			attempts = fmt.Sprintf(" (–∑–∞ %d –ø–æ–ø—ã—Ç–æ–∫)", maxAttempts)
		}

		if !lastResult.Success {
			status = "‚ùå —Å –æ—à–∏–±–∫–∞–º–∏"
			attempts = fmt.Sprintf(" –ø–æ—Å–ª–µ %d –ø–æ–ø—ã—Ç–æ–∫", maxAttempts)
			log.Printf("‚ùå Test validation failed for user %d: %s", session.UserID, lastResult.Output)
		}

		resultMsg := fmt.Sprintf(`[vibecoding] üß™ –¢–µ—Å—Ç—ã –≤—ã–ø–æ–ª–Ω–µ–Ω—ã %s%s

–ö–æ–¥ –≤—ã—Ö–æ–¥–∞: %d
–í—ã–≤–æ–¥:
%s`,
			status,
			attempts,
			lastResult.ExitCode,
			lastResult.Output)

		h.updateMessage(chatID, sentMsg.MessageID, resultMsg)

		// –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É –µ—Å–ª–∏ —Ç–µ—Å—Ç—ã –Ω–µ –ø—Ä–æ—à–ª–∏ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞
		if !lastResult.Success {
			return fmt.Errorf("test validation failed with exit code %d", lastResult.ExitCode)
		}
	} else if lastError != nil {
		errorMsg := fmt.Sprintf("[vibecoding] ‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤: %s", lastError.Error())
		h.updateMessage(chatID, sentMsg.MessageID, errorMsg)
		return lastError
	}

	return nil
}

// handleGenerateTestsCommand –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤
func (h *VibeCodingHandler) handleGenerateTestsCommand(ctx context.Context, chatID int64, session *VibeCodingSession) error {
	text := "[vibecoding] üß† –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤..."
	msg := tgbotapi.NewMessage(chatID, h.formatter.EscapeText(text))
	msg.ParseMode = h.formatter.ParseModeValue()
	sentMsg, _ := h.sender.Send(msg)

	// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ—Å—Ç—ã —á–µ—Ä–µ–∑ LLM —Å –¥–µ—Ç–∞–ª—å–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
	tests, err := h.generateTestsWithProgress(ctx, session, chatID, sentMsg.MessageID)
	if err != nil {
		errorMsg := fmt.Sprintf("[vibecoding] ‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤: %s", err.Error())
		h.updateMessage(chatID, sentMsg.MessageID, errorMsg)
		return err
	}

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã –≤ —Å–µ—Å—Å–∏–∏
	for filename, content := range tests {
		session.AddGeneratedFile(filename, content)
	}

	// –ö–æ–ø–∏—Ä—É–µ–º —Ç–µ—Å—Ç—ã –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
	if err := session.Docker.CopyFilesToContainer(ctx, session.ContainerID, tests); err != nil {
		log.Printf("‚ö†Ô∏è Failed to copy generated tests to container: %v", err)
	}

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
	h.updateMessage(chatID, sentMsg.MessageID, "[vibecoding] ‚úÖ –¢–µ—Å—Ç—ã —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ –ø—Ä–æ–µ–∫—Ç")

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ç–µ—Å—Ç–æ–≤
	for filename, content := range tests {
		testMsg := fmt.Sprintf(`[vibecoding] üìù –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ñ–∞–π–ª: %s

%s`,
			filename,
			content)

		h.sendLongMessage(chatID, testMsg)
	}

	return nil
}

// handleEndCommand –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏
func (h *VibeCodingHandler) handleEndCommand(ctx context.Context, chatID int64, userID int64, session *VibeCodingSession) error {
	text := "[vibecoding] üì¶ –°–æ–∑–¥–∞–Ω–∏–µ –∏—Ç–æ–≥–æ–≤–æ–≥–æ –∞—Ä—Ö–∏–≤–∞..."
	msg := tgbotapi.NewMessage(chatID, h.formatter.EscapeText(text))
	msg.ParseMode = h.formatter.ParseModeValue()
	sentMsg, _ := h.sender.Send(msg)

	// –°–æ–∑–¥–∞–µ–º –∞—Ä—Ö–∏–≤ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
	archiveData, err := CreateResultArchive(session)
	if err != nil {
		errorMsg := fmt.Sprintf("[vibecoding] ‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∞—Ä—Ö–∏–≤–∞: %s", err.Error())
		h.updateMessage(chatID, sentMsg.MessageID, errorMsg)
		return err
	}

	// –û—Ç–∫–ª—é—á–∞–µ–º MCP –∫–ª–∏–µ–Ω—Ç –ø–µ—Ä–µ–¥ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ–º —Å–µ—Å—Å–∏–∏
	if h.protocolClient != nil && h.protocolClient.mcpClient != nil {
		log.Printf("üîå Disconnecting MCP client for user %d", userID)
		if err := h.protocolClient.mcpClient.Close(); err != nil {
			log.Printf("‚ö†Ô∏è Error disconnecting MCP client: %v", err)
		} else {
			log.Printf("‚úÖ MCP client disconnected for user %d", userID)
		}
	}

	// –ó–∞–≤–µ—Ä—à–∞–µ–º —Å–µ—Å—Å–∏—é –∏ –æ—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è
	duration := time.Since(session.StartTime).Round(time.Second)
	delete(h.awaitingAutoTask, userID) // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏
	if err := h.sessionManager.EndSession(userID); err != nil {
		log.Printf("‚ö†Ô∏è Error ending session: %v", err)
	}

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∞—Ä—Ö–∏–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
	archiveName := fmt.Sprintf("%s-vibecoding-result.zip", session.ProjectName)
	document := tgbotapi.FileBytes{
		Name:  archiveName,
		Bytes: archiveData,
	}

	documentMsg := tgbotapi.NewDocument(chatID, document)
	caption := fmt.Sprintf(`[vibecoding] üî• –°–µ—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞

–ü—Ä–æ–µ–∫—Ç: %s
–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: %s
–§–∞–π–ª–æ–≤ –≤ –∞—Ä—Ö–∏–≤–µ: %d

–ê—Ä—Ö–∏–≤ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –∏—Å—Ö–æ–¥–Ω—ã–µ –∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã.`,
		session.ProjectName,
		duration,
		len(session.GetAllFiles()))
	documentMsg.Caption = h.formatter.EscapeText(caption)
	documentMsg.ParseMode = h.formatter.ParseModeValue()

	_, err = h.sender.Send(documentMsg)
	return err
}

// handleAutoCommand –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–π —Ä–∞–±–æ—Ç—ã
func (h *VibeCodingHandler) handleAutoCommand(ctx context.Context, chatID int64, userID int64, session *VibeCodingSession) error {
	h.awaitingAutoTask[userID] = true
	text := "[vibecoding] ü§ñ –ó–∞–ø—É—Å–∫ –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–π —Ä–∞–±–æ—Ç—ã...\n\n–í–≤–µ–¥–∏—Ç–µ –∑–∞–¥–∞—á—É –¥–ª—è –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:"
	return h.sendMessage(chatID, text)
}

// HandleAutoWorkRequest –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∑–∞–ø—Ä–æ—Å –Ω–∞ –∞–≤—Ç–æ–Ω–æ–º–Ω—É—é —Ä–∞–±–æ—Ç—É —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∑–∞–¥–∞—á–µ–π
func (h *VibeCodingHandler) HandleAutoWorkRequest(ctx context.Context, userID, chatID int64, task string) error {
	session := h.sessionManager.GetSession(userID)
	if session == nil {
		text := "[vibecoding] ‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Å–µ—Å—Å–∏–∏ –≤–∞–π–±–∫–æ–¥–∏–Ω–≥–∞."
		return h.sendMessage(chatID, text)
	}

	text := fmt.Sprintf("[vibecoding] ü§ñ –ó–∞–ø—É—Å–∫ –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–π —Ä–∞–±–æ—Ç—ã...\n\n–ó–∞–¥–∞—á–∞: %s", task)
	msg := tgbotapi.NewMessage(chatID, h.formatter.EscapeText(text))
	msg.ParseMode = h.formatter.ParseModeValue()
	sentMsg, _ := h.sender.Send(msg)

	// –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –¥–ª—è –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–π —Ä–∞–±–æ—Ç—ã
	options := map[string]interface{}{
		"user_id": userID,
	}

	// –î–æ–±–∞–≤–ª—è–µ–º —Å–∂–∞—Ç—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞ –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω
	if session.Context != nil {
		options["project_context"] = session.Context
	}

	request := VibeCodingRequest{
		Action: "autonomous_work",
		Context: VibeCodingContext{
			ProjectName:     session.ProjectName,
			Language:        session.Analysis.Language,
			Files:           session.Files,
			GeneratedFiles:  session.GeneratedFiles,
			SessionDuration: time.Since(session.StartTime).Round(time.Second).String(),
		},
		Query:   task,
		Options: options,
	}

	log.Printf("ü§ñ Starting autonomous work for user %d: %s", userID, task)

	// –ó–∞–ø—É—Å–∫–∞–µ–º –∞–≤—Ç–æ–Ω–æ–º–Ω—É—é —Ä–∞–±–æ—Ç—É
	response, err := h.protocolClient.ProcessRequest(ctx, request)
	if err != nil {
		log.Printf("‚ùå Autonomous work failed: %v", err)
		errorMsg := fmt.Sprintf("[vibecoding] ‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–π —Ä–∞–±–æ—Ç—ã: %s", err.Error())
		h.updateMessage(chatID, sentMsg.MessageID, errorMsg)
		return err
	}

	// –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
	var resultMsg strings.Builder
	resultMsg.WriteString("[vibecoding] ü§ñ –ê–≤—Ç–æ–Ω–æ–º–Ω–∞—è —Ä–∞–±–æ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞\n\n")
	resultMsg.WriteString(fmt.Sprintf("–°—Ç–∞—Ç—É—Å: %s\n", response.Status))

	if response.Status == "success" {
		resultMsg.WriteString(fmt.Sprintf("–†–µ–∑—É–ª—å—Ç–∞—Ç: %s\n", response.Response))

		// –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–∞—Ö
		if len(response.Code) > 0 {
			resultMsg.WriteString(fmt.Sprintf("\nüìù –°–æ–∑–¥–∞–Ω–æ —Ñ–∞–π–ª–æ–≤: %d\n", len(response.Code)))
			for filename := range response.Code {
				resultMsg.WriteString(fmt.Sprintf("- %s\n", filename))
			}
		}

		// –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–≥ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω
		if response.Metadata != nil {
			if executionLog, exists := response.Metadata["execution_log"].([]string); exists && len(executionLog) > 0 {
				resultMsg.WriteString("\nüîç –ñ—É—Ä–Ω–∞–ª –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:\n")
				for i, logEntry := range executionLog {
					if i < 10 { // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 10 –∑–∞–ø–∏—Å–µ–π
						resultMsg.WriteString(fmt.Sprintf("%s\n", logEntry))
					}
				}
				if len(executionLog) > 10 {
					resultMsg.WriteString(fmt.Sprintf("... –∏ –µ—â–µ %d –∑–∞–ø–∏—Å–µ–π\n", len(executionLog)-10))
				}
			}
		}

		// –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
		if len(response.Suggestions) > 0 {
			resultMsg.WriteString("\nüí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:\n")
			for _, suggestion := range response.Suggestions {
				resultMsg.WriteString(fmt.Sprintf("- %s\n", suggestion))
			}
		}
	} else {
		resultMsg.WriteString(fmt.Sprintf("–û—à–∏–±–∫–∞: %s\n", response.Error))
	}

	h.updateMessage(chatID, sentMsg.MessageID, resultMsg.String())
	return nil
}

// generateCodeResponse –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç –Ω–∞ –≤–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ –∫–æ–¥–µ —á–µ—Ä–µ–∑ JSON –ø—Ä–æ—Ç–æ–∫–æ–ª
func (h *VibeCodingHandler) generateCodeResponse(ctx context.Context, session *VibeCodingSession, question string) (string, error) {
	// –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ JSON –ø—Ä–æ—Ç–æ–∫–æ–ª
	request := VibeCodingRequest{
		Action: "answer_question",
		Context: VibeCodingContext{
			ProjectName:     session.ProjectName,
			Language:        session.Analysis.Language,
			Files:           session.Files,
			GeneratedFiles:  session.GeneratedFiles,
			SessionDuration: time.Since(session.StartTime).Round(time.Second).String(),
		},
		Query: question,
	}

	// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ –ø—Ä–æ—Ç–æ–∫–æ–ª –∫–ª–∏–µ–Ω—Ç
	response, err := h.protocolClient.ProcessRequest(ctx, request)
	if err != nil {
		log.Printf("‚ùå JSON protocol request failed: %v", err)
		// Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –º–µ—Ç–æ–¥
		return h.generateCodeResponseLegacy(ctx, session, question)
	}

	// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç
	if response.Status == "error" {
		return "", fmt.Errorf("LLM returned error: %s", response.Error)
	}

	var result strings.Builder
	result.WriteString(response.Response)

	// –î–æ–±–∞–≤–ª—è–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ –µ—Å–ª–∏ –µ—Å—Ç—å
	if len(response.Code) > 0 {
		result.WriteString("\n\nüìù –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥:\n")
		for filename, content := range response.Code {
			result.WriteString(fmt.Sprintf("\n**%s:**\n```\n%s\n```", filename, content))

			// –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ –≤ —Å–µ—Å—Å–∏–∏
			session.AddGeneratedFile(filename, content)
		}
	}

	// –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –µ—Å–ª–∏ –µ—Å—Ç—å
	if len(response.Suggestions) > 0 {
		result.WriteString("\n\nüí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è:\n")
		for _, suggestion := range response.Suggestions {
			result.WriteString(fmt.Sprintf("‚Ä¢ %s\n", suggestion))
		}
	}

	return result.String(), nil
}

// generateCodeResponseLegacy - –∑–∞–ø–∞—Å–Ω–æ–π –º–µ—Ç–æ–¥ –±–µ–∑ JSON –ø—Ä–æ—Ç–æ–∫–æ–ª–∞
func (h *VibeCodingHandler) generateCodeResponseLegacy(ctx context.Context, session *VibeCodingSession, question string) (string, error) {
	log.Printf("‚ö†Ô∏è Using legacy code response generation")

	// –§–æ—Ä–º–∏—Ä—É–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è LLM
	projectContext := h.buildProjectContext(session)

	prompt := fmt.Sprintf(`–¢—ã —Ä–∞–±–æ—Ç–∞–µ—à—å –≤ —Ä–µ–∂–∏–º–µ VibeCoding - –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–π —Å–µ—Å—Å–∏–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏.

–ö–û–ù–¢–ï–ö–°–¢ –ü–†–û–ï–ö–¢–ê:
–ü—Ä–æ–µ–∫—Ç: %s
–Ø–∑—ã–∫: %s
–§–∞–π–ª–æ–≤: %d

–°–¢–†–£–ö–¢–£–†–ê –ü–†–û–ï–ö–¢–ê:
%s

–í–û–ü–†–û–° –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø:
%s

–ò–ù–°–¢–†–£–ö–¶–ò–ò:
1. –û—Ç–≤–µ—á–∞–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ –∏ –ø—Ä–∞–∫—Ç–∏—á–Ω–æ
2. If you need to show code, format it properly for Telegram
3. –ï—Å–ª–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—à—å –Ω–æ–≤—ã–π –∫–æ–¥, —É–∫–∞–∂–∏ –≤ –∫–∞–∫–æ–π —Ñ–∞–π–ª –µ–≥–æ –Ω—É–∂–Ω–æ –ø–æ–º–µ—Å—Ç–∏—Ç—å
4. –ë—É–¥—å –∫—Ä–∞—Ç–æ–∫ –Ω–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–µ–Ω`,
		session.ProjectName,
		session.Analysis.Language,
		len(session.Files),
		projectContext,
		question)

	resp, err := h.llmClient.Generate(ctx, []llm.Message{{Role: "user", Content: prompt}})
	if err != nil {
		return "", fmt.Errorf("failed to generate response: %w", err)
	}

	return resp.Content, nil
}

// generateTestsWithProgress –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç—ã —Å –¥–µ—Ç–∞–ª—å–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –≤ Telegram
func (h *VibeCodingHandler) generateTestsWithProgress(ctx context.Context, session *VibeCodingSession, chatID int64, messageID int) (map[string]string, error) {
	maxAttempts := 5
	var lastError error

	for attempt := 1; attempt <= maxAttempts; attempt++ {
		// –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º
		progressMsg := fmt.Sprintf("[vibecoding] üß† –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤... (–ø–æ–ø—ã—Ç–∫–∞ %d/%d)", attempt, maxAttempts)
		h.updateMessage(chatID, messageID, progressMsg)

		log.Printf("üß™ Test generation attempt %d/%d", attempt, maxAttempts)

		// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ—Å—Ç—ã
		tests, err := h.generateTestsOnce(ctx, session, attempt)
		if err != nil {
			lastError = fmt.Errorf("test generation failed: %w", err)
			log.Printf("‚ùå Test generation attempt %d failed: %v", attempt, err)

			// –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
			errorMsg := fmt.Sprintf("[vibecoding] ‚ö†Ô∏è –ü–æ–ø—ã—Ç–∫–∞ %d/%d –Ω–µ —É–¥–∞–ª–∞—Å—å: %s", attempt, maxAttempts, err.Error())
			h.updateMessage(chatID, messageID, errorMsg)
			time.Sleep(2 * time.Second) // –î–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø—Ä–æ—á–∏—Ç–∞—Ç—å –æ—à–∏–±–∫—É
			continue
		}

		if len(tests) == 0 {
			lastError = fmt.Errorf("no tests generated")
			log.Printf("‚ö†Ô∏è No tests generated on attempt %d", attempt)

			// –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
			h.updateMessage(chatID, messageID, fmt.Sprintf("[vibecoding] ‚ö†Ô∏è –ü–æ–ø—ã—Ç–∫–∞ %d/%d: —Ç–µ—Å—Ç—ã –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã", attempt, maxAttempts))
			time.Sleep(2 * time.Second)
			continue
		}

		// –í–∞–ª–∏–¥–∏—Ä—É–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã
		validationMsg := fmt.Sprintf("[vibecoding] üîç –í–∞–ª–∏–¥–∞—Ü–∏—è %d —Ç–µ—Å—Ç–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤... (–ø–æ–ø—ã—Ç–∫–∞ %d/%d)", len(tests), attempt, maxAttempts)
		h.updateMessage(chatID, messageID, validationMsg)
		log.Printf("üîç Validating %d generated test files", len(tests))

		validationResult, err := h.validateGeneratedTests(ctx, session, tests)
		if err != nil {
			log.Printf("‚ùå Test validation failed on attempt %d: %v", attempt, err)
			lastError = err

			// –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
			h.updateMessage(chatID, messageID, fmt.Sprintf("[vibecoding] ‚ùå –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–µ –ø—Ä–æ—à–ª–∞ (–ø–æ–ø—ã—Ç–∫–∞ %d/%d): %s", attempt, maxAttempts, err.Error()))
			time.Sleep(2 * time.Second)
			continue
		}

		if validationResult.Success {
			log.Printf("‚úÖ All tests passed validation on attempt %d", attempt)

			// –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—Ö–µ
			successMsg := fmt.Sprintf("[vibecoding] ‚úÖ –¢–µ—Å—Ç—ã —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –∏ –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã (–ø–æ–ø—ã—Ç–∫–∞ %d/%d)", attempt, maxAttempts)
			h.updateMessage(chatID, messageID, successMsg)

			return validationResult.ValidTests, nil
		}

		// –ï—Å–ª–∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–µ –ø—Ä–æ—à–ª–∞, –ø—ã—Ç–∞–µ–º—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç—ã
		if attempt < maxAttempts {
			log.Printf("üîß Attempting to fix test issues on attempt %d", attempt)

			// –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–∏
			fixMsg := fmt.Sprintf("[vibecoding] üîß –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—à–∏–±–æ–∫ —Ç–µ—Å—Ç–æ–≤... (–ø–æ–ø—ã—Ç–∫–∞ %d/%d)", attempt, maxAttempts)
			h.updateMessage(chatID, messageID, fixMsg)

			fixedTests, err := h.fixTestIssues(ctx, session, tests, validationResult)
			if err != nil {
				log.Printf("‚ö†Ô∏è Could not fix test issues: %v", err)
				lastError = fmt.Errorf("test fixing failed: %w", err)

				h.updateMessage(chatID, messageID, fmt.Sprintf("[vibecoding] ‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø—Ä–∞–≤–∏—Ç—å –æ—à–∏–±–∫–∏ (–ø–æ–ø—ã—Ç–∫–∞ %d/%d)", attempt, maxAttempts))
				time.Sleep(2 * time.Second)
				continue
			}
			// –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
			tests = fixedTests

			// –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–∏
			h.updateMessage(chatID, messageID, fmt.Sprintf("[vibecoding] ‚úÖ –û—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã, –ø–æ–≤—Ç–æ—Ä –≤–∞–ª–∏–¥–∞—Ü–∏–∏... (–ø–æ–ø—ã—Ç–∫–∞ %d/%d)", attempt, maxAttempts))
		} else {
			lastError = fmt.Errorf("test validation failed after %d attempts", maxAttempts)
		}
	}

	// –ï—Å–ª–∏ –≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –Ω–µ—É–¥–∞—á–Ω—ã, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É
	log.Printf("‚ùå Test generation and validation failed after %d attempts", maxAttempts)
	finalErrorMsg := fmt.Sprintf("[vibecoding] ‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç–µ—Å—Ç—ã –ø–æ—Å–ª–µ %d –ø–æ–ø—ã—Ç–æ–∫: %s", maxAttempts, lastError.Error())
	h.updateMessage(chatID, messageID, finalErrorMsg)

	return nil, fmt.Errorf("test generation failed after %d attempts: %w", maxAttempts, lastError)
}

// generateTests –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç—ã –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞ —á–µ—Ä–µ–∑ JSON –ø—Ä–æ—Ç–æ–∫–æ–ª —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π –∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º (–±–µ–∑ Telegram updates)
func (h *VibeCodingHandler) generateTests(ctx context.Context, session *VibeCodingSession) (map[string]string, error) {
	maxAttempts := 5
	var lastError error

	for attempt := 1; attempt <= maxAttempts; attempt++ {
		log.Printf("üß™ Test generation attempt %d/%d", attempt, maxAttempts)

		// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ—Å—Ç—ã
		tests, err := h.generateTestsOnce(ctx, session, attempt)
		if err != nil {
			lastError = fmt.Errorf("test generation failed: %w", err)
			log.Printf("‚ùå Test generation attempt %d failed: %v", attempt, err)
			continue
		}

		if len(tests) == 0 {
			lastError = fmt.Errorf("no tests generated")
			log.Printf("‚ö†Ô∏è No tests generated on attempt %d", attempt)
			continue
		}

		// –í–∞–ª–∏–¥–∏—Ä—É–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã
		log.Printf("üîç Validating %d generated test files", len(tests))
		validationResult, err := h.validateGeneratedTests(ctx, session, tests)
		if err != nil {
			log.Printf("‚ùå Test validation failed on attempt %d: %v", attempt, err)
			lastError = err
			continue
		}

		if validationResult.Success {
			log.Printf("‚úÖ All tests passed validation on attempt %d", attempt)
			return validationResult.ValidTests, nil
		}

		// –ï—Å–ª–∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–µ –ø—Ä–æ—à–ª–∞, –ø—ã—Ç–∞–µ–º—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç—ã
		if attempt < maxAttempts {
			log.Printf("üîß Attempting to fix test issues on attempt %d", attempt)
			fixedTests, err := h.fixTestIssues(ctx, session, tests, validationResult)
			if err != nil {
				log.Printf("‚ö†Ô∏è Could not fix test issues: %v", err)
				lastError = fmt.Errorf("test fixing failed: %w", err)
				continue
			}

			// –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
			tests = fixedTests
		} else {
			lastError = fmt.Errorf("test validation failed after %d attempts", maxAttempts)
		}
	}

	// –ï—Å–ª–∏ –≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –Ω–µ—É–¥–∞—á–Ω—ã, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É –±–µ–∑ fallback
	log.Printf("‚ùå Test generation and validation failed after %d attempts", maxAttempts)
	return nil, fmt.Errorf("test generation failed after %d attempts: %w", maxAttempts, lastError)
}

// generateTestsOnce –≤—ã–ø–æ–ª–Ω—è–µ—Ç –æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Ç–µ—Å—Ç–æ–≤
func (h *VibeCodingHandler) generateTestsOnce(ctx context.Context, session *VibeCodingSession, attempt int) (map[string]string, error) {
	// –°–Ω–∞—á–∞–ª–∞ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –Ω–∞–ø–∏—Å–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤
	testPrompt, err := h.generateTestWritingPrompt(ctx, session)
	if err != nil {
		log.Printf("‚ö†Ô∏è Failed to generate test writing prompt: %v, using default", err)
		testPrompt = fmt.Sprintf("Generate comprehensive tests for this %s project. Include unit tests and integration tests where appropriate. Follow best practices and testing conventions for %s.", session.Analysis.Language, session.Analysis.Language)
	}

	log.Printf("üéØ Generated specialized test writing prompt for %s", session.Analysis.Language)

	// –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ JSON –ø—Ä–æ—Ç–æ–∫–æ–ª —Å —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –ø—Ä–æ–º–ø—Ç–æ–º
	query := testPrompt

	if attempt > 1 {
		query += fmt.Sprintf(" This is attempt %d - ensure tests are syntactically correct and runnable.", attempt)
	}

	request := VibeCodingRequest{
		Action: "generate_code",
		Context: VibeCodingContext{
			ProjectName:     session.ProjectName,
			Language:        session.Analysis.Language,
			Files:           session.Files,
			GeneratedFiles:  session.GeneratedFiles,
			SessionDuration: time.Since(session.StartTime).Round(time.Second).String(),
		},
		Query: query,
		Options: map[string]interface{}{
			"task_type": "test_generation",
			"language":  session.Analysis.Language,
			"attempt":   attempt,
		},
	}

	// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ –ø—Ä–æ—Ç–æ–∫–æ–ª –∫–ª–∏–µ–Ω—Ç
	response, err := h.protocolClient.ProcessRequest(ctx, request)
	if err != nil {
		return nil, fmt.Errorf("JSON protocol request failed: %w", err)
	}

	// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç
	if response.Status == "error" {
		return nil, fmt.Errorf("LLM returned error: %s", response.Error)
	}

	if len(response.Code) == 0 {
		return nil, fmt.Errorf("no code generated")
	}

	log.Printf("Generated tests code:\n%s", response.Code)

	return response.Code, nil
}

// buildProjectContext —Å—Ç—Ä–æ–∏—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞ –¥–ª—è LLM
func (h *VibeCodingHandler) buildProjectContext(session *VibeCodingSession) string {
	// –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∂–∞—Ç—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω
	if session.Context != nil {
		return h.buildCompressedContext(session)
	}

	// Fallback –∫ —Å—Ç–∞—Ä–æ–º—É –º–µ—Ç–æ–¥—É –µ—Å–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω
	var context strings.Builder
	context.WriteString("‚ö†Ô∏è Project context not available, using file excerpts:\n\n")

	for filename, content := range session.Files {
		context.WriteString(fmt.Sprintf("\n=== %s ===\n", filename))

		// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
		if len(content) > 2000 {
			context.WriteString(content[:2000])
			context.WriteString("\n... (—Ñ–∞–π–ª –æ–±—Ä–µ–∑–∞–Ω)")
		} else {
			context.WriteString(content)
		}
		context.WriteString("\n")
	}

	return context.String()
}

// buildCompressedContext —Å—Ç—Ä–æ–∏—Ç —Å–∂–∞—Ç—ã–π LLM-–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è LLM
func (h *VibeCodingHandler) buildCompressedContext(session *VibeCodingSession) string {
	var context strings.Builder

	ctx := session.Context

	context.WriteString("# LLM-Generated Compressed Project Context\n\n")
	context.WriteString(fmt.Sprintf("**Project:** %s | **Language:** %s | **Files:** %d | **Tokens:** %d/%d\n",
		ctx.ProjectName, ctx.Language, ctx.TotalFiles, ctx.TokensUsed, ctx.TokensLimit))

	if ctx.Description != "" {
		context.WriteString(fmt.Sprintf("**Description:** %s\n", ctx.Description))
	}
	context.WriteString("\n")

	// –ö—Ä–∞—Ç–∫–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞
	context.WriteString("## Project Structure:\n")
	for i, dir := range ctx.Structure.Directories {
		if i >= 5 { // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–æ–ø-5 –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
			context.WriteString(fmt.Sprintf("- ... –∏ –µ—â–µ %d –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π\n", len(ctx.Structure.Directories)-5))
			break
		}
		context.WriteString(fmt.Sprintf("- **%s** (%d files) - %s\n", dir.Path, dir.FileCount, dir.Purpose))
	}
	context.WriteString("\n")

	// LLM-—Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–ø–∏—Å–∞–Ω–∏—è —Ñ–∞–π–ª–æ–≤
	context.WriteString("## Key Files & LLM-Generated Descriptions:\n")
	fileCount := 0
	for filePath, fileCtx := range ctx.Files {
		if fileCount >= 10 { // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 10 —Ñ–∞–π–ª–æ–≤
			context.WriteString(fmt.Sprintf("- ... –∏ –µ—â–µ %d —Ñ–∞–π–ª–æ–≤ (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ MCP tools –¥–ª—è –¥–æ—Å—Ç—É–ø–∞)\n", len(ctx.Files)-10))
			break
		}
		fileCount++

		context.WriteString(fmt.Sprintf("\n### %s (%s, %d bytes, %d tokens)\n", filePath, fileCtx.Type, fileCtx.Size, fileCtx.TokensUsed))

		if fileCtx.Summary != "" {
			context.WriteString(fmt.Sprintf("**Summary:** %s\n", fileCtx.Summary))
		}

		if fileCtx.Purpose != "" {
			context.WriteString(fmt.Sprintf("**Purpose:** %s\n", fileCtx.Purpose))
		}

		// –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–ª—é—á–µ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã (LLM-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ)
		if len(fileCtx.KeyElements) > 0 {
			context.WriteString(fmt.Sprintf("**Key Elements (%d):** ", len(fileCtx.KeyElements)))
			elementNames := make([]string, 0, len(fileCtx.KeyElements))
			for j, element := range fileCtx.KeyElements {
				if j >= 5 { // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 5 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
					elementNames = append(elementNames, "...")
					break
				}
				elementNames = append(elementNames, element)
			}
			context.WriteString(strings.Join(elementNames, ", ") + "\n")
		}

		// –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —Ñ–∞–π–ª–∞
		if len(fileCtx.Dependencies) > 0 {
			context.WriteString(fmt.Sprintf("**Dependencies:** %s\n", strings.Join(fileCtx.Dependencies, ", ")))
		}
	}

	// –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å MCP
	context.WriteString("\n## üîß MCP Tools Available:\n")
	context.WriteString("- `vibe_list_files` - –ø–æ–ª—É—á–∏—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤\n")
	context.WriteString("- `vibe_read_file` - –ø—Ä–æ—á–∏—Ç–∞—Ç—å –ø–æ–ª–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞\n")
	context.WriteString("- `vibe_write_file` - —Å–æ–∑–¥–∞—Ç—å –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å —Ñ–∞–π–ª\n")
	context.WriteString("- `vibe_execute_command` - –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∫–æ–º–∞–Ω–¥—É –≤ –æ–∫—Ä—É–∂–µ–Ω–∏–∏\n")
	context.WriteString("- `vibe_run_tests` - –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç—ã –ø—Ä–æ–µ–∫—Ç–∞\n")
	context.WriteString("- `vibe_validate_code` - –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∫–æ–¥–∞\n")
	context.WriteString("- `vibe_get_session_info` - –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–µ—Å—Å–∏–∏\n\n")

	context.WriteString("**–í–ê–ñ–ù–û:** –≠—Ç–æ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è LLM —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —Ç–æ–∫–µ–Ω–æ–≤. ")
	context.WriteString("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ MCP tools –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª–Ω–æ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ —Ñ–∞–π–ª–æ–≤ –∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π. ")
	context.WriteString("–î–ª—è –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤ LLM –º–æ–∂–µ—Ç –∑–∞–ø—Ä–æ—Å–∏—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —á–µ—Ä–µ–∑ MCP –ø–æ –º–µ—Ä–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏.\n")

	// –î–æ–±–∞–≤–ª—è–µ–º PROJECT_CONTEXT.md –≤ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ MCP
	if _, exists := session.GeneratedFiles["PROJECT_CONTEXT.md"]; exists {
		context.WriteString("\nüìã –ü–æ–ª–Ω—ã–π LLM-–∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–æ—Å—Ç—É–ø–µ–Ω –≤ —Ñ–∞–π–ª–µ PROJECT_CONTEXT.md (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ vibe_read_file)\n")
	}

	return context.String()
}

// sendLongMessage –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –¥–ª–∏–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, —Ä–∞–∑–±–∏–≤–∞—è –µ–≥–æ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
func (h *VibeCodingHandler) sendLongMessage(chatID int64, text string) error {
	maxLength := 4000 // –û—Å—Ç–∞–≤–ª—è–µ–º –Ω–µ–º–Ω–æ–≥–æ –º–µ—Å—Ç–∞ –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞

	if len(text) <= maxLength {
		msg := tgbotapi.NewMessage(chatID, h.formatter.EscapeText(text))
		msg.ParseMode = h.formatter.ParseModeValue()
		_, err := h.sender.Send(msg)
		return err
	}

	// –†–∞–∑–±–∏–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —á–∞—Å—Ç–∏
	parts := h.splitMessage(text, maxLength)
	for i, part := range parts {
		partText := part
		if len(parts) > 1 {
			partText = fmt.Sprintf("%s\n\n<i>–ß–∞—Å—Ç—å %d –∏–∑ %d</i>", part, i+1, len(parts))
		}

		msg := tgbotapi.NewMessage(chatID, h.formatter.EscapeText(partText))
		msg.ParseMode = h.formatter.ParseModeValue()
		_, err := h.sender.Send(msg)
		if err != nil {
			return err
		}

		time.Sleep(100 * time.Millisecond) // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
	}

	return nil
}

// splitMessage —Ä–∞–∑–±–∏–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ –ª–æ–≥–∏—á–µ—Å–∫–∏–µ —á–∞—Å—Ç–∏
func (h *VibeCodingHandler) splitMessage(text string, maxLength int) []string {
	if len(text) <= maxLength {
		return []string{text}
	}

	var parts []string
	remaining := text

	for len(remaining) > maxLength {
		// –ò—â–µ–º –ø–æ–¥—Ö–æ–¥—è—â–µ–µ –º–µ—Å—Ç–æ –¥–ª—è —Ä–∞–∑—Ä—ã–≤–∞ (–∫–æ–Ω–µ—Ü —Å—Ç—Ä–æ–∫–∏, –±–ª–æ–∫–∞ –∫–æ–¥–∞ –∏ —Ç.–¥.)
		breakPoint := maxLength

		// –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø–µ—Ä–µ–Ω–æ—Å —Å—Ç—Ä–æ–∫–∏ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –ª–∏–º–∏—Ç–∞
		for i := maxLength - 1; i > maxLength/2; i-- {
			if remaining[i] == '\n' {
				breakPoint = i + 1
				break
			}
		}

		parts = append(parts, remaining[:breakPoint])
		remaining = remaining[breakPoint:]
	}

	if len(remaining) > 0 {
		parts = append(parts, remaining)
	}

	return parts
}

// TestValidationResult –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤
type TestValidationResult struct {
	Success    bool              `json:"success"`
	ValidTests map[string]string `json:"valid_tests"`
	Issues     []TestIssue       `json:"issues"`
	Output     string            `json:"output"`
}

// TestIssue –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –ø—Ä–æ–±–ª–µ–º—É –≤ —Ç–µ—Å—Ç–µ
type TestIssue struct {
	Filename    string `json:"filename"`
	Type        string `json:"type"` // "syntax_error", "runtime_error", "missing_dependency", "invalid_test"
	Description string `json:"description"`
	Line        int    `json:"line,omitempty"`
}

// TestLLMValidationRequest –∑–∞–ø—Ä–æ—Å –Ω–∞ –≤–∞–ª–∏–¥–∞—Ü–∏—é —Ç–µ—Å—Ç–æ–≤ —á–µ—Ä–µ–∑ LLM
type TestLLMValidationRequest struct {
	Language     string            `json:"language"`
	ProjectFiles map[string]string `json:"project_files"`
	TestFiles    map[string]string `json:"test_files"`
	Context      string            `json:"context"`
}

// TestLLMValidationResponse –æ—Ç–≤–µ—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤ —á–µ—Ä–µ–∑ LLM
type TestLLMValidationResponse struct {
	Status      string                   `json:"status"` // "ok", "needs_fix", "error"
	Issues      []TestLLMValidationIssue `json:"issues,omitempty"`
	FixedTests  map[string]string        `json:"fixed_tests,omitempty"`
	Reasoning   string                   `json:"reasoning"`
	Suggestions []string                 `json:"suggestions,omitempty"`
}

// TestLLMValidationIssue –ø—Ä–æ–±–ª–µ–º–∞ –Ω–∞–π–¥–µ–Ω–Ω–∞—è LLM –≤ —Ç–µ—Å—Ç–∞—Ö
type TestLLMValidationIssue struct {
	Filename   string `json:"filename"`
	Issue      string `json:"issue"`
	Severity   string `json:"severity"` // "critical", "warning", "info"
	Fix        string `json:"fix"`
	LineNumber int    `json:"line_number,omitempty"`
}

// validateGeneratedTests –≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã —Å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º
func (h *VibeCodingHandler) validateGeneratedTests(ctx context.Context, session *VibeCodingSession, tests map[string]string) (*TestValidationResult, error) {
	log.Printf("üîç Starting strict validation of %d test files", len(tests))

	// –°–Ω–∞—á–∞–ª–∞ –≤–∞–ª–∏–¥–∏—Ä—É–µ–º —Ç–µ—Å—Ç—ã —á–µ—Ä–µ–∑ LLM
	llmValidatedTests, err := h.validateTestsWithLLM(ctx, session, tests)
	if err != nil {
		log.Printf("‚ö†Ô∏è LLM validation failed, proceeding with original tests: %v", err)
		// –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–º–∏ —Ç–µ—Å—Ç–∞–º–∏ –µ—Å–ª–∏ LLM –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å
		llmValidatedTests = tests
	}

	log.Printf("‚úÖ LLM validation complete, proceeding with execution validation of %d test files", len(llmValidatedTests))

	result := &TestValidationResult{
		Success:    true,
		ValidTests: make(map[string]string),
		Issues:     make([]TestIssue, 0),
	}

	// –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –∫–æ–ø–∏—é —Ñ–∞–π–ª–æ–≤ —Å–µ—Å—Å–∏–∏ —Å –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Ç–µ—Å—Ç–∞–º–∏
	tempFiles := make(map[string]string)
	for k, v := range session.Files {
		tempFiles[k] = v
	}
	for filename, content := range llmValidatedTests {
		tempFiles[filename] = content
	}

	// –ö–æ–ø–∏—Ä—É–µ–º —Ñ–∞–π–ª—ã –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
	if err := session.Docker.CopyFilesToContainer(ctx, session.ContainerID, tempFiles); err != nil {
		return nil, fmt.Errorf("failed to copy test files to container: %w", err)
	}

	// –ö–†–ò–¢–ò–ß–ù–û: –≤—ã–ø–æ–ª–Ω—è–µ–º —Ä–µ–∞–ª—å–Ω—É—é –≤–∞–ª–∏–¥–∞—Ü–∏—é –∫–∞–∂–¥–æ–≥–æ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞
	for filename, content := range llmValidatedTests {
		log.Printf("üîç Executing real validation for test file: %s", filename)

		// –í—ã–ø–æ–ª–Ω—è–µ–º –§–ê–ö–¢–ò–ß–ï–°–ö–û–ï –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤ –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
		executionOK, executionIssue := h.executeTestForValidation(ctx, session, filename)
		if !executionOK {
			result.Success = false
			result.Issues = append(result.Issues, *executionIssue)
			log.Printf("‚ùå Test execution validation FAILED for %s: %s", filename, executionIssue.Description)

			// –ù–ï –¥–æ–±–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –≤ valid_tests –µ—Å–ª–∏ –æ–Ω –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è
			continue
		}

		// –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –≤ –≤–∞–ª–∏–¥–Ω—ã–µ —Ç–µ—Å—Ç—ã –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –æ–Ω –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è
		result.ValidTests[filename] = content
		log.Printf("‚úÖ Test file %s PASSED execution validation", filename)
	}

	log.Printf("üîç Strict validation complete: %d valid files, %d issues found", len(result.ValidTests), len(result.Issues))

	// –ï—Å–ª–∏ –ù–ò –û–î–ò–ù —Ç–µ—Å—Ç –Ω–µ –ø—Ä–æ—à–µ–ª –≤–∞–ª–∏–¥–∞—Ü–∏—é - —ç—Ç–æ –æ—à–∏–±–∫–∞
	if len(result.ValidTests) == 0 && len(llmValidatedTests) > 0 {
		result.Success = false
		log.Printf("‚ùå CRITICAL: No tests passed execution validation")
	}

	return result, nil
}

// executeTestForValidation –≤—ã–ø–æ–ª–Ω—è–µ—Ç —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —Å—Ç—Ä–æ–≥–æ–π –≤–∞–ª–∏–¥–∞—Ü–∏–∏
func (h *VibeCodingHandler) executeTestForValidation(ctx context.Context, session *VibeCodingSession, filename string) (bool, *TestIssue) {
	log.Printf("üß™ Executing test file for validation: %s", filename)

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–º–∞–Ω–¥—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑ LLM –∞–Ω–∞–ª–∏–∑–∞
	if len(session.Analysis.TestCommands) == 0 {
		log.Printf("‚ùå No test commands provided by LLM analysis for validation of %s", filename)
		return false, &TestIssue{
			Filename:    filename,
			Type:        "configuration_error",
			Description: "No test commands available for validation",
		}
	}

	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–¥—Ö–æ–¥—è—â—É—é –∫–æ–º–∞–Ω–¥—É —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ LLM
	var command string
	for _, testCmd := range session.Analysis.TestCommands {
		// –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–µ—Ä–µ–∑ LLM, –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
		if h.isTestCommandSuitableForFile(ctx, testCmd, filename, session.Analysis.Language) {
			command = h.adaptTestCommandForFile(ctx, testCmd, filename, session.Analysis.Language)
			break
		}
	}

	// –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ–¥—Ö–æ–¥—è—â—É—é –∫–æ–º–∞–Ω–¥—É, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—É—é –∏ –∞–¥–∞–ø—Ç–∏—Ä—É–µ–º —á–µ—Ä–µ–∑ LLM
	if command == "" && len(session.Analysis.TestCommands) > 0 {
		command = h.adaptTestCommandForFile(ctx, session.Analysis.TestCommands[0], filename, session.Analysis.Language)
	}

	if command == "" {
		log.Printf("‚ùå No suitable test command found for validation of %s", filename)
		return false, &TestIssue{
			Filename:    filename,
			Type:        "configuration_error",
			Description: "No suitable test command found",
		}
	}

	log.Printf("üß™ Executing validation command for %s: %s", filename, command)

	// –ö–†–ò–¢–ò–ß–ù–û: –≤—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—É —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Å—Ç—Ä–æ–≥–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
	result, err := session.ExecuteCommand(ctx, command)
	if err != nil {
		log.Printf("‚ùå Test execution FAILED for %s: %v", filename, err)
		return false, &TestIssue{
			Filename:    filename,
			Type:        "execution_error",
			Description: fmt.Sprintf("Test execution failed: %v", err),
		}
	}

	// –°–¢–†–û–ì–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞: —Ç–µ—Å—Ç—ã –¥–æ–ª–∂–Ω—ã –≤—ã–ø–æ–ª–Ω—è—Ç—å—Å—è –ë–ï–ó –æ—à–∏–±–æ–∫
	if result.ExitCode != 0 {
		log.Printf("‚ùå Test validation FAILED for %s with exit code %d", filename, result.ExitCode)

		// –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–∏–ø –æ—à–∏–±–∫–∏ –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
		errorType := "test_failure"
		if strings.Contains(result.Output, "SyntaxError") ||
			strings.Contains(result.Output, "IndentationError") ||
			strings.Contains(result.Output, "compilation error") ||
			strings.Contains(result.Output, "syntax error") {
			errorType = "syntax_error"
		} else if strings.Contains(result.Output, "ModuleNotFoundError") ||
			strings.Contains(result.Output, "cannot find module") ||
			strings.Contains(result.Output, "ImportError") ||
			strings.Contains(result.Output, "package") && strings.Contains(result.Output, "not found") {
			errorType = "missing_dependency"
		} else if strings.Contains(result.Output, "NameError") ||
			strings.Contains(result.Output, "AttributeError") ||
			strings.Contains(result.Output, "is not defined") {
			errorType = "invalid_reference"
		}

		return false, &TestIssue{
			Filename:    filename,
			Type:        errorType,
			Description: fmt.Sprintf("Test failed with exit code %d: %s", result.ExitCode, result.Output),
		}
	}

	// –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: —É–±–µ–∂–¥–∞–µ–º—Å—è —á—Ç–æ —Ç–µ—Å—Ç—ã —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ –≤—ã–ø–æ–ª–Ω–∏–ª–∏—Å—å
	if !result.Success {
		log.Printf("‚ùå Test execution marked as unsuccessful for %s", filename)
		return false, &TestIssue{
			Filename:    filename,
			Type:        "execution_error",
			Description: fmt.Sprintf("Test execution unsuccessful: %s", result.Output),
		}
	}

	log.Printf("‚úÖ Test file %s PASSED validation execution", filename)
	return true, nil
}

// Note: validateTestSyntax –º–µ—Ç–æ–¥ —É–¥–∞–ª–µ–Ω - —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞—é—Ç—Å—è –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ —Ç–µ—Å—Ç–æ–≤

// validateTestExecution –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –≤—ã–ø–æ–ª–Ω–∏–º–æ—Å—Ç—å —Ç–µ—Å—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–∞–Ω–¥—ã –∏–∑ LLM –∞–Ω–∞–ª–∏–∑–∞ (—É—Å—Ç–∞—Ä–µ–≤—à–∏–π, –∑–∞–º–µ–Ω–µ–Ω –Ω–∞ executeTestForValidation)
func (h *VibeCodingHandler) validateTestExecution(ctx context.Context, session *VibeCodingSession, filename string) (bool, *TestIssue) {
	// –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–º–∞–Ω–¥—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑ LLM –∞–Ω–∞–ª–∏–∑–∞
	if len(session.Analysis.TestCommands) == 0 {
		log.Printf("‚ÑπÔ∏è No test commands provided by LLM analysis, skipping test execution validation for %s", filename)
		return true, nil
	}

	// –í—ã–±–∏—Ä–∞–µ–º –ø–æ–¥—Ö–æ–¥—è—â—É—é –∫–æ–º–∞–Ω–¥—É —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ LLM
	var command string
	for _, testCmd := range session.Analysis.TestCommands {
		// –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–µ—Ä–µ–∑ LLM, –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
		if h.isTestCommandSuitableForFile(ctx, testCmd, filename, session.Analysis.Language) {
			command = h.adaptTestCommandForFile(ctx, testCmd, filename, session.Analysis.Language)
			break
		}
	}

	// –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ–¥—Ö–æ–¥—è—â—É—é –∫–æ–º–∞–Ω–¥—É, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—É—é –∏ –∞–¥–∞–ø—Ç–∏—Ä—É–µ–º —á–µ—Ä–µ–∑ LLM
	if command == "" && len(session.Analysis.TestCommands) > 0 {
		command = h.adaptTestCommandForFile(ctx, session.Analysis.TestCommands[0], filename, session.Analysis.Language)
	}

	if command == "" {
		log.Printf("‚ÑπÔ∏è No suitable test command found for %s", filename)
		return true, nil
	}

	log.Printf("üß™ Executing test command for %s: %s", filename, command)

	result, err := session.ExecuteCommand(ctx, command)
	if err != nil {
		return false, &TestIssue{
			Filename:    filename,
			Type:        "runtime_error",
			Description: fmt.Sprintf("Test execution failed: %v", err),
		}
	}

	// –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Ç–µ—Å—Ç—ã –º–æ–≥—É—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è —Å –∫–æ–¥–æ–º –æ—à–∏–±–∫–∏, –Ω–æ —ç—Ç–æ –Ω–µ –∑–Ω–∞—á–∏—Ç —á—Ç–æ –æ–Ω–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã
	if !result.Success && result.ExitCode != 0 {
		// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –æ—à–∏–±–∫–æ–π missing dependency –∏–ª–∏ –ø–æ–¥–æ–±–Ω—ã–º
		if strings.Contains(result.Output, "ModuleNotFoundError") ||
			strings.Contains(result.Output, "cannot find module") ||
			strings.Contains(result.Output, "package") && strings.Contains(result.Output, "not found") {
			return false, &TestIssue{
				Filename:    filename,
				Type:        "missing_dependency",
				Description: fmt.Sprintf("Missing dependency: %s", result.Output),
			}
		}

		// –í –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–æ—Ä–º–∞–ª—å–Ω–æ (—Ç–µ—Å—Ç—ã –º–æ–≥—É—Ç –ø–∞–¥–∞—Ç—å)
		log.Printf("‚ÑπÔ∏è Test %s completed with non-zero exit code, but may be valid", filename)
	}

	return true, nil
}

// isTestCommandSuitableForFile –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —á–µ—Ä–µ–∑ LLM, –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –∫–æ–º–∞–Ω–¥–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
func (h *VibeCodingHandler) isTestCommandSuitableForFile(ctx context.Context, command, filename, language string) bool {
	systemPrompt := `You are a testing expert. Determine if a given test command is suitable for running a specific test file.

Respond with a JSON object matching this exact schema:
{
  "is_suitable": true/false,
  "confidence": "high|medium|low",
  "reasoning": "brief explanation"
}

Consider:
- Command compatibility with file type
- Language-specific testing frameworks  
- File extension matching
- Command syntax and parameters`

	userPrompt := fmt.Sprintf(`Is this test command suitable for this file?

Language: %s
Test Command: %s
Test File: %s

Determine if the command can properly execute tests in this file.`, language, command, filename)

	messages := []llm.Message{
		{Role: "system", Content: systemPrompt},
		{Role: "user", Content: userPrompt},
	}

	response, err := h.llmClient.Generate(ctx, messages)
	if err != nil {
		log.Printf("‚ö†Ô∏è LLM command suitability check failed for %s: %v, assuming suitable", filename, err)
		return true // Fallback: assume suitable
	}

	var suitabilityResponse struct {
		IsSuitable bool   `json:"is_suitable"`
		Confidence string `json:"confidence"`
		Reasoning  string `json:"reasoning"`
	}

	content := response.Content
	if strings.Contains(content, "```json") {
		start := strings.Index(content, "```json") + 7
		end := strings.Index(content[start:], "```")
		if end > 0 {
			content = strings.TrimSpace(content[start : start+end])
		}
	}

	if err := json.Unmarshal([]byte(content), &suitabilityResponse); err != nil {
		log.Printf("‚ö†Ô∏è Failed to parse LLM suitability response for %s: %v, assuming suitable", filename, err)
		return true
	}

	log.Printf("ü§ñ LLM command suitability for %s: suitable=%v (confidence: %s) - %s",
		filename, suitabilityResponse.IsSuitable, suitabilityResponse.Confidence, suitabilityResponse.Reasoning)

	return suitabilityResponse.IsSuitable
}

// adaptTestCommandForFile –∞–¥–∞–ø—Ç–∏—Ä—É–µ—Ç –∫–æ–º–∞–Ω–¥—É —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ LLM
func (h *VibeCodingHandler) adaptTestCommandForFile(ctx context.Context, command, filename, language string) string {
	systemPrompt := `You are a testing command expert. Adapt a generic test command to run a specific test file.

Respond with a JSON object matching this exact schema:
{
  "adapted_command": "modified command string",
  "changes_made": "description of changes",
  "reasoning": "brief explanation"
}

Consider:
- File-specific targeting in test commands
- Language-specific test runners
- Proper command syntax
- Framework-specific patterns`

	userPrompt := fmt.Sprintf(`Adapt this test command to run the specific test file:

Language: %s
Original Command: %s
Test File: %s

Modify the command to specifically target this test file while maintaining proper syntax.`, language, command, filename)

	messages := []llm.Message{
		{Role: "system", Content: systemPrompt},
		{Role: "user", Content: userPrompt},
	}

	response, err := h.llmClient.Generate(ctx, messages)
	if err != nil {
		log.Printf("‚ö†Ô∏è LLM command adaptation failed for %s: %v, using original command", filename, err)
		return command // Fallback: use original command
	}

	var adaptationResponse struct {
		AdaptedCommand string `json:"adapted_command"`
		ChangesMade    string `json:"changes_made"`
		Reasoning      string `json:"reasoning"`
	}

	content := response.Content
	if strings.Contains(content, "```json") {
		start := strings.Index(content, "```json") + 7
		end := strings.Index(content[start:], "```")
		if end > 0 {
			content = strings.TrimSpace(content[start : start+end])
		}
	}

	if err := json.Unmarshal([]byte(content), &adaptationResponse); err != nil {
		log.Printf("‚ö†Ô∏è Failed to parse LLM adaptation response for %s: %v, using original command", filename, err)
		return command
	}

	log.Printf("ü§ñ LLM command adaptation for %s: %s -> %s (%s)",
		filename, command, adaptationResponse.AdaptedCommand, adaptationResponse.Reasoning)

	if adaptationResponse.AdaptedCommand == "" {
		return command
	}

	return adaptationResponse.AdaptedCommand
}

// fixTestIssues –∏—Å–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã –≤ —Ç–µ—Å—Ç–∞—Ö —á–µ—Ä–µ–∑ LLM
func (h *VibeCodingHandler) fixTestIssues(ctx context.Context, session *VibeCodingSession, tests map[string]string, validationResult *TestValidationResult) (map[string]string, error) {
	if len(validationResult.Issues) == 0 {
		return tests, nil
	}

	log.Printf("üîß Attempting to fix %d test issues", len(validationResult.Issues))

	// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º –¥–ª—è LLM
	var issuesDescription strings.Builder
	issuesDescription.WriteString("Issues found in generated tests:\n")
	for i, issue := range validationResult.Issues {
		issuesDescription.WriteString(fmt.Sprintf("%d. File: %s, Type: %s, Description: %s\n",
			i+1, issue.Filename, issue.Type, issue.Description))
	}

	request := VibeCodingRequest{
		Action: "generate_code",
		Context: VibeCodingContext{
			ProjectName:     session.ProjectName,
			Language:        session.Analysis.Language,
			Files:           session.Files,
			GeneratedFiles:  session.GeneratedFiles,
			SessionDuration: time.Since(session.StartTime).Round(time.Second).String(),
		},
		Query: fmt.Sprintf(`Fix the following test issues for this %s project:

%s

Current test files that need fixing:
%s

Please fix the issues and return corrected test files. Remove any test files that cannot be fixed or are unnecessary.`,
			session.Analysis.Language,
			issuesDescription.String(),
			h.formatTestFiles(tests)),
		Options: map[string]interface{}{
			"task_type": "test_fixing",
			"language":  session.Analysis.Language,
			"issues":    validationResult.Issues,
		},
	}

	response, err := h.protocolClient.ProcessRequest(ctx, request)
	if err != nil {
		return nil, fmt.Errorf("failed to get test fixes from LLM: %w", err)
	}

	if response.Status == "error" {
		return nil, fmt.Errorf("LLM could not fix tests: %s", response.Error)
	}

	if len(response.Code) == 0 {
		return nil, fmt.Errorf("no fixed tests returned from LLM")
	}

	log.Printf("‚úÖ LLM provided %d fixed test files", len(response.Code))
	return response.Code, nil
}

// formatTestFiles —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ LLM
func (h *VibeCodingHandler) formatTestFiles(tests map[string]string) string {
	var result strings.Builder

	for filename, content := range tests {
		result.WriteString(fmt.Sprintf("\n=== %s ===\n", filename))
		if len(content) > 1000 {
			result.WriteString(content[:1000])
			result.WriteString("\n... (truncated)")
		} else {
			result.WriteString(content)
		}
		result.WriteString("\n")
	}

	return result.String()
}

// validateTestsWithLLM –≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç—ã —á–µ—Ä–µ–∑ LLM –ø–µ—Ä–µ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º
func (h *VibeCodingHandler) validateTestsWithLLM(ctx context.Context, session *VibeCodingSession, tests map[string]string) (map[string]string, error) {
	log.Printf("üß† Validating tests with LLM before execution")

	// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤
	systemPrompt := `You are an expert test reviewer and validator. Your task is to analyze generated test files and ensure they are:
1. Syntactically correct
2. Follow best practices for the given programming language
3. Actually test the code they're supposed to test (CRITICAL: only test functions/classes that actually exist)
4. Are runnable and don't have obvious errors
5. Don't test non-existent functions, classes, or methods

CRITICAL VALIDATION RULES:
- Only test functions and classes that are explicitly listed in the "AVAILABLE FUNCTIONS AND CLASSES" section
- Remove or fix any tests that try to test non-existent functions or classes
- Ensure imports correspond to actual project files
- Verify that method calls exist on the classes being tested

Respond with a JSON object matching this exact schema:

{
  "status": "ok|needs_fix|error",
  "issues": [
    {
      "filename": "test_file.py",
      "issue": "specific description of the issue",
      "severity": "critical|warning|info", 
      "fix": "specific fix to apply",
      "line_number": 42
    }
  ],
  "fixed_tests": {
    "test_file.py": "corrected test content"
  },
  "reasoning": "brief explanation of what was checked and why",
  "suggestions": ["improvement suggestions"]
}

Guidelines:
- Use "ok" if tests are good as-is
- Use "needs_fix" if tests have issues but can be fixed
- Use "error" if tests are completely broken or test non-existent code
- Only include "fixed_tests" if status is "needs_fix" and you can fix them
- Be specific about issues and fixes
- Remove any test files that are unnecessary or cannot be fixed
- Flag tests that reference functions/classes not in the available list as "critical" issues`

	// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
	userPrompt := fmt.Sprintf(`Please validate these test files for a %s project:

PROJECT CONTEXT:
Language: %s
Project: %s

%s

TEST FILES TO VALIDATE:
%s

CRITICAL VALIDATION REQUIREMENTS:
1. Every function/method call in tests MUST exist in the project files
2. Every class instantiation MUST reference existing classes
3. Every import MUST correspond to actual project files
4. No tests should reference non-existent code elements
5. All syntax must be correct and runnable
6. Test structure must follow %s testing conventions

Carefully cross-reference all test code against the available functions and classes listed above.`,
		session.Analysis.Language,
		session.Analysis.Language,
		session.ProjectName,
		h.formatProjectFilesForValidation(session.Files),
		h.formatTestFilesForValidation(tests),
		session.Analysis.Language)

	messages := []llm.Message{
		{Role: "system", Content: systemPrompt},
		{Role: "user", Content: userPrompt},
	}

	log.Printf("üîç Requesting test validation from LLM")

	maxAttempts := 3
	var lastError error

	for attempt := 1; attempt <= maxAttempts; attempt++ {
		response, err := h.llmClient.Generate(ctx, messages)
		if err != nil {
			lastError = fmt.Errorf("LLM validation request failed: %w", err)
			log.Printf("‚ùå LLM validation attempt %d failed: %v", attempt, err)
			continue
		}

		// –ü–∞—Ä—Å–∏–º JSON –æ—Ç–≤–µ—Ç
		var validationResponse TestLLMValidationResponse
		if err := json.Unmarshal([]byte(response.Content), &validationResponse); err != nil {
			// –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å JSON –∏–∑ markdown –±–ª–æ–∫–∞
			content := response.Content
			if strings.Contains(content, "```json") {
				start := strings.Index(content, "```json") + 7
				end := strings.Index(content[start:], "```")
				if end > 0 {
					content = strings.TrimSpace(content[start : start+end])
				}
			}

			if err := json.Unmarshal([]byte(content), &validationResponse); err != nil {
				lastError = fmt.Errorf("failed to parse LLM validation response: %w", err)
				log.Printf("‚ö†Ô∏è Failed to parse LLM response attempt %d: %v", attempt, err)
				log.Printf("Raw response: %s", response.Content)
				continue
			}
		}

		log.Printf("üîç LLM validation result: status=%s, issues=%d", validationResponse.Status, len(validationResponse.Issues))
		if validationResponse.Reasoning != "" {
			log.Printf("üß† LLM reasoning: %s", validationResponse.Reasoning)
		}

		switch validationResponse.Status {
		case "ok":
			log.Printf("‚úÖ LLM approved all tests as-is")
			return tests, nil

		case "needs_fix":
			if len(validationResponse.FixedTests) > 0 {
				log.Printf("üîß LLM provided %d fixed test files", len(validationResponse.FixedTests))
				// –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã
				for _, issue := range validationResponse.Issues {
					log.Printf("  üêõ Issue in %s: %s (severity: %s)", issue.Filename, issue.Issue, issue.Severity)
				}
				return validationResponse.FixedTests, nil
			} else {
				lastError = fmt.Errorf("LLM says tests need fixing but provided no fixed tests")
				log.Printf("‚ö†Ô∏è LLM indicated fixes needed but provided no fixed tests")
				continue
			}

		case "error":
			lastError = fmt.Errorf("LLM validation failed: tests have critical issues")
			log.Printf("‚ùå LLM validation failed: tests have critical issues")
			continue

		default:
			lastError = fmt.Errorf("unknown LLM validation status: %s", validationResponse.Status)
			log.Printf("‚ö†Ô∏è Unknown validation status: %s", validationResponse.Status)
			continue
		}
	}

	return nil, fmt.Errorf("LLM test validation failed after %d attempts: %w", maxAttempts, lastError)
}

// formatProjectFilesForValidation —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ñ–∞–π–ª—ã –ø—Ä–æ–µ–∫—Ç–∞ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
func (h *VibeCodingHandler) formatProjectFilesForValidation(files map[string]string) string {
	var result strings.Builder

	// –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–µ–º –æ–±–∑–æ—Ä –≤—Å–µ—Ö —Ñ—É–Ω–∫—Ü–∏–π –∏ –∫–ª–∞—Å—Å–æ–≤
	result.WriteString("AVAILABLE FUNCTIONS AND CLASSES:\n")
	result.WriteString(h.extractFunctionsAndClasses(files))
	result.WriteString("\n\nPROJECT FILES (sample content):\n")

	fileCount := 0
	maxFiles := 8 // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–∏–º–∏—Ç —Ñ–∞–π–ª–æ–≤

	for filename, content := range files {
		if fileCount >= maxFiles {
			result.WriteString("... (additional files not shown for brevity)\n")
			break
		}

		result.WriteString(fmt.Sprintf("=== %s ===\n", filename))
		if len(content) > 1500 { // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–∏–º–∏—Ç —Å–∏–º–≤–æ–ª–æ–≤
			result.WriteString(content[:1500])
			result.WriteString("\n... (truncated)\n")
		} else {
			result.WriteString(content)
		}
		result.WriteString("\n\n")
		fileCount++
	}

	return result.String()
}

// extractFunctionsAndClasses –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ñ—É–Ω–∫—Ü–∏–π –∏ –∫–ª–∞—Å—Å–æ–≤ –∏–∑ —Ñ–∞–π–ª–æ–≤ –ø—Ä–æ–µ–∫—Ç–∞
func (h *VibeCodingHandler) extractFunctionsAndClasses(files map[string]string) string {
	var result strings.Builder

	for filename, content := range files {
		lines := strings.Split(content, "\n")
		var functions, classes []string

		for _, line := range lines {
			trimmed := strings.TrimSpace(line)

			// Python/Go function detection
			if strings.HasPrefix(trimmed, "def ") || strings.HasPrefix(trimmed, "func ") {
				funcName := h.extractNameFromDefinition(trimmed)
				if funcName != "" {
					functions = append(functions, funcName)
				}
			}

			// Python/Go/Java class detection
			if strings.HasPrefix(trimmed, "class ") || strings.HasPrefix(trimmed, "type ") && strings.Contains(trimmed, "struct") {
				className := h.extractNameFromDefinition(trimmed)
				if className != "" {
					classes = append(classes, className)
				}
			}
		}

		if len(functions) > 0 || len(classes) > 0 {
			result.WriteString(fmt.Sprintf("File: %s\n", filename))
			if len(classes) > 0 {
				result.WriteString(fmt.Sprintf("  Classes: %s\n", strings.Join(classes, ", ")))
			}
			if len(functions) > 0 {
				result.WriteString(fmt.Sprintf("  Functions: %s\n", strings.Join(functions, ", ")))
			}
		}
	}

	return result.String()
}

// extractNameFromDefinition –∏–∑–≤–ª–µ–∫–∞–µ—Ç –∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏ –∏–ª–∏ –∫–ª–∞—Å—Å–∞ –∏–∑ —Å—Ç—Ä–æ–∫–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
func (h *VibeCodingHandler) extractNameFromDefinition(line string) string {
	parts := strings.Fields(line)
	if len(parts) < 2 {
		return ""
	}

	// –î–ª—è "def function_name(" –∏–ª–∏ "func functionName("
	if parts[0] == "def" {
		name := parts[1]
		if idx := strings.Index(name, "("); idx != -1 {
			return name[:idx]
		}
		return name
	}

	// –î–ª—è Go —Ñ—É–Ω–∫—Ü–∏–π: "func functionName(" –∏–ª–∏ "func (receiver) MethodName("
	if parts[0] == "func" {
		if len(parts) >= 2 && strings.HasPrefix(parts[1], "(") {
			// Go –º–µ—Ç–æ–¥: func (c *Config) GetName() string {
			// –ò—â–µ–º –∏–º—è –º–µ—Ç–æ–¥–∞ –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–π —Å–∫–æ–±–∫–∏
			for i := 2; i < len(parts); i++ {
				name := parts[i]
				if idx := strings.Index(name, "("); idx != -1 {
					return name[:idx]
				}
				if name != "" && !strings.Contains(name, ")") {
					return name
				}
			}
		} else {
			// Go —Ñ—É–Ω–∫—Ü–∏—è: func functionName() {
			name := parts[1]
			if idx := strings.Index(name, "("); idx != -1 {
				return name[:idx]
			}
			return name
		}
	}

	// –î–ª—è "class ClassName:" –∏–ª–∏ "type StructName struct"
	if parts[0] == "class" || parts[0] == "type" {
		name := parts[1]
		if idx := strings.Index(name, "("); idx != -1 {
			return name[:idx]
		}
		if idx := strings.Index(name, ":"); idx != -1 {
			return name[:idx]
		}
		if idx := strings.Index(name, " "); idx != -1 {
			return name[:idx]
		}
		return name
	}

	return ""
}

// formatTestFilesForValidation —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
func (h *VibeCodingHandler) formatTestFilesForValidation(tests map[string]string) string {
	var result strings.Builder

	for filename, content := range tests {
		result.WriteString(fmt.Sprintf("=== %s ===\n", filename))
		result.WriteString(content)
		result.WriteString("\n\n")
	}

	return result.String()
}

// updateMessage –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
func (h *VibeCodingHandler) updateMessage(chatID int64, messageID int, newText string) error {
	editMsg := tgbotapi.NewEditMessageText(chatID, messageID, h.formatter.EscapeText(newText))
	editMsg.ParseMode = h.formatter.ParseModeValue()
	_, err := h.sender.Send(editMsg)
	return err
}

// sendMessage –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º
func (h *VibeCodingHandler) sendMessage(chatID int64, text string) error {
	msg := tgbotapi.NewMessage(chatID, h.formatter.EscapeText(text))
	msg.ParseMode = h.formatter.ParseModeValue()
	_, err := h.sender.Send(msg)
	return err
}

// fixFailingTests –∏—Å–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–æ–≤–∞–ª–∏–≤–∞—é—â–∏–µ—Å—è —Ç–µ—Å—Ç—ã —á–µ—Ä–µ–∑ –∞–Ω–∞–ª–∏–∑ –≤—ã–≤–æ–¥–∞ LLM
func (h *VibeCodingHandler) fixFailingTests(ctx context.Context, session *VibeCodingSession, testResult *codevalidation.ValidationResult) error {
	log.Printf("üîß Analyzing failing tests for user %d", session.UserID)

	// –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç–µ—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã –∏–∑ —Å–µ—Å—Å–∏–∏ —á–µ—Ä–µ–∑ LLM –∞–Ω–∞–ª–∏–∑
	testFiles := make(map[string]string)
	for filename, content := range session.GeneratedFiles {
		// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã —á–µ—Ä–µ–∑ LLM –∞–Ω–∞–ª–∏–∑
		if h.isTestFile(ctx, filename, session.Analysis.Language) {
			testFiles[filename] = content
		}
	}

	if len(testFiles) == 0 {
		return fmt.Errorf("no test files found to fix")
	}

	// –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤
	query := fmt.Sprintf(`The tests are failing with the following output:

EXIT CODE: %d
OUTPUT:
%s

Please analyze the test failures and fix the test files to make them pass. Focus on:
1. Fixing syntax errors
2. Correcting import statements
3. Fixing assertion logic
4. Ensuring test setup is correct
5. Making tests compatible with the actual code structure

Provide updated test files that will pass.`, testResult.ExitCode, testResult.Output)

	request := VibeCodingRequest{
		Action: "generate_code",
		Context: VibeCodingContext{
			ProjectName:     session.ProjectName,
			Language:        session.Analysis.Language,
			Files:           session.Files,
			GeneratedFiles:  session.GeneratedFiles,
			SessionDuration: time.Since(session.StartTime).Round(time.Second).String(),
		},
		Query: query,
		Options: map[string]interface{}{
			"task_type":     "test_fixing",
			"language":      session.Analysis.Language,
			"failing_tests": testFiles,
			"test_output":   testResult.Output,
			"exit_code":     testResult.ExitCode,
		},
	}

	log.Printf("üß† Requesting test fixes from LLM")
	response, err := h.protocolClient.ProcessRequest(ctx, request)
	if err != nil {
		return fmt.Errorf("failed to get test fixes from LLM: %w", err)
	}

	if response.Status == "error" {
		return fmt.Errorf("LLM could not fix tests: %s", response.Error)
	}

	if len(response.Code) == 0 {
		return fmt.Errorf("no fixed tests returned from LLM")
	}

	// –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã –≤ —Å–µ—Å—Å–∏–∏
	for filename, content := range response.Code {
		session.AddGeneratedFile(filename, content)
		log.Printf("üîß Updated test file: %s (%d bytes)", filename, len(content))
	}

	// –ö–æ–ø–∏—Ä—É–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
	if err := session.Docker.CopyFilesToContainer(ctx, session.ContainerID, response.Code); err != nil {
		log.Printf("‚ö†Ô∏è Failed to copy fixed tests to container: %v", err)
		return fmt.Errorf("failed to update tests in container: %w", err)
	}

	log.Printf("‚úÖ Successfully applied %d test fixes", len(response.Code))
	return nil
}

// fixTestExecutionIssues –∏—Å–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã —Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º —Ç–µ—Å—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏)
func (h *VibeCodingHandler) fixTestExecutionIssues(ctx context.Context, session *VibeCodingSession, execError error) error {
	log.Printf("üîß Analyzing test execution issues for user %d", session.UserID)

	// –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
	query := fmt.Sprintf(`Test execution failed with the following error:

ERROR: %s

This appears to be an execution issue (not test failure). Please analyze and suggest fixes for:
1. Missing dependencies that need to be installed
2. Environment setup issues
3. Path or import problems
4. Configuration issues

Provide specific commands or configuration changes needed to fix the execution environment.`, execError.Error())

	request := VibeCodingRequest{
		Action: "analyze_error",
		Context: VibeCodingContext{
			ProjectName:     session.ProjectName,
			Language:        session.Analysis.Language,
			Files:           session.Files,
			GeneratedFiles:  session.GeneratedFiles,
			SessionDuration: time.Since(session.StartTime).Round(time.Second).String(),
		},
		Query: query,
		Options: map[string]interface{}{
			"task_type":        "execution_fix",
			"language":         session.Analysis.Language,
			"execution_error":  execError.Error(),
			"current_analysis": session.Analysis,
		},
	}

	log.Printf("üß† Requesting execution issue fixes from LLM")
	response, err := h.protocolClient.ProcessRequest(ctx, request)
	if err != nil {
		return fmt.Errorf("failed to get execution fixes from LLM: %w", err)
	}

	if response.Status == "error" {
		return fmt.Errorf("LLM could not fix execution issues: %s", response.Error)
	}

	// –ï—Å–ª–∏ LLM –ø—Ä–µ–¥–ª–æ–∂–∏–ª –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã —É—Å—Ç–∞–Ω–æ–≤–∫–∏, –≤—ã–ø–æ–ª–Ω—è–µ–º –∏—Ö
	if response.Metadata != nil {
		if additionalCommands, exists := response.Metadata["install_commands"].([]string); exists && len(additionalCommands) > 0 {
			log.Printf("üîß Executing additional installation commands: %v", additionalCommands)

			// –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏
			tempAnalysis := &codevalidation.CodeAnalysisResult{
				Language:        session.Analysis.Language,
				DockerImage:     session.Analysis.DockerImage,
				InstallCommands: additionalCommands,
				WorkingDir:      session.Analysis.WorkingDir,
			}

			// –í—ã–ø–æ–ª–Ω—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã —É—Å—Ç–∞–Ω–æ–≤–∫–∏
			if err := session.Docker.InstallDependencies(ctx, session.ContainerID, tempAnalysis); err != nil {
				log.Printf("‚ö†Ô∏è Failed to execute additional install commands: %v", err)
				return fmt.Errorf("failed to execute additional install commands: %w", err)
			}

			log.Printf("‚úÖ Successfully executed additional install commands")
		}
	}

	return nil
}

// isTestFile –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª —Ç–µ—Å—Ç–æ–≤—ã–º —á–µ—Ä–µ–∑ LLM –∞–Ω–∞–ª–∏–∑
func (h *VibeCodingHandler) isTestFile(ctx context.Context, filename string, projectLanguage string) bool {
	// –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫ LLM –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞
	systemPrompt := `You are a programming language expert. Determine if a given filename represents a test file.

Respond with a JSON object matching this exact schema:
{
  "is_test_file": true/false,
  "confidence": "high|medium|low",
  "reasoning": "brief explanation"
}

Consider:
- Common test file naming conventions for the specified language
- Directory structures
- File extensions
- Language-specific testing frameworks`

	userPrompt := fmt.Sprintf(`Is this file a test file?

Language: %s
Filename: %s

Please determine if this filename follows test file naming conventions for %s.`, projectLanguage, filename, projectLanguage)

	messages := []llm.Message{
		{Role: "system", Content: systemPrompt},
		{Role: "user", Content: userPrompt},
	}

	response, err := h.llmClient.Generate(ctx, messages)
	if err != nil {
		log.Printf("‚ö†Ô∏è LLM test file detection failed for %s: %v, falling back to basic detection", filename, err)
		// Fallback: –æ—á–µ–Ω—å –±–∞–∑–æ–≤–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
		return strings.Contains(strings.ToLower(filename), "test")
	}

	// –ü–∞—Ä—Å–∏–º JSON –æ—Ç–≤–µ—Ç
	var testFileResponse struct {
		IsTestFile bool   `json:"is_test_file"`
		Confidence string `json:"confidence"`
		Reasoning  string `json:"reasoning"`
	}

	content := response.Content
	if strings.Contains(content, "```json") {
		start := strings.Index(content, "```json") + 7
		end := strings.Index(content[start:], "```")
		if end > 0 {
			content = strings.TrimSpace(content[start : start+end])
		}
	}

	if err := json.Unmarshal([]byte(content), &testFileResponse); err != nil {
		log.Printf("‚ö†Ô∏è Failed to parse LLM test file response for %s: %v, falling back to basic detection", filename, err)
		return strings.Contains(strings.ToLower(filename), "test")
	}

	log.Printf("ü§ñ LLM test file analysis for %s: is_test=%v (confidence: %s) - %s",
		filename, testFileResponse.IsTestFile, testFileResponse.Confidence, testFileResponse.Reasoning)

	return testFileResponse.IsTestFile
}

// generateTestWritingPrompt –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –Ω–∞–ø–∏—Å–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤ —á–µ—Ä–µ–∑ LLM
func (h *VibeCodingHandler) generateTestWritingPrompt(ctx context.Context, session *VibeCodingSession) (string, error) {
	log.Printf("üéØ Generating specialized test writing prompt for %s project", session.Analysis.Language)

	systemPrompt := `You are an expert test writing advisor. Your task is to create a detailed, language-specific prompt for writing high-quality tests that will definitely pass execution.

Respond with a JSON object matching this exact schema:
{
  "test_prompt": "detailed test writing instructions",
  "key_rules": ["rule1", "rule2", "rule3"],
  "testing_framework": "recommended framework",
  "file_naming": "naming convention",
  "best_practices": ["practice1", "practice2"],
  "common_pitfalls": ["pitfall1", "pitfall2"]
}

Create a comprehensive prompt that includes:
- Language-specific testing conventions and frameworks
- Specific rules to avoid test failures
- Import and dependency management
- Assertion patterns that work reliably
- File structure and naming conventions
- Common mistakes to avoid for this language`

	userPrompt := fmt.Sprintf(`Create a specialized test writing prompt for this project:

LANGUAGE: %s
PROJECT: %s
TEST COMMANDS: %s

PROJECT ANALYSIS:
- Language: %s
- Docker Image: %s
- Working Directory: %s
- Install Commands: %d configured
- Test Commands: %d configured

PROJECT FILES STRUCTURE:
%s

REQUIREMENTS:
1. Tests must be syntactically correct and executable
2. Tests should use proper testing frameworks for %s
3. Tests must import only existing functions and classes
4. Tests should follow %s conventions
5. Tests must pass execution without errors
6. Include specific rules to prevent common test failures
7. Consider the project's actual file structure and dependencies

Generate a detailed prompt that will help an AI write tests that actually work and pass execution.`,
		session.Analysis.Language,
		session.ProjectName,
		strings.Join(session.Analysis.TestCommands, "; "),
		session.Analysis.Language,
		session.Analysis.DockerImage,
		session.Analysis.WorkingDir,
		len(session.Analysis.InstallCommands),
		len(session.Analysis.TestCommands),
		h.extractProjectStructureForPrompt(session.Files),
		session.Analysis.Language,
		session.Analysis.Language)

	messages := []llm.Message{
		{Role: "system", Content: systemPrompt},
		{Role: "user", Content: userPrompt},
	}

	log.Printf("üîç Requesting specialized test prompt from LLM")

	response, err := h.llmClient.Generate(ctx, messages)
	if err != nil {
		return "", fmt.Errorf("LLM test prompt generation failed: %w", err)
	}

	// –ü–∞—Ä—Å–∏–º JSON –æ—Ç–≤–µ—Ç
	var promptResponse struct {
		TestPrompt       string   `json:"test_prompt"`
		KeyRules         []string `json:"key_rules"`
		TestingFramework string   `json:"testing_framework"`
		FileNaming       string   `json:"file_naming"`
		BestPractices    []string `json:"best_practices"`
		CommonPitfalls   []string `json:"common_pitfalls"`
	}

	content := response.Content
	if strings.Contains(content, "```json") {
		start := strings.Index(content, "```json") + 7
		end := strings.Index(content[start:], "```")
		if end > 0 {
			content = strings.TrimSpace(content[start : start+end])
		}
	}

	if err := json.Unmarshal([]byte(content), &promptResponse); err != nil {
		log.Printf("‚ö†Ô∏è Failed to parse LLM prompt response: %v", err)
		return "", fmt.Errorf("failed to parse test prompt response: %w", err)
	}

	// –§–æ—Ä–º–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –ø—Ä–æ–º–ø—Ç
	var finalPrompt strings.Builder

	finalPrompt.WriteString(promptResponse.TestPrompt)
	finalPrompt.WriteString("\n\n")

	if promptResponse.TestingFramework != "" {
		finalPrompt.WriteString(fmt.Sprintf("RECOMMENDED TESTING FRAMEWORK: %s\n", promptResponse.TestingFramework))
	}

	if promptResponse.FileNaming != "" {
		finalPrompt.WriteString(fmt.Sprintf("FILE NAMING CONVENTION: %s\n", promptResponse.FileNaming))
	}

	if len(promptResponse.KeyRules) > 0 {
		finalPrompt.WriteString("\nCRITICAL RULES (tests MUST follow these to pass):\n")
		for i, rule := range promptResponse.KeyRules {
			finalPrompt.WriteString(fmt.Sprintf("%d. %s\n", i+1, rule))
		}
	}

	if len(promptResponse.BestPractices) > 0 {
		finalPrompt.WriteString("\nBEST PRACTICES:\n")
		for _, practice := range promptResponse.BestPractices {
			finalPrompt.WriteString(fmt.Sprintf("- %s\n", practice))
		}
	}

	if len(promptResponse.CommonPitfalls) > 0 {
		finalPrompt.WriteString("\nAVOID THESE PITFALLS:\n")
		for _, pitfall := range promptResponse.CommonPitfalls {
			finalPrompt.WriteString(fmt.Sprintf("‚ö†Ô∏è %s\n", pitfall))
		}
	}

	// –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞
	finalPrompt.WriteString(fmt.Sprintf("\nPROJECT CONTEXT:\n%s", h.formatProjectFilesForValidation(session.Files)))

	log.Printf("‚úÖ Generated specialized test prompt (%d chars) with framework: %s",
		len(finalPrompt.String()), promptResponse.TestingFramework)

	return finalPrompt.String(), nil
}

// extractProjectStructureForPrompt –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø—Ä–æ–µ–∫—Ç–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ø—Ä–æ–º–ø—Ç–∞
func (h *VibeCodingHandler) extractProjectStructureForPrompt(files map[string]string) string {
	var result strings.Builder

	// –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ñ–∞–π–ª–æ–≤
	result.WriteString("FILE STRUCTURE:\n")
	for filename := range files {
		result.WriteString(fmt.Sprintf("- %s\n", filename))
	}

	// –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
	result.WriteString("\nDETECTED DEPENDENCIES:\n")
	dependencies := make(map[string]bool)

	for _, content := range files {
		lines := strings.Split(content, "\n")
		for _, line := range lines {
			trimmed := strings.TrimSpace(line)

			// Python imports
			if strings.HasPrefix(trimmed, "import ") || strings.HasPrefix(trimmed, "from ") {
				dependencies[trimmed] = true
			}

			// Go imports
			if strings.Contains(trimmed, "\"") && (strings.Contains(line, "import") || strings.Contains(line, "package")) {
				dependencies[trimmed] = true
			}
		}
	}

	count := 0
	for dep := range dependencies {
		if count >= 10 { // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 10
			result.WriteString("... (and more)\n")
			break
		}
		result.WriteString(fmt.Sprintf("- %s\n", dep))
		count++
	}

	return result.String()
}


<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bot: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">ai-chatter/cmd/bot/main.go (0.0%)</option>
				
				<option value="file1">ai-chatter/cmd/notion-mcp-server/main.go (0.0%)</option>
				
				<option value="file2">ai-chatter/cmd/test-custom-mcp/main.go (0.0%)</option>
				
				<option value="file3">ai-chatter/internal/auth/auth.go (91.7%)</option>
				
				<option value="file4">ai-chatter/internal/auth/file_repo.go (0.0%)</option>
				
				<option value="file5">ai-chatter/internal/config/config.go (0.0%)</option>
				
				<option value="file6">ai-chatter/internal/history/history.go (60.6%)</option>
				
				<option value="file7">ai-chatter/internal/llm/factory.go (0.0%)</option>
				
				<option value="file8">ai-chatter/internal/llm/openai.go (0.0%)</option>
				
				<option value="file9">ai-chatter/internal/llm/tools.go (0.0%)</option>
				
				<option value="file10">ai-chatter/internal/llm/yandex.go (0.0%)</option>
				
				<option value="file11">ai-chatter/internal/notion/mcp.go (0.0%)</option>
				
				<option value="file12">ai-chatter/internal/pending/file_repo.go (82.3%)</option>
				
				<option value="file13">ai-chatter/internal/storage/file.go (45.3%)</option>
				
				<option value="file14">ai-chatter/internal/telegram/api.go (0.0%)</option>
				
				<option value="file15">ai-chatter/internal/telegram/bot.go (43.0%)</option>
				
				<option value="file16">ai-chatter/internal/telegram/handlers.go (22.0%)</option>
				
				<option value="file17">ai-chatter/internal/telegram/process.go (51.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log"
        "os"
        "strings"

        "github.com/joho/godotenv"

        "ai-chatter/internal/auth"
        "ai-chatter/internal/config"
        "ai-chatter/internal/llm"
        "ai-chatter/internal/notion"
        "ai-chatter/internal/pending"
        "ai-chatter/internal/storage"
        "ai-chatter/internal/telegram"
)

func main() <span class="cov0" title="0">{
        // Try several common locations for .env
        if err := godotenv.Load(".env" /*, "../.env", "cmd/bot/.env"*/); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: .env file not found: %v", err)
        }</span>

        <span class="cov0" title="0">cfg := config.New()

        var allowRepo auth.Repository
        if cfg.AllowlistFilePath != "" </span><span class="cov0" title="0">{
                repo, err := auth.NewFileRepository(cfg.AllowlistFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to init allowlist repo: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        allowRepo = repo
                }</span>
        }

        <span class="cov0" title="0">authSvc, err := auth.NewWithRepo(allowRepo, cfg.AllowedUsers)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to init auth: %v", err)
        }</span>

        // Resolve provider/model with overrides
        <span class="cov0" title="0">prov := string(cfg.LLMProvider)
        if s := readTrim(cfg.ProviderFilePath); s != "" </span><span class="cov0" title="0">{
                prov = s
        }</span>
        <span class="cov0" title="0">model := cfg.OpenAIModel
        if s := readTrim(cfg.ModelFilePath); s != "" </span><span class="cov0" title="0">{
                model = s
        }</span>

        <span class="cov0" title="0">llmFactory := llm.NewFactory(cfg)
        llmClient, err := llmFactory.CreateClient(prov, model)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to create llm client: %v", err)
        }</span>

        <span class="cov0" title="0">systemPrompt := readSystemPrompt(cfg.SystemPromptPath)

        var rec storage.Recorder
        if cfg.LogFilePath != "" </span><span class="cov0" title="0">{
                fr, err := storage.NewFileRecorder(cfg.LogFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to init file recorder: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        rec = fr
                }</span>
        }

        <span class="cov0" title="0">var pRepo pending.Repository
        if cfg.PendingFilePath != "" </span><span class="cov0" title="0">{
                pr, err := pending.NewFileRepository(cfg.PendingFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to init pending repo: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        pRepo = pr
                }</span>
        }

        // Initialize Notion MCP client
        <span class="cov0" title="0">var mcpClient *notion.MCPClient
        if cfg.NotionToken != "" </span><span class="cov0" title="0">{
                mcpClient = notion.NewMCPClient(cfg.NotionToken)

                // Подключаемся к MCP серверу
                ctx := context.Background()
                if err := mcpClient.Connect(ctx, cfg.NotionToken); err != nil </span><span class="cov0" title="0">{
                        log.Printf("⚠️ Failed to connect to Notion MCP server: %v", err)
                        log.Printf("Notion functionality will be disabled")
                        mcpClient = nil
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("✅ Notion MCP client connected successfully")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("NOTION_TOKEN not set, Notion functionality disabled")
        }</span>

        <span class="cov0" title="0">bot, err := telegram.New(
                cfg.TelegramBotToken,
                authSvc,
                llmClient,
                llmFactory,
                systemPrompt,
                rec,
                cfg.AdminUserID,
                pRepo,
                cfg.MessageParseMode,
                prov,
                model,
                mcpClient,
                cfg.NotionParentPage,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to create bot: %v", err)
        }</span>

        <span class="cov0" title="0">bot.Start(context.Background())</span>
}

func readSystemPrompt(path string) string <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("system prompt file not found or unreadable at %s: %v", path, err)
                return ""
        }</span>
        <span class="cov0" title="0">return string(data)</span>
}

func readTrim(path string) string <span class="cov0" title="0">{
        b, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(b))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "time"

        "github.com/joho/godotenv"
        "github.com/modelcontextprotocol/go-sdk/mcp"
)

// CreatePageParams параметры для создания страницы в Notion
type CreatePageParams struct {
        Title        string                 `json:"title" mcp:"the title of the page to create"`
        Content      string                 `json:"content" mcp:"the content of the page in markdown format"`
        Properties   map[string]interface{} `json:"properties,omitempty" mcp:"page properties (Type, User, etc.)"`
        ParentPageID string                 `json:"parent_page_id" mcp:"parent page ID (required - get from Notion workspace)"`
}

// SaveDialogParams параметры для сохранения диалога
type SaveDialogParams struct {
        Title        string `json:"title" mcp:"the title for the dialog summary"`
        Content      string `json:"content" mcp:"the dialog content to save"`
        UserID       string `json:"user_id" mcp:"ID of the user"`
        Username     string `json:"username" mcp:"username of the user"`
        DialogType   string `json:"dialog_type,omitempty" mcp:"Type of dialog (e.g., 'support', 'chat')"`
        ParentPageID string `json:"parent_page_id" mcp:"parent page ID (required - get from Notion workspace)"`
}

// SearchParams параметры для поиска в Notion
type SearchParams struct {
        Query    string                 `json:"query" mcp:"search query to find pages"`
        Filter   map[string]interface{} `json:"filter,omitempty" mcp:"optional filter for search"`
        PageSize int                    `json:"page_size,omitempty" mcp:"number of results to return (default: 20)"`
}

// NotionMCPServer кастомный MCP сервер для Notion
type NotionMCPServer struct {
        notionClient *NotionAPIClient
}

// NotionAPIClient клиент для прямой работы с Notion REST API
type NotionAPIClient struct {
        token      string
        baseURL    string
        apiVersion string
        httpClient *http.Client
}

// NewNotionAPIClient создает новый клиент Notion API
func NewNotionAPIClient(token string) *NotionAPIClient <span class="cov0" title="0">{
        return &amp;NotionAPIClient{
                token:      token,
                baseURL:    "https://api.notion.com/v1",
                apiVersion: "2022-06-28",
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
        }
}</span>

// doNotionRequest выполняет HTTP запрос к Notion API
func (c *NotionAPIClient) doNotionRequest(ctx context.Context, method, endpoint string, body interface{}) ([]byte, error) <span class="cov0" title="0">{
        var reqBody io.Reader
        if body != nil </span><span class="cov0" title="0">{
                bodyBytes, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov0" title="0">reqBody = bytes.NewReader(bodyBytes)</span>
        }

        <span class="cov0" title="0">url := c.baseURL + endpoint
        req, err := http.NewRequestWithContext(ctx, method, url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+c.token)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Notion-Version", c.apiVersion)

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Notion API error %d: %s", resp.StatusCode, string(respBody))
        }</span>

        <span class="cov0" title="0">return respBody, nil</span>
}

// createPage создает страницу в Notion
func (c *NotionAPIClient) createPage(ctx context.Context, title, content, parentPageID string, properties map[string]interface{}) (string, error) <span class="cov0" title="0">{
        // Создание страницы согласно Notion API
        pageData := map[string]interface{}{
                "parent": map[string]interface{}{
                        "type":    "page_id",
                        "page_id": parentPageID,
                },
                "properties": map[string]interface{}{
                        "title": map[string]interface{}{
                                "title": []map[string]interface{}{
                                        {
                                                "text": map[string]interface{}{
                                                        "content": title,
                                                },
                                        },
                                },
                        },
                },
                "children": []map[string]interface{}{
                        {
                                "object": "block",
                                "type":   "paragraph",
                                "paragraph": map[string]interface{}{
                                        "rich_text": []map[string]interface{}{
                                                {
                                                        "type": "text",
                                                        "text": map[string]interface{}{
                                                                "content": content,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }

        respBody, err := c.doNotionRequest(ctx, "POST", "/pages", pageData)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(respBody, &amp;result); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">if id, ok := result["id"].(string); ok </span><span class="cov0" title="0">{
                return id, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("no page ID in response")</span>
}

// searchPages ищет страницы в Notion
func (c *NotionAPIClient) searchPages(ctx context.Context, query string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        searchData := map[string]interface{}{
                "query":     query,
                "page_size": 20,
        }

        respBody, err := c.doNotionRequest(ctx, "POST", "/search", searchData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(respBody, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">if results, ok := result["results"].([]interface{}); ok </span><span class="cov0" title="0">{
                var pages []map[string]interface{}
                for _, r := range results </span><span class="cov0" title="0">{
                        if page, ok := r.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                pages = append(pages, page)
                        }</span>
                }
                <span class="cov0" title="0">return pages, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no results in response")</span>
}

// NewNotionMCPServer создает новый MCP сервер для Notion
func NewNotionMCPServer(notionToken string) *NotionMCPServer <span class="cov0" title="0">{
        return &amp;NotionMCPServer{
                notionClient: NewNotionAPIClient(notionToken),
        }
}</span>

// CreatePage создает новую страницу в Notion через MCP
func (s *NotionMCPServer) CreatePage(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[CreatePageParams]) (*mcp.CallToolResultFor[any], error) <span class="cov0" title="0">{
        args := params.Arguments

        log.Printf("📝 MCP Server: Creating Notion page '%s' in parent %s", args.Title, args.ParentPageID)

        // Проверяем обязательный parent_page_id
        if args.ParentPageID == "" </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResultFor[any]{
                        IsError: true,
                        Content: []mcp.Content{
                                &amp;mcp.TextContent{Text: "❌ parent_page_id is required - get it from your Notion workspace"},
                        },
                }, nil
        }</span>

        // Создаем страницу через прямой API вызов
        <span class="cov0" title="0">pageID, err := s.notionClient.createPage(ctx, args.Title, args.Content, args.ParentPageID, args.Properties)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResultFor[any]{
                        IsError: true,
                        Content: []mcp.Content{
                                &amp;mcp.TextContent{Text: fmt.Sprintf("❌ Failed to create page: %v", err)},
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[any]{
                Content: []mcp.Content{
                        &amp;mcp.TextContent{Text: fmt.Sprintf("✅ Successfully created page '%s' in Notion", args.Title)},
                },
                Meta: map[string]interface{}{
                        "page_id": pageID,
                        "title":   args.Title,
                        "success": true,
                },
        }, nil</span>
}

// SearchPages ищет страницы в Notion через MCP
func (s *NotionMCPServer) SearchPages(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[SearchParams]) (*mcp.CallToolResultFor[any], error) <span class="cov0" title="0">{
        args := params.Arguments

        log.Printf("🔍 MCP Server: Searching Notion for '%s'", args.Query)

        // Ищем страницы через прямой API вызов
        pages, err := s.notionClient.searchPages(ctx, args.Query)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResultFor[any]{
                        IsError: true,
                        Content: []mcp.Content{
                                &amp;mcp.TextContent{Text: fmt.Sprintf("❌ Search failed: %v", err)},
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">resultMessage := fmt.Sprintf("✅ Found %d pages for query '%s'", len(pages), args.Query)
        for i, page := range pages </span><span class="cov0" title="0">{
                if i &gt;= 5 </span><span class="cov0" title="0">{ // Показываем только первые 5 результатов
                        break</span>
                }
                <span class="cov0" title="0">if title, ok := page["properties"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if titleProp, ok := title["title"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if titleArray, ok := titleProp["title"].([]interface{}); ok &amp;&amp; len(titleArray) &gt; 0 </span><span class="cov0" title="0">{
                                        if titleText, ok := titleArray[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if text, ok := titleText["text"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                        if content, ok := text["content"].(string); ok </span><span class="cov0" title="0">{
                                                                resultMessage += fmt.Sprintf("\n- %s", content)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[any]{
                Content: []mcp.Content{
                        &amp;mcp.TextContent{Text: resultMessage},
                },
                Meta: map[string]interface{}{
                        "query":      args.Query,
                        "page_count": len(pages),
                        "success":    true,
                },
        }, nil</span>
}

// SaveDialog сохраняет диалог в Notion через MCP
func (s *NotionMCPServer) SaveDialog(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[SaveDialogParams]) (*mcp.CallToolResultFor[any], error) <span class="cov0" title="0">{
        args := params.Arguments

        log.Printf("💾 MCP Server: Saving dialog '%s' for user %s in parent %s", args.Title, args.Username, args.ParentPageID)

        // Проверяем обязательный parent_page_id
        if args.ParentPageID == "" </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResultFor[any]{
                        IsError: true,
                        Content: []mcp.Content{
                                &amp;mcp.TextContent{Text: "❌ parent_page_id is required for saving dialogs - get it from your Notion workspace"},
                        },
                }, nil
        }</span>

        // Формируем контент диалога
        <span class="cov0" title="0">dialogContent := fmt.Sprintf("# %s\n\n**User:** %s\n**Type:** %s\n**Date:** %s\n\n## Content\n\n%s",
                args.Title, args.Username, args.DialogType, time.Now().Format("2006-01-02 15:04:05"), args.Content)

        // Создаем свойства для страницы
        properties := map[string]interface{}{
                "Type":       "Dialog",
                "User":       args.Username,
                "UserID":     args.UserID,
                "DialogType": args.DialogType,
                "Created":    time.Now().Format("2006-01-02"),
        }

        // Сохраняем диалог как страницу
        pageID, err := s.notionClient.createPage(ctx, args.Title, dialogContent, args.ParentPageID, properties)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResultFor[any]{
                        IsError: true,
                        Content: []mcp.Content{
                                &amp;mcp.TextContent{Text: fmt.Sprintf("❌ Failed to save dialog: %v", err)},
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[any]{
                Content: []mcp.Content{
                        &amp;mcp.TextContent{Text: fmt.Sprintf("✅ Dialog '%s' saved to Notion", args.Title)},
                },
                Meta: map[string]interface{}{
                        "page_id":     pageID,
                        "title":       args.Title,
                        "user":        args.Username,
                        "dialog_type": args.DialogType,
                        "success":     true,
                },
        }, nil</span>
}

// getProperty извлекает свойство из карты с fallback значением
func getProperty(props map[string]interface{}, key, defaultValue string) string <span class="cov0" title="0">{
        if props == nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">if val, ok := props[key].(string); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func main() <span class="cov0" title="0">{
        if err := godotenv.Load(".env" /*, "../.env", "cmd/bot/.env"*/); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: .env file not found: %v", err)
        }</span>
        // Получаем токен Notion из переменной окружения
        <span class="cov0" title="0">notionToken := os.Getenv("NOTION_TOKEN")
        if notionToken == "" </span><span class="cov0" title="0">{
                log.Fatal("❌ NOTION_TOKEN environment variable is required")
        }</span>

        <span class="cov0" title="0">log.Printf("🚀 Starting Custom Notion MCP Server")
        log.Printf("🔑 Using Notion token: %s...%s", notionToken[:10], notionToken[len(notionToken)-5:])

        // Создаем MCP сервер
        server := mcp.NewServer(&amp;mcp.Implementation{
                Name:    "ai-chatter-notion-mcp",
                Version: "1.0.0",
        }, nil)

        // Создаем наш Notion сервер
        notionServer := NewNotionMCPServer(notionToken)

        // Регистрируем инструменты
        mcp.AddTool(server, &amp;mcp.Tool{
                Name:        "create_page",
                Description: "Creates a new page in Notion with the specified title and content",
        }, notionServer.CreatePage)

        mcp.AddTool(server, &amp;mcp.Tool{
                Name:        "search_pages",
                Description: "Searches for pages in Notion workspace",
        }, notionServer.SearchPages)

        mcp.AddTool(server, &amp;mcp.Tool{
                Name:        "save_dialog_to_notion",
                Description: "Saves a dialog conversation to Notion as a summary page",
        }, notionServer.SaveDialog)

        log.Printf("📋 Registered %d tools: create_page, search_pages, save_dialog_to_notion", 3)
        log.Printf("🔗 Starting server on stdin/stdout...")

        // Запускаем сервер через stdin/stdout
        transport := mcp.NewStdioTransport()
        if err := server.Run(context.Background(), transport); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("❌ Server failed: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"

        "ai-chatter/internal/notion"

        "github.com/joho/godotenv"
)

func main() <span class="cov0" title="0">{
        if err := godotenv.Load(".env" /*, "../.env", "cmd/bot/.env"*/); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: .env file not found: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("🧪 Testing Custom Notion MCP Server")
        fmt.Println("===================================")

        // Проверяем наличие токена
        notionToken := os.Getenv("NOTION_TOKEN")
        if notionToken == "" </span><span class="cov0" title="0">{
                fmt.Println("❌ NOTION_TOKEN environment variable is required")
                fmt.Println("💡 Please set it with your Notion integration token:")
                fmt.Println("   export NOTION_TOKEN=secret_xxxxx")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ NOTION_TOKEN is set: %s...%s\n", notionToken[:10], notionToken[len(notionToken)-5:])

        // Создаем MCP клиент
        mcpClient := notion.NewMCPClient(notionToken)

        ctx := context.Background()

        // Тестируем подключение к кастомному серверу
        fmt.Println("\n🔗 Connecting to custom MCP server...")
        fmt.Println("💡 Make sure the server binary is built:")
        fmt.Println("   go build -o notion-mcp-server cmd/notion-mcp-server/main.go")
        fmt.Println("")

        err := mcpClient.Connect(ctx, notionToken)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Connection failed: %v\n", err)
                fmt.Println("\n💡 Please ensure:")
                fmt.Println("   1. MCP server is built: go build -o notion-mcp-server cmd/notion-mcp-server/main.go")
                fmt.Println("   2. NOTION_TOKEN is valid")
                fmt.Println("   3. Notion integration has access to pages")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("✅ Connected successfully!")

        // Тестируем сохранение диалога
        fmt.Println("\n💾 Testing dialog saving...")

        // Используем фейковый parent page ID для теста (в реальности нужен настоящий)
        testPageID := os.Getenv("NOTION_TEST_PAGE_ID")

        dialogResult := mcpClient.CreateDialogSummary(
                ctx,
                "Test Dialog from Custom MCP",
                "This is a test dialog created through our custom MCP server.",
                "test_user_123",
                "TestUser",
                "test",
                testPageID,
        )

        if !dialogResult.Success </span><span class="cov0" title="0">{
                fmt.Printf("❌ Dialog save failed: %s\n", dialogResult.Message)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✅ Dialog saved: %s\n", dialogResult.Message)
                if dialogResult.PageID != "" </span><span class="cov0" title="0">{
                        fmt.Printf("📄 Page ID: %s\n", dialogResult.PageID)
                }</span>
        }

        // Тестируем создание произвольной страницы
        <span class="cov0" title="0">fmt.Println("\n📄 Testing free-form page creation...")

        pageResult := mcpClient.CreateFreeFormPage(
                ctx,
                "Custom MCP Test Page",
                "# Custom MCP Integration Test\n\nThis page was created using our custom Notion MCP server built with Go and the official MCP SDK.\n\n## Features\n- Direct Notion API integration\n- MCP protocol compliance\n- Go-based implementation\n- Official SDK usage",
                testPageID,
                []string{"test", "mcp", "custom"},
        )

        if !pageResult.Success </span><span class="cov0" title="0">{
                fmt.Printf("❌ Page creation failed: %s\n", pageResult.Message)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✅ Page created: %s\n", pageResult.Message)
                if pageResult.PageID != "" </span><span class="cov0" title="0">{
                        fmt.Printf("📄 Page ID: %s\n", pageResult.PageID)
                }</span>
        }

        // Тестируем поиск
        <span class="cov0" title="0">fmt.Println("\n🔍 Testing search functionality...")

        searchResult := mcpClient.SearchDialogSummaries(ctx, "AI", "", "")

        if !searchResult.Success </span><span class="cov0" title="0">{
                fmt.Printf("❌ Search failed: %s\n", searchResult.Message)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✅ Search completed: %s\n", searchResult.Message)
        }</span>

        // Закрываем соединение
        <span class="cov0" title="0">mcpClient.Close()

        fmt.Println("\n🎉 Custom MCP Server integration test completed!")
        fmt.Println("🏗️ Custom MCP server is working correctly")
        fmt.Println("📋 Benefits of custom approach:")
        fmt.Println("   ✅ Full control over MCP implementation")
        fmt.Println("   ✅ Direct Notion API access")
        fmt.Println("   ✅ Official MCP SDK compliance")
        fmt.Println("   ✅ Go-based end-to-end solution")
        fmt.Println("   ✅ Easy debugging and customization")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

type User struct {
        ID        int64  `json:"id"`
        Username  string `json:"username"`
        FirstName string `json:"first_name"`
        LastName  string `json:"last_name"`
}

type Repository interface {
        LoadAll() ([]User, error)
        Upsert(user User) error
        Remove(userID int64) error
}

type Service struct {
        repo         Repository
        allowedUsers map[int64]User
}

func NewWithRepo(repo Repository, initial []int64) (*Service, error) <span class="cov1" title="1">{
        s := &amp;Service{repo: repo, allowedUsers: make(map[int64]User)}
        // preload from repo
        if repo != nil </span><span class="cov1" title="1">{
                users, err := repo.LoadAll()
                if err == nil </span><span class="cov1" title="1">{
                        for _, u := range users </span><span class="cov1" title="1">{
                                s.allowedUsers[u.ID] = u
                        }</span>
                }
        }
        // merge initial IDs (from env) without usernames
        <span class="cov1" title="1">for _, id := range initial </span><span class="cov1" title="1">{
                if _, ok := s.allowedUsers[id]; !ok </span><span class="cov1" title="1">{
                        s.allowedUsers[id] = User{ID: id}
                }</span>
        }
        <span class="cov1" title="1">return s, nil</span>
}

func (s *Service) IsAllowed(userID int64) bool <span class="cov10" title="5">{
        _, ok := s.allowedUsers[userID]
        return ok
}</span>

func (s *Service) Upsert(user User) error <span class="cov1" title="1">{
        s.allowedUsers[user.ID] = user
        if s.repo != nil </span><span class="cov1" title="1">{
                return s.repo.Upsert(user)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Service) Remove(userID int64) error <span class="cov1" title="1">{
        delete(s.allowedUsers, userID)
        if s.repo != nil </span><span class="cov1" title="1">{
                return s.repo.Remove(userID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Service) List() []User <span class="cov1" title="1">{
        out := make([]User, 0, len(s.allowedUsers))
        for _, u := range s.allowedUsers </span><span class="cov4" title="2">{
                out = append(out, u)
        }</span>
        <span class="cov1" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
)

type FileRepository struct {
        path string
        mu   sync.Mutex
}

func NewFileRepository(path string) (*FileRepository, error) <span class="cov0" title="0">{
        if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ensure dir: %w", err)
        }</span>
        // Touch file if not exists
        <span class="cov0" title="0">f, err := os.OpenFile(path, os.O_CREATE, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("touch file: %w", err)
        }</span>
        <span class="cov0" title="0">_ = f.Close()
        return &amp;FileRepository{path: path}, nil</span>
}

func (r *FileRepository) LoadAll() ([]User, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open: %w", err)
        }</span>
        <span class="cov0" title="0">defer func(f *os.File) </span><span class="cov0" title="0">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov0" title="0">var users []User
        dec := json.NewDecoder(f)
        if err := dec.Decode(&amp;users); err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return []User{}, nil
                }</span>
                // empty or malformed -&gt; start fresh
                <span class="cov0" title="0">return []User{}, nil</span>
        }
        <span class="cov0" title="0">return users, nil</span>
}

func (r *FileRepository) Upsert(user User) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        users, _ := r.loadUnlocked()
        updated := false
        for i, u := range users </span><span class="cov0" title="0">{
                if u.ID == user.ID </span><span class="cov0" title="0">{
                        users[i] = user
                        updated = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !updated </span><span class="cov0" title="0">{
                users = append(users, user)
        }</span>
        <span class="cov0" title="0">return r.saveUnlocked(users)</span>
}

func (r *FileRepository) Remove(userID int64) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        users, _ := r.loadUnlocked()
        var out []User
        for _, u := range users </span><span class="cov0" title="0">{
                if u.ID != userID </span><span class="cov0" title="0">{
                        out = append(out, u)
                }</span>
        }
        <span class="cov0" title="0">return r.saveUnlocked(out)</span>
}

func (r *FileRepository) loadUnlocked() ([]User, error) <span class="cov0" title="0">{
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func(f *os.File) </span><span class="cov0" title="0">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov0" title="0">var users []User
        dec := json.NewDecoder(f)
        if err := dec.Decode(&amp;users); err != nil </span><span class="cov0" title="0">{
                return []User{}, nil
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

func (r *FileRepository) saveUnlocked(users []User) error <span class="cov0" title="0">{
        f, err := os.OpenFile(r.path, os.O_TRUNC|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(f *os.File) </span><span class="cov0" title="0">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov0" title="0">enc := json.NewEncoder(f)
        enc.SetIndent("", "  ")
        return enc.Encode(users)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "log"

        "github.com/caarlos0/env/v6"
)

type LLMProvider string

const (
        ProviderOpenAI LLMProvider = "openai"
        ProviderYandex LLMProvider = "yandex"
)

type Config struct {
        TelegramBotToken string  `env:"TELEGRAM_BOT_TOKEN,required"`
        AllowedUsers     []int64 `env:"ALLOWED_USERS" envSeparator:":"`
        AdminUserID      int64   `env:"ADMIN_USER"`

        // LLM settings
        LLMProvider      LLMProvider `env:"LLM_PROVIDER" envDefault:"openai"`
        OpenAIAPIKey     string      `env:"OPENAI_API_KEY"`
        OpenAIBaseURL    string      `env:"OPENAI_BASE_URL"`
        OpenAIModel      string      `env:"OPENAI_MODEL" envDefault:"gpt-3.5-turbo"`
        YandexOAuthToken string      `env:"YANDEX_OAUTH_TOKEN"`
        YandexFolderID   string      `env:"YANDEX_FOLDER_ID"`

        // OpenRouter (optional)
        OpenRouterReferrer string `env:"OPENROUTER_REFERRER"`
        OpenRouterTitle    string `env:"OPENROUTER_TITLE"`

        // Prompts
        SystemPromptPath string `env:"SYSTEM_PROMPT_PATH" envDefault:"prompts/system_prompt.txt"`

        // Storage
        LogFilePath       string `env:"LOG_FILE_PATH" envDefault:"logs/log.jsonl"`
        AllowlistFilePath string `env:"ALLOWLIST_FILE_PATH" envDefault:"data/allowlist.json"`
        PendingFilePath   string `env:"PENDING_FILE_PATH" envDefault:"data/pending.json"`

        // Overrides persistence
        ProviderFilePath string `env:"PROVIDER_FILE_PATH" envDefault:"data/provider.txt"`
        ModelFilePath    string `env:"MODEL_FILE_PATH" envDefault:"data/model.txt"`
        Model2FilePath   string `env:"MODEL2_FILE_PATH" envDefault:"data/model2.txt"`

        // Formatting
        MessageParseMode string `env:"MESSAGE_PARSE_MODE" envDefault:"HTML"`

        // Notion integration
        NotionToken      string `env:"NOTION_TOKEN"`
        NotionParentPage string `env:"NOTION_PARENT_PAGE_ID"`
}

func New() *Config <span class="cov0" title="0">{
        cfg := &amp;Config{}
        if err := env.Parse(cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to parse config: %v", err)
        }</span>
        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package history

import (
        "sync"

        "ai-chatter/internal/llm"
)

type entry struct {
        msg  llm.Message
        used bool
}

type Manager struct {
        mu       sync.RWMutex
        sessions map[int64][]entry
}

func NewManager() *Manager <span class="cov1" title="1">{
        return &amp;Manager{sessions: make(map[int64][]entry)}
}</span>

func (m *Manager) Reset(userID int64) <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        delete(m.sessions, userID)
}</span>

func (m *Manager) DisableAll(userID int64) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        entries := m.sessions[userID]
        for i := range entries </span><span class="cov0" title="0">{
                entries[i].used = false
        }</span>
        <span class="cov0" title="0">m.sessions[userID] = entries</span>
}

func (m *Manager) AppendUser(userID int64, content string) <span class="cov4" title="2">{
        m.AppendUserWithUsed(userID, content, true)
}</span>
func (m *Manager) AppendAssistant(userID int64, content string) <span class="cov4" title="2">{
        m.AppendAssistantWithUsed(userID, content, true)
}</span>

func (m *Manager) AppendUserWithUsed(userID int64, content string, used bool) <span class="cov4" title="2">{
        m.append(userID, llm.Message{Role: "user", Content: content}, used)
}</span>

func (m *Manager) AppendAssistantWithUsed(userID int64, content string, used bool) <span class="cov4" title="2">{
        m.append(userID, llm.Message{Role: "assistant", Content: content}, used)
}</span>

func (m *Manager) append(userID int64, msg llm.Message, used bool) <span class="cov7" title="4">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.sessions[userID] = append(m.sessions[userID], entry{msg: msg, used: used})
}</span>

// Get returns only messages that are marked as used in context (backward-compatible behavior)
func (m *Manager) Get(userID int64) []llm.Message <span class="cov7" title="5">{ return m.GetUsed(userID) }</span>

func (m *Manager) GetUsed(userID int64) []llm.Message <span class="cov7" title="5">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        es := m.sessions[userID]
        var out []llm.Message
        for _, e := range es </span><span class="cov10" title="8">{
                if e.used </span><span class="cov10" title="8">{
                        out = append(out, e.msg)
                }</span>
        }
        <span class="cov7" title="5">return out</span>
}

func (m *Manager) GetAll(userID int64) []llm.Message <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        es := m.sessions[userID]
        out := make([]llm.Message, 0, len(es))
        for _, e := range es </span><span class="cov0" title="0">{
                out = append(out, e.msg)
        }</span>
        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package llm

import (
        "fmt"
        "strings"

        "ai-chatter/internal/config"
)

const (
        ProviderOpenAI = "openai"
        ProviderYandex = "yandex"
)

var AllowedModels = map[string]bool{
        "openai/gpt-5-nano":              true,
        "openai/gpt-oss-20b:free":        true,
        "qwen/qwen3-coder":               true,
        "z-ai/glm-4.5-air:free":          true,
        "qwen/qwen3-coder:free":          true,
        "google/gemini-2.5-flash-lite":   true,
        "deepseek/deepseek-r1-0528:free": true,
}

// Factory creates LLM clients with consistent logic
type Factory struct {
        OpenaiAPIKey       string
        OpenaiBaseURL      string
        OpenRouterReferrer string
        OpenRouterTitle    string
        YandexOAuthToken   string
        YandexFolderID     string
}

func NewFactory(cfg *config.Config) *Factory <span class="cov0" title="0">{
        return &amp;Factory{
                OpenaiAPIKey:       cfg.OpenAIAPIKey,
                OpenaiBaseURL:      cfg.OpenAIBaseURL,
                OpenRouterReferrer: cfg.OpenRouterReferrer,
                OpenRouterTitle:    cfg.OpenRouterTitle,
                YandexOAuthToken:   cfg.YandexOAuthToken,
                YandexFolderID:     cfg.YandexFolderID,
        }
}</span>

func (f *Factory) CreateClient(provider, model string) (Client, error) <span class="cov0" title="0">{
        switch strings.ToLower(provider) </span>{
        case ProviderOpenAI:<span class="cov0" title="0">
                return NewOpenAI(f.OpenaiAPIKey, f.OpenaiBaseURL, model, f.OpenRouterReferrer, f.OpenRouterTitle), nil</span>
        case ProviderYandex:<span class="cov0" title="0">
                return NewYandex(f.YandexOAuthToken, f.YandexFolderID)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown llm provider: %s", provider)</span>
        }
}

func IsModelAllowed(model string) bool <span class="cov0" title="0">{
        return AllowedModels[model]
}</span>

func GetAllowedModels() []string <span class="cov0" title="0">{
        models := make([]string, 0, len(AllowedModels))
        for model := range AllowedModels </span><span class="cov0" title="0">{
                models = append(models, model)
        }</span>
        <span class="cov0" title="0">return models</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package llm

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/sashabaranov/go-openai"
)

type OpenAIClient struct {
        client *openai.Client
        model  string
}

type headerTransport struct {
        rt      http.RoundTripper
        headers http.Header
}

func (t headerTransport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        // Clone request to avoid mutating the original
        cl := req.Clone(req.Context())
        for k, vs := range t.headers </span><span class="cov0" title="0">{
                for _, v := range vs </span><span class="cov0" title="0">{
                        cl.Header.Add(k, v)
                }</span>
        }
        <span class="cov0" title="0">return t.rt.RoundTrip(cl)</span>
}

func NewOpenAI(apiKey, baseURL, model, referrer, title string) *OpenAIClient <span class="cov0" title="0">{
        config := openai.DefaultConfig(apiKey)
        if baseURL != "" </span><span class="cov0" title="0">{
                config.BaseURL = baseURL
        }</span>
        // Inject optional headers (useful for OpenRouter)
        <span class="cov0" title="0">if referrer != "" || title != "" </span><span class="cov0" title="0">{
                h := http.Header{}
                if referrer != "" </span><span class="cov0" title="0">{
                        h.Set("HTTP-Referer", referrer)
                }</span>
                <span class="cov0" title="0">if title != "" </span><span class="cov0" title="0">{
                        h.Set("X-Title", title)
                }</span>
                <span class="cov0" title="0">base := http.DefaultTransport
                config.HTTPClient = &amp;http.Client{Transport: headerTransport{rt: base, headers: h}}</span>
        }
        <span class="cov0" title="0">return &amp;OpenAIClient{
                client: openai.NewClientWithConfig(config),
                model:  model,
        }</span>
}

func (c *OpenAIClient) Generate(ctx context.Context, messages []Message) (Response, error) <span class="cov0" title="0">{
        return c.GenerateWithTools(ctx, messages, nil)
}</span>

func (c *OpenAIClient) GenerateWithTools(ctx context.Context, messages []Message, tools []Tool) (Response, error) <span class="cov0" title="0">{
        var oaMsgs []openai.ChatCompletionMessage
        for _, m := range messages </span><span class="cov0" title="0">{
                msg := openai.ChatCompletionMessage{Role: m.Role, Content: m.Content}
                // Для tool response сообщений добавляем ToolCallID
                if m.Role == "tool" &amp;&amp; m.ToolCallID != "" </span><span class="cov0" title="0">{
                        msg.ToolCallID = m.ToolCallID
                }</span>
                <span class="cov0" title="0">oaMsgs = append(oaMsgs, msg)</span>
        }

        <span class="cov0" title="0">req := openai.ChatCompletionRequest{
                Model:    c.model,
                Messages: oaMsgs,
        }

        // Добавляем tools если они есть
        if len(tools) &gt; 0 </span><span class="cov0" title="0">{
                var oaTools []openai.Tool
                for _, tool := range tools </span><span class="cov0" title="0">{
                        oaTools = append(oaTools, openai.Tool{
                                Type: openai.ToolTypeFunction,
                                Function: &amp;openai.FunctionDefinition{
                                        Name:        tool.Function.Name,
                                        Description: tool.Function.Description,
                                        Parameters:  tool.Function.Parameters,
                                },
                        })
                }</span>
                <span class="cov0" title="0">req.Tools = oaTools
                req.ToolChoice = "auto"</span> // LLM решает сама когда вызывать функции
        }

        <span class="cov0" title="0">resp, err := c.client.CreateChatCompletion(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return Response{}, fmt.Errorf("failed to create chat completion: %w", err)
        }</span>

        <span class="cov0" title="0">out := Response{
                Content: resp.Choices[0].Message.Content,
                Model:   c.model,
        }
        out.PromptTokens = resp.Usage.PromptTokens
        out.CompletionTokens = resp.Usage.CompletionTokens
        out.TotalTokens = resp.Usage.TotalTokens

        // Обрабатываем tool calls если они есть
        if len(resp.Choices[0].Message.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                for _, tc := range resp.Choices[0].Message.ToolCalls </span><span class="cov0" title="0">{
                        out.ToolCalls = append(out.ToolCalls, ToolCall{
                                ID:   tc.ID,
                                Type: string(tc.Type),
                                Function: FunctionCall{
                                        Name:      tc.Function.Name,
                                        Arguments: parseJSONArgs(tc.Function.Arguments),
                                },
                        })
                }</span>
        }

        <span class="cov0" title="0">return out, nil</span>
}

// parseJSONArgs парсит аргументы функции из JSON строки
func parseJSONArgs(args string) map[string]interface{} <span class="cov0" title="0">{
        var result map[string]interface{}
        if err := json.Unmarshal([]byte(args), &amp;result); err != nil </span><span class="cov0" title="0">{
                return make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package llm

// GetNotionTools возвращает список инструментов Notion для LLM
func GetNotionTools() []Tool <span class="cov0" title="0">{
        return []Tool{
                {
                        Type: "function",
                        Function: Function{
                                Name:        "save_dialog_to_notion",
                                Description: "Сохраняет текущий диалог в Notion. Используется когда пользователь просит сохранить беседу, запомнить информацию или создать заметку.",
                                Parameters: map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "title": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Название страницы в Notion (краткое и понятное)",
                                                },
                                        },
                                        "required": []string{"title"},
                                },
                        },
                },
                {
                        Type: "function",
                        Function: Function{
                                Name:        "search_notion",
                                Description: "Ищет информацию в ранее сохранённых диалогах в Notion. Используется когда пользователь спрашивает про прошлые беседы или нужно найти ранее обсуждённые темы.",
                                Parameters: map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "query": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Поисковый запрос для поиска в Notion",
                                                },
                                        },
                                        "required": []string{"query"},
                                },
                        },
                },
                {
                        Type: "function",
                        Function: Function{
                                Name:        "create_notion_page",
                                Description: "Создаёт новую страницу в Notion с произвольным содержимым. Используется для создания заметок, планов, или структурированной информации.",
                                Parameters: map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "title": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Название страницы",
                                                },
                                                "content": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Содержимое страницы в формате Markdown",
                                                },
                                                "parent_page": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Название родительской страницы (опционально)",
                                                },
                                        },
                                        "required": []string{"title", "content"},
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package llm

import (
        "context"
        "fmt"

        "github.com/Morwran/yagpt"
)

type YandexClient struct {
        ya       yagpt.YaGPTFace
        iamToken string
}

func NewYandex(oauthToken, folderID string) (*YandexClient, error) <span class="cov0" title="0">{
        // Create IAM token from OAuth token
        iam, err := yagpt.NewYaIam(oauthToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to init yandex iam: %w", err)
        }</span>
        <span class="cov0" title="0">resp, err := iam.Create()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create iam token: %w", err)
        }</span>

        // Create YaGPT client for a folder
        <span class="cov0" title="0">ya, err := yagpt.NewYagpt(folderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to init yagpt: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;YandexClient{
                ya:       ya,
                iamToken: resp.IamToken,
        }, nil</span>
}

func (c *YandexClient) Generate(ctx context.Context, messages []Message) (Response, error) <span class="cov0" title="0">{
        return c.GenerateWithTools(ctx, messages, nil)
}</span>

func (c *YandexClient) GenerateWithTools(ctx context.Context, messages []Message, tools []Tool) (Response, error) <span class="cov0" title="0">{
        // YandexGPT пока не поддерживает function calling
        // Игнорируем tools и делаем обычный запрос
        var yaMsgs []yagpt.Message
        for _, m := range messages </span><span class="cov0" title="0">{
                yaMsgs = append(yaMsgs, yagpt.Message{Role: m.Role, Content: m.Content})
        }</span>

        <span class="cov0" title="0">resp, err := c.ya.CompletionWithCtx(ctx, c.iamToken, yaMsgs)
        if err != nil </span><span class="cov0" title="0">{
                return Response{}, fmt.Errorf("yagpt completion failed: %w", err)
        }</span>
        <span class="cov0" title="0">if resp == nil || len(resp.Alternatives) == 0 </span><span class="cov0" title="0">{
                return Response{}, fmt.Errorf("yagpt returned empty response")
        }</span>
        <span class="cov0" title="0">out := Response{Content: resp.Alternatives[0].Message.Content, Model: yagpt.YaModelLite}
        out.PromptTokens = int(resp.Usage.InputTextTokens)
        out.CompletionTokens = int(resp.Usage.CompletionTokens)
        out.TotalTokens = int(resp.Usage.TotalTokens)
        // YandexGPT не поддерживает tool calls
        out.ToolCalls = nil
        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package notion

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "os/exec"
        "time"

        "github.com/modelcontextprotocol/go-sdk/mcp"
)

// MCPClient клиент для работы с кастомным Notion MCP сервером
type MCPClient struct {
        client  *mcp.Client
        session *mcp.ClientSession
}

// NewMCPClient создает новый MCP клиент для Notion
func NewMCPClient(token string) *MCPClient <span class="cov0" title="0">{
        return &amp;MCPClient{}
}</span>

// Connect подключается к кастомному Notion MCP серверу через stdio
func (m *MCPClient) Connect(ctx context.Context, notionToken string) error <span class="cov0" title="0">{
        log.Printf("🔗 Connecting to custom Notion MCP server via stdio")

        // Создаем MCP клиент
        m.client = mcp.NewClient(&amp;mcp.Implementation{
                Name:    "ai-chatter-bot",
                Version: "1.0.0",
        }, nil)

        // Запускаем наш кастомный MCP сервер как подпроцесс
        serverPath := "./notion-mcp-server"
        if customPath := os.Getenv("NOTION_MCP_SERVER_PATH"); customPath != "" </span><span class="cov0" title="0">{
                serverPath = customPath
        }</span>

        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, serverPath)
        cmd.Env = append(os.Environ(), fmt.Sprintf("NOTION_TOKEN=%s", notionToken))

        transport := mcp.NewCommandTransport(cmd)

        session, err := m.client.Connect(ctx, transport)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to custom MCP server: %w", err)
        }</span>

        <span class="cov0" title="0">m.session = session
        log.Printf("✅ Connected to custom Notion MCP server")
        return nil</span>
}

// Close закрывает соединение с MCP сервером
func (m *MCPClient) Close() error <span class="cov0" title="0">{
        if m.session != nil </span><span class="cov0" title="0">{
                return m.session.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateDialogSummary создает страницу с сохранением диалога через кастомный MCP
func (m *MCPClient) CreateDialogSummary(ctx context.Context, title, content, userID, username, dialogType, parentPageID string) MCPResult <span class="cov0" title="0">{
        if m.session == nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "MCP session not connected"}
        }</span>

        <span class="cov0" title="0">log.Printf("📝 Creating Notion page via custom MCP: %s", title)

        // Проверяем обязательный parent_page_id
        if parentPageID == "" </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "parent_page_id is required - get it from your Notion workspace"}
        }</span>

        // Вызываем инструмент save_dialog_to_notion
        <span class="cov0" title="0">result, err := m.session.CallTool(ctx, &amp;mcp.CallToolParams{
                Name: "save_dialog_to_notion",
                Arguments: map[string]any{
                        "title":          title,
                        "content":        content,
                        "user_id":        userID,
                        "username":       username,
                        "dialog_type":    dialogType,
                        "parent_page_id": parentPageID,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("❌ MCP save_dialog error: %v", err)
                return MCPResult{Success: false, Message: fmt.Sprintf("MCP error: %v", err)}
        }</span>

        <span class="cov0" title="0">if result.IsError </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "Tool returned error"}
        }</span>

        // Извлекаем текст из результата
        <span class="cov0" title="0">var responseText string
        for _, content := range result.Content </span><span class="cov0" title="0">{
                if textContent, ok := content.(*mcp.TextContent); ok </span><span class="cov0" title="0">{
                        responseText += textContent.Text
                }</span>
        }

        <span class="cov0" title="0">var pageID string
        if result.Meta != nil </span><span class="cov0" title="0">{
                if id, ok := result.Meta["page_id"].(string); ok </span><span class="cov0" title="0">{
                        pageID = id
                }</span>
        }

        <span class="cov0" title="0">return MCPResult{
                Success: true,
                Message: responseText,
                PageID:  pageID,
                Data:    formatResultMeta(result.Meta),
        }</span>
}

// SearchDialogSummaries ищет сохраненные диалоги через кастомный MCP
func (m *MCPClient) SearchDialogSummaries(ctx context.Context, query, userID, dialogType string) MCPResult <span class="cov0" title="0">{
        if m.session == nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "MCP session not connected"}
        }</span>

        <span class="cov0" title="0">log.Printf("🔍 Searching Notion via custom MCP: query='%s'", query)

        // Вызываем инструмент search_pages
        result, err := m.session.CallTool(ctx, &amp;mcp.CallToolParams{
                Name: "search_pages",
                Arguments: map[string]any{
                        "query": query,
                        "filter": map[string]any{
                                "property": "Type",
                                "select": map[string]any{
                                        "equals": "Dialog",
                                },
                        },
                        "page_size": 20,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("❌ MCP search error: %v", err)
                return MCPResult{Success: false, Message: fmt.Sprintf("MCP search error: %v", err)}
        }</span>

        <span class="cov0" title="0">if result.IsError </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "Tool returned error"}
        }</span>

        // Извлекаем текст из результата
        <span class="cov0" title="0">var responseText string
        for _, content := range result.Content </span><span class="cov0" title="0">{
                if textContent, ok := content.(*mcp.TextContent); ok </span><span class="cov0" title="0">{
                        responseText += textContent.Text
                }</span>
        }

        <span class="cov0" title="0">return MCPResult{
                Success: true,
                Message: responseText,
                Data:    formatResultMeta(result.Meta),
        }</span>
}

// CreateFreeFormPage создает произвольную страницу через кастомный MCP
func (m *MCPClient) CreateFreeFormPage(ctx context.Context, title, content, parentPageId string, tags []string) MCPResult <span class="cov0" title="0">{
        if m.session == nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "MCP session not connected"}
        }</span>

        <span class="cov0" title="0">log.Printf("📄 Creating free-form page via custom MCP: %s", title)

        // Вызываем инструмент create_page
        args := map[string]any{
                "title":   title,
                "content": content,
                "properties": map[string]any{
                        "Type":    "Free-form",
                        "Created": time.Now().Format("2006-01-02"),
                },
        }

        if parentPageId == "" </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "parent_page_id is required - get it from your Notion workspace"}
        }</span>

        <span class="cov0" title="0">args["parent_page_id"] = parentPageId

        if len(tags) &gt; 0 </span><span class="cov0" title="0">{
                args["properties"].(map[string]any)["Tags"] = tags
        }</span>

        <span class="cov0" title="0">result, err := m.session.CallTool(ctx, &amp;mcp.CallToolParams{
                Name:      "create_page",
                Arguments: args,
        })

        if err != nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: fmt.Sprintf("MCP error: %v", err)}
        }</span>

        <span class="cov0" title="0">if result.IsError </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: fmt.Sprintf("Tool returned error: %v", result.Content)}
        }</span>

        // Извлекаем текст из результата
        <span class="cov0" title="0">var responseText string
        for _, content := range result.Content </span><span class="cov0" title="0">{
                if textContent, ok := content.(*mcp.TextContent); ok </span><span class="cov0" title="0">{
                        responseText += textContent.Text
                }</span>
        }

        <span class="cov0" title="0">var pageID string
        if result.Meta != nil </span><span class="cov0" title="0">{
                if id, ok := result.Meta["page_id"].(string); ok </span><span class="cov0" title="0">{
                        pageID = id
                }</span>
        }

        <span class="cov0" title="0">return MCPResult{
                Success: true,
                Message: responseText,
                PageID:  pageID,
                Data:    formatResultMeta(result.Meta),
        }</span>
}

// SearchWorkspace выполняет поиск по workspace через кастомный MCP
func (m *MCPClient) SearchWorkspace(ctx context.Context, query, pageType string, tags []string) MCPResult <span class="cov0" title="0">{
        if m.session == nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "MCP session not connected"}
        }</span>

        <span class="cov0" title="0">args := map[string]any{
                "query":     query,
                "page_size": 50,
        }

        // Добавляем фильтр по типу если указан
        if pageType != "" </span><span class="cov0" title="0">{
                args["filter"] = map[string]any{
                        "property": "Type",
                        "select": map[string]any{
                                "equals": pageType,
                        },
                }
        }</span>

        <span class="cov0" title="0">result, err := m.session.CallTool(ctx, &amp;mcp.CallToolParams{
                Name:      "search_pages",
                Arguments: args,
        })

        if err != nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: fmt.Sprintf("MCP search error: %v", err)}
        }</span>

        <span class="cov0" title="0">if result.IsError </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "Tool returned error"}
        }</span>

        // Извлекаем текст из результата
        <span class="cov0" title="0">var responseText string
        for _, content := range result.Content </span><span class="cov0" title="0">{
                if textContent, ok := content.(*mcp.TextContent); ok </span><span class="cov0" title="0">{
                        responseText += textContent.Text
                }</span>
        }

        <span class="cov0" title="0">return MCPResult{
                Success: true,
                Message: responseText,
                Data:    formatResultMeta(result.Meta),
        }</span>
}

// formatResultMeta форматирует метаданные результата в JSON строку
func formatResultMeta(meta any) string <span class="cov0" title="0">{
        if meta == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(meta)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return string(data)</span>
}

// MCPResult представляет результат MCP вызова
type MCPResult struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
        Data    string `json:"data,omitempty"`
        PageID  string `json:"page_id,omitempty"`
}

// MCPCreatePagesResult результат создания страниц через MCP
type MCPCreatePagesResult struct {
        Pages []MCPPageInfo `json:"pages"`
}

// MCPPageInfo информация о созданной странице
type MCPPageInfo struct {
        ID  string `json:"id"`
        URL string `json:"url"`
}

// MCPSearchResult результат поиска через MCP
type MCPSearchResult struct {
        Results []MCPSearchItem `json:"results"`
        Type    string          `json:"type"`
}

// MCPSearchItem элемент результата поиска
type MCPSearchItem struct {
        Title     string `json:"title"`
        URL       string `json:"url"`
        Type      string `json:"type"`
        Highlight string `json:"highlight"`
        Timestamp string `json:"timestamp"`
        ID        string `json:"id"`
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package pending

import (
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"

        "ai-chatter/internal/auth"
)

type Repository interface {
        LoadAll() ([]auth.User, error)
        Upsert(user auth.User) error
        Remove(userID int64) error
}

type FileRepository struct {
        path string
        mu   sync.Mutex
}

func NewFileRepository(path string) (*FileRepository, error) <span class="cov1" title="1">{
        if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ensure dir: %w", err)
        }</span>
        <span class="cov1" title="1">f, err := os.OpenFile(path, os.O_CREATE, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("touch file: %w", err)
        }</span>
        <span class="cov1" title="1">_ = f.Close()
        return &amp;FileRepository{path: path}, nil</span>
}

func (r *FileRepository) LoadAll() ([]auth.User, error) <span class="cov6" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open: %w", err)
        }</span>
        <span class="cov6" title="2">defer func(f *os.File) </span><span class="cov6" title="2">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov6" title="2">var users []auth.User
        dec := json.NewDecoder(f)
        if err := dec.Decode(&amp;users); err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return []auth.User{}, nil
                }</span>
                <span class="cov0" title="0">return []auth.User{}, nil</span>
        }
        <span class="cov6" title="2">return users, nil</span>
}

func (r *FileRepository) Upsert(user auth.User) error <span class="cov6" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()
        users, _ := r.loadUnlocked()
        updated := false
        for i, u := range users </span><span class="cov1" title="1">{
                if u.ID == user.ID </span><span class="cov0" title="0">{
                        users[i] = user
                        updated = true
                        break</span>
                }
        }
        <span class="cov6" title="2">if !updated </span><span class="cov6" title="2">{
                users = append(users, user)
        }</span>
        <span class="cov6" title="2">return r.saveUnlocked(users)</span>
}

func (r *FileRepository) Remove(userID int64) error <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        users, _ := r.loadUnlocked()
        var out []auth.User
        for _, u := range users </span><span class="cov6" title="2">{
                if u.ID != userID </span><span class="cov1" title="1">{
                        out = append(out, u)
                }</span>
        }
        <span class="cov1" title="1">return r.saveUnlocked(out)</span>
}

func (r *FileRepository) loadUnlocked() ([]auth.User, error) <span class="cov10" title="3">{
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">defer func(f *os.File) </span><span class="cov10" title="3">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov10" title="3">var users []auth.User
        dec := json.NewDecoder(f)
        if err := dec.Decode(&amp;users); err != nil </span><span class="cov1" title="1">{
                return []auth.User{}, nil
        }</span>
        <span class="cov6" title="2">return users, nil</span>
}

func (r *FileRepository) saveUnlocked(users []auth.User) error <span class="cov10" title="3">{
        f, err := os.OpenFile(r.path, os.O_TRUNC|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="3">defer func(f *os.File) </span><span class="cov10" title="3">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov10" title="3">enc := json.NewEncoder(f)
        enc.SetIndent("", "  ")
        return enc.Encode(users)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package storage

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sync"
)

type FileRecorder struct {
        path string
        mu   sync.Mutex
}

func NewFileRecorder(path string) (*FileRecorder, error) <span class="cov1" title="1">{
        if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ensure log dir: %w", err)
        }</span>
        <span class="cov1" title="1">f, err := os.OpenFile(path, os.O_CREATE, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to init log file: %w", err)
        }</span>
        <span class="cov1" title="1">_ = f.Close()
        return &amp;FileRecorder{path: path}, nil</span>
}

func (r *FileRecorder) AppendInteraction(event Event) error <span class="cov10" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()
        f, err := os.OpenFile(r.path, os.O_APPEND|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open append: %w", err)
        }</span>
        <span class="cov10" title="2">defer func(f *os.File) </span><span class="cov10" title="2">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov10" title="2">enc := json.NewEncoder(f)
        if err := enc.Encode(event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("encode append: %w", err)
        }</span>
        <span class="cov10" title="2">return nil</span>
}

func (r *FileRecorder) LoadInteractions() ([]Event, error) <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open read: %w", err)
        }</span>
        <span class="cov1" title="1">defer func(f *os.File) </span><span class="cov1" title="1">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov1" title="1">s := bufio.NewScanner(f)
        buf := make([]byte, 0, 1024*1024)
        s.Buffer(buf, 10*1024*1024)
        var events []Event
        for s.Scan() </span><span class="cov10" title="2">{
                line := s.Bytes()
                if len(line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="2">var ev Event
                if err := json.Unmarshal(line, &amp;ev); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="2">events = append(events, ev)</span>
        }
        <span class="cov1" title="1">if err := s.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scan: %w", err)
        }</span>
        <span class="cov1" title="1">return events, nil</span>
}

func (r *FileRecorder) SetAllCanUse(userID int64, canUse bool) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        // read all
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open read: %w", err)
        }</span>
        <span class="cov0" title="0">var events []Event
        s := bufio.NewScanner(f)
        buf := make([]byte, 0, 1024*1024)
        s.Buffer(buf, 10*1024*1024)
        for s.Scan() </span><span class="cov0" title="0">{
                line := s.Bytes()
                if len(line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var ev Event
                if err := json.Unmarshal(line, &amp;ev); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if ev.UserID == userID </span><span class="cov0" title="0">{
                        ev.CanUse = &amp;canUse
                }</span>
                <span class="cov0" title="0">events = append(events, ev)</span>
        }
        <span class="cov0" title="0">_ = f.Close()
        if err := s.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("scan: %w", err)
        }</span>
        // rewrite file
        <span class="cov0" title="0">wf, err := os.OpenFile(r.path, os.O_TRUNC|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open write: %w", err)
        }</span>
        <span class="cov0" title="0">defer func(wf *os.File) </span><span class="cov0" title="0">{
                err := wf.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(wf)
        <span class="cov0" title="0">enc := json.NewEncoder(wf)
        for _, ev := range events </span><span class="cov0" title="0">{
                if err := enc.Encode(ev); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("encode: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package telegram

import tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

type sender interface {
        Send(c tgbotapi.Chattable) (tgbotapi.Message, error)
}

type botAPISender struct{ api *tgbotapi.BotAPI }

func (s botAPISender) Send(c tgbotapi.Chattable) (tgbotapi.Message, error) <span class="cov0" title="0">{
        return s.api.Send(c)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package telegram

import (
        "context"
        "fmt"
        "html"
        "log"
        "os"
        "strings"
        "sync"
        "time"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

        "ai-chatter/internal/auth"
        "ai-chatter/internal/history"
        "ai-chatter/internal/llm"
        "ai-chatter/internal/notion"
        "ai-chatter/internal/pending"
        "ai-chatter/internal/storage"
)

const (
        resetCmd       = "reset_ctx"
        summaryCmd     = "summary_ctx"
        approvePrefix  = "approve:"
        denyPrefix     = "deny:"
        spUpdateMarker = "[system_prompt_update]"
        // TZ conversation limit (assistant clarification turns)
        tzMaxSteps = 15
)

type Bot struct {
        api          *tgbotapi.BotAPI
        s            sender
        authSvc      *auth.Service
        systemPrompt string
        llmClient    llm.Client
        llmMu        sync.RWMutex
        history      *history.Manager
        recorder     storage.Recorder
        adminUserID  int64
        pending      map[int64]auth.User
        pendingRepo  pending.Repository
        parseMode    string
        provider     string
        model        string
        // secondary model for post-TS instruction
        model2           string
        llmClient2       llm.Client
        llmFactory       *llm.Factory
        userSysMu        sync.RWMutex
        userSystemPrompt map[int64]string
        tzMu             sync.RWMutex
        tzMode           map[int64]bool
        // per-user remaining steps in TZ mode
        tzRemaining map[int64]int
        // Notion MCP client
        mcpClient        *notion.MCPClient
        notionParentPage string
}

func New(
        botToken string,
        authSvc *auth.Service,
        llmClient llm.Client,
        llmFactory *llm.Factory,
        systemPrompt string,
        rec storage.Recorder,
        adminUserID int64,
        pendingRepo pending.Repository,
        parseMode string,
        provider string,
        model string,
        mcpClient *notion.MCPClient,
        notionParentPage string,
) (*Bot, error) <span class="cov0" title="0">{
        api, err := tgbotapi.NewBotAPI(botToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">b := &amp;Bot{
                api:              api,
                s:                botAPISender{api: api},
                authSvc:          authSvc,
                systemPrompt:     systemPrompt,
                history:          history.NewManager(),
                recorder:         rec,
                adminUserID:      adminUserID,
                pending:          make(map[int64]auth.User),
                pendingRepo:      pendingRepo,
                parseMode:        parseMode,
                provider:         provider,
                model:            model,
                llmFactory:       llmFactory,
                userSystemPrompt: make(map[int64]string),
                tzMode:           make(map[int64]bool),
                tzRemaining:      make(map[int64]int),
                mcpClient:        mcpClient,
                notionParentPage: notionParentPage,
        }
        // Try to preload model2 from file if present
        if data, err := os.ReadFile("data/model2.txt"); err == nil </span><span class="cov0" title="0">{
                m2 := strings.TrimSpace(string(data))
                if m2 != "" </span><span class="cov0" title="0">{
                        b.model2 = m2
                }</span>
        }
        <span class="cov0" title="0">b.setLLMClient(llmClient)
        if rec != nil </span><span class="cov0" title="0">{
                if events, err := rec.LoadInteractions(); err == nil </span><span class="cov0" title="0">{
                        for _, ev := range events </span><span class="cov0" title="0">{
                                if ev.UserID == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if ev.UserMessage == spUpdateMarker &amp;&amp; ev.AssistantResponse != "" </span><span class="cov0" title="0">{
                                        b.addUserSystemPromptInternal(ev.UserID, ev.AssistantResponse, false)
                                        continue</span>
                                }
                                <span class="cov0" title="0">used := true
                                if ev.CanUse != nil </span><span class="cov0" title="0">{
                                        used = *ev.CanUse
                                }</span>
                                <span class="cov0" title="0">if ev.UserMessage != "" </span><span class="cov0" title="0">{
                                        b.history.AppendUserWithUsed(ev.UserID, ev.UserMessage, used)
                                }</span>
                                <span class="cov0" title="0">if ev.AssistantResponse != "" </span><span class="cov0" title="0">{
                                        b.history.AppendAssistantWithUsed(ev.UserID, ev.AssistantResponse, used)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">if b.pendingRepo != nil </span><span class="cov0" title="0">{
                if items, err := b.pendingRepo.LoadAll(); err == nil </span><span class="cov0" title="0">{
                        for _, u := range items </span><span class="cov0" title="0">{
                                b.pending[u.ID] = u
                        }</span>
                }
        }
        <span class="cov0" title="0">return b, nil</span>
}

func (b *Bot) getLLMClient() llm.Client <span class="cov6" title="12">{
        b.llmMu.RLock()
        defer b.llmMu.RUnlock()
        return b.llmClient
}</span>

func (b *Bot) setLLMClient(c llm.Client) <span class="cov0" title="0">{
        b.llmMu.Lock()
        defer b.llmMu.Unlock()
        b.llmClient = c
}</span>

func (b *Bot) getSecondLLMClient() llm.Client <span class="cov5" title="7">{
        b.llmMu.RLock()
        cli := b.llmClient2
        b.llmMu.RUnlock()
        if cli != nil </span><span class="cov4" title="5">{
                return cli
        }</span>

        <span class="cov2" title="2">desiredModel := b.model
        if strings.TrimSpace(b.model2) != "" </span><span class="cov0" title="0">{
                desiredModel = b.model2
        }</span>

        <span class="cov2" title="2">newCli, err := b.llmFactory.CreateClient(b.provider, desiredModel)
        if err != nil </span><span class="cov2" title="2">{
                // Fallback to primary client
                newCli = b.getLLMClient()
        }</span>

        <span class="cov2" title="2">b.llmMu.Lock()
        if b.llmClient2 == nil </span><span class="cov2" title="2">{
                b.llmClient2 = newCli
                cli = newCli
        }</span> else<span class="cov0" title="0"> {
                cli = b.llmClient2
        }</span>
        <span class="cov2" title="2">b.llmMu.Unlock()
        return cli</span>
}

func (b *Bot) reloadLLMClient() error <span class="cov0" title="0">{
        newCli, err := b.llmFactory.CreateClient(b.provider, b.model)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">b.setLLMClient(newCli)
        b.llmMu.Lock()
        b.llmClient2 = nil
        b.llmMu.Unlock()
        return nil</span>
}

func (b *Bot) escapeIfNeeded(s string) string <span class="cov7" title="14">{
        pm := strings.ToLower(b.parseModeValue())
        switch pm </span>{
        case strings.ToLower(tgbotapi.ModeMarkdownV2):<span class="cov0" title="0">
                return escapeMarkdownV2(s)</span>
        case strings.ToLower(tgbotapi.ModeHTML):<span class="cov6" title="12">
                return html.EscapeString(s)</span>
        default:<span class="cov2" title="2">
                return s</span>
        }
}

func escapeMarkdownV2(s string) string <span class="cov0" title="0">{
        repl := strings.NewReplacer(
                "_", "\\_",
                "*", "\\*",
                "[", "\\[",
                "]", "\\]",
                "(", "\\(",
                ")", "\\)",
                "~", "\\~",
                "`", "\\`",
                "&gt;", "\\&gt;",
                "#", "\\#",
                "+", "\\+",
                "-", "\\-",
                "=", "\\=",
                "|", "\\|",
                "{", "\\{",
                "}", "\\}",
                ".", "\\.",
                "!", "\\!",
        )
        return repl.Replace(s)
}</span>

func (b *Bot) parseModeValue() string <span class="cov9" title="45">{
        s := strings.ToLower(b.parseMode)
        switch s </span>{
        case strings.ToLower(tgbotapi.ModeMarkdown), strings.ToLower(tgbotapi.ModeMarkdownV2), strings.ToLower(tgbotapi.ModeHTML):<span class="cov9" title="43">
                return b.parseMode</span>
        default:<span class="cov2" title="2">
                return tgbotapi.ModeMarkdown</span>
        }
}

func (b *Bot) Start(ctx context.Context) <span class="cov0" title="0">{
        u := tgbotapi.NewUpdate(0)
        u.Timeout = 60

        log.Printf("Bot started")
        if b.adminUserID != 0 </span><span class="cov0" title="0">{
                info := fmt.Sprintf("Бот запущен и готов к работе. Провайдер: %s, модель: %s.", b.provider, b.model)
                b.sendMessage(b.adminUserID, info)
        }</span>

        <span class="cov0" title="0">updates := b.api.GetUpdatesChan(u)

        for update := range updates </span><span class="cov0" title="0">{
                if update.Message != nil </span><span class="cov0" title="0">{
                        if update.Message.IsCommand() </span><span class="cov0" title="0">{
                                if update.Message.Command() == "start" </span><span class="cov0" title="0">{
                                        b.handleStart(update.Message)
                                        continue</span>
                                }
                                <span class="cov0" title="0">b.handleCommand(update.Message)
                                continue</span>
                        }
                        <span class="cov0" title="0">b.handleIncomingMessage(ctx, update.Message)
                        continue</span>
                }
                <span class="cov0" title="0">if update.CallbackQuery != nil </span><span class="cov0" title="0">{
                        b.handleCallback(ctx, update.CallbackQuery)
                        continue</span>
                }
        }
}

func (b *Bot) handleStart(msg *tgbotapi.Message) <span class="cov0" title="0">{
        welcome := "Привет! Я LLM-бот. Отвечаю на вопросы с учётом контекста. Под каждым ответом есть кнопки: ‘История’ (саммари диалога) и ‘Сбросить контекст’."
        if b.authSvc.IsAllowed(msg.From.ID) </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, welcome+"\n\nДоступ уже предоставлен. Можете писать сообщение.")
                return
        }</span>
        // Not allowed: cache and request admin
        <span class="cov0" title="0">b.pending[msg.From.ID] = auth.User{ID: msg.From.ID, Username: msg.From.UserName, FirstName: msg.From.FirstName, LastName: msg.From.LastName}
        b.notifyAdminRequest(msg.From.ID, msg.From.UserName)
        b.sendMessage(msg.Chat.ID, welcome+"\n\nЗапрос на доступ отправлен администратору. Как только он подтвердит, вы получите уведомление.")</span>
}

// handleCommand is implemented in handlers.go

func (b *Bot) handleAdminConfigCommands(msg *tgbotapi.Message) <span class="cov1" title="1">{
        if msg.From.ID != b.adminUserID </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "Команда доступна только администратору")
                return
        }</span>
        <span class="cov1" title="1">cmd := msg.Command()
        args := strings.Fields(msg.CommandArguments())
        switch cmd </span>{
        case "provider":<span class="cov0" title="0">
                if len(args) != 1 </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Usage: /provider &lt;openai|yandex&gt;")
                        return
                }</span>
                <span class="cov0" title="0">prov := strings.ToLower(args[0])
                if prov != "openai" &amp;&amp; prov != "yandex" </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Поддерживаются: openai, yandex")
                        return
                }</span>
                <span class="cov0" title="0">if err := os.WriteFile("data/provider.txt", []byte(prov), 0o644); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Ошибка сохранения: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.provider = prov
                if err := b.reloadLLMClient(); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Ошибка перезагрузки клиента: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, fmt.Sprintf("Провайдер установлен и применён: %s", prov))</span>
        case "model":<span class="cov0" title="0">
                if len(args) != 1 </span><span class="cov0" title="0">{
                        allowedModels := strings.Join(llm.GetAllowedModels(), "|")
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Usage: /model &lt;%s&gt;", allowedModels))
                        return
                }</span>
                <span class="cov0" title="0">model := args[0]
                if !llm.IsModelAllowed(model) </span><span class="cov0" title="0">{
                        allowedModels := strings.Join(llm.GetAllowedModels(), ", ")
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Неподдерживаемая модель. Доступные: %s", allowedModels))
                        return
                }</span>
                <span class="cov0" title="0">if err := os.WriteFile("data/model.txt", []byte(model), 0o644); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Ошибка сохранения: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.model = model
                if err := b.reloadLLMClient(); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Ошибка перезагрузки клиента: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, fmt.Sprintf("Модель установлена и применена: %s", model))</span>
        case "model2":<span class="cov1" title="1">
                if len(args) != 1 </span><span class="cov0" title="0">{
                        allowedModels := strings.Join(llm.GetAllowedModels(), "|")
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Usage: /model2 &lt;%s&gt;", allowedModels))
                        return
                }</span>
                <span class="cov1" title="1">model := args[0]
                if !llm.IsModelAllowed(model) </span><span class="cov1" title="1">{
                        allowedModels := strings.Join(llm.GetAllowedModels(), ", ")
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Неподдерживаемая модель. Доступные: %s", allowedModels))
                        return
                }</span>
                <span class="cov0" title="0">if err := os.WriteFile("data/model2.txt", []byte(model), 0o644); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Ошибка сохранения: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.model2 = model
                b.llmMu.Lock()
                b.llmClient2 = nil
                b.llmMu.Unlock()
                b.sendMessage(msg.Chat.ID, fmt.Sprintf("Вторая модель установлена: %s", model))</span>
        }
}

// JSON parsing moved to process.go

func (b *Bot) formatTitleAnswer(title, answer string) string <span class="cov6" title="11">{
        pm := strings.ToLower(b.parseModeValue())
        switch pm </span>{
        case strings.ToLower(tgbotapi.ModeHTML):<span class="cov6" title="11">
                // Preserve answer formatting as-is; escape only title
                return fmt.Sprintf("&lt;b&gt;%s&lt;/b&gt;\n\n%s", html.EscapeString(title), answer)</span>
        case strings.ToLower(tgbotapi.ModeMarkdownV2):<span class="cov0" title="0">
                // Preserve answer; escape title
                return fmt.Sprintf("%s\n\n%s", escapeMarkdownV2(title), answer)</span>
        default:<span class="cov0" title="0"> // Markdown
                return fmt.Sprintf("%s\n\n%s", title, answer)</span>
        }
}

// Context management

func sizeOfMessages(msgs []llm.Message) int <span class="cov0" title="0">{
        t := 0
        for _, m := range msgs </span><span class="cov0" title="0">{
                t += len(m.Content)
        }</span>
        <span class="cov0" title="0">return t</span>
}

func truncateForLog(s string, limit int) string <span class="cov9" title="32">{
        if len(s) &lt;= limit </span><span class="cov9" title="32">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:limit] + "…"</span>
}

func (b *Bot) logLLMRequest(userID int64, purpose string, msgs []llm.Message) <span class="cov7" title="17">{
        var bld strings.Builder
        bld.WriteString(fmt.Sprintf("LLM request | user=%d | purpose=%s | provider=%s | model=%s | messages=%d\n", userID, purpose, b.provider, b.model, len(msgs)))
        for i, m := range msgs </span><span class="cov9" title="32">{
                content := truncateForLog(m.Content, 1500)
                bld.WriteString(fmt.Sprintf("  [%d] role=%s len=%d\n      %s\n", i, m.Role, len(m.Content), content))
        }</span>
        <span class="cov7" title="17">log.Print(bld.String())</span>
}

// Retry to conform to schema
func (b *Bot) reformatToSchema(ctx context.Context, userID int64, raw string) (llmJSON, bool) <span class="cov0" title="0">{
        instr := "You are a formatter. Reformat the previous output strictly into a JSON object with exactly these fields: {title, answer, compressed_context, status}. Values: status must be one of ['continue','final']. Do not add other top-level keys. Do not change content, only structure."
        msgs := []llm.Message{{Role: "system", Content: instr}, {Role: "user", Content: raw}}
        b.logLLMRequest(userID, "reformat_to_schema", msgs)
        resp, err := b.getLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                return llmJSON{}, false
        }</span>
        <span class="cov0" title="0">p, ok := parseLLMJSON(resp.Content)
        return p, ok</span>
}

// Context build no longer proactively compresses
func (b *Bot) buildContextWithOverflow(ctx context.Context, userID int64) []llm.Message <span class="cov6" title="9">{
        var msgs []llm.Message
        sys := b.getUserSystemPrompt(userID)
        if sys != "" </span><span class="cov5" title="7">{
                msgs = append(msgs, llm.Message{Role: "system", Content: sys})
        }</span>
        <span class="cov6" title="9">msgs = append(msgs, b.history.Get(userID)...)
        _ = ctx
        return msgs</span>
}

// Command handling additions

// moved: handlers in handlers.go

func (b *Bot) approveUser(id int64) <span class="cov0" title="0">{
        u := b.pending[id]
        if u.ID == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">delete(b.pending, id)
        if b.pendingRepo != nil </span><span class="cov0" title="0">{
                _ = b.pendingRepo.Remove(id)
        }</span>
        <span class="cov0" title="0">_ = b.authSvc.Upsert(u)
        msg := tgbotapi.NewMessage(b.adminUserID, b.escapeIfNeeded(fmt.Sprintf("Пользователь @%s (%d) добавлен в allowlist", u.Username, u.ID)))
        msg.ParseMode = b.parseModeValue()
        if _, err := b.s.Send(msg); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to notify approval: %v", err)
        }</span>
        <span class="cov0" title="0">msg2 := tgbotapi.NewMessage(u.ID, b.escapeIfNeeded("Ваш доступ к боту подтвержден. Добро пожаловать!"))
        msg2.ParseMode = b.parseModeValue()
        if _, err := b.s.Send(msg2); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to notify user approval: %v", err)
        }</span>
}

func (b *Bot) denyUser(id int64) <span class="cov0" title="0">{
        u := b.pending[id]
        if u.ID == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">delete(b.pending, id)
        if b.pendingRepo != nil </span><span class="cov0" title="0">{
                _ = b.pendingRepo.Remove(id)
        }</span>
        <span class="cov0" title="0">msg := tgbotapi.NewMessage(b.adminUserID, b.escapeIfNeeded(fmt.Sprintf("Пользователю @%s (%d) отказано в доступе", u.Username, u.ID)))
        msg.ParseMode = b.parseModeValue()
        if _, err := b.s.Send(msg); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to notify denial: %v", err)
        }</span>
}

func (b *Bot) menuKeyboard() tgbotapi.InlineKeyboardMarkup <span class="cov6" title="11">{
        return tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("Сбросить контекст", resetCmd),
                        tgbotapi.NewInlineKeyboardButtonData("История", summaryCmd),
                ),
        )
}</span>

func (b *Bot) sendMessage(chatID int64, text string) <span class="cov2" title="2">{
        msg := tgbotapi.NewMessage(chatID, b.escapeIfNeeded(text))
        msg.ParseMode = b.parseModeValue()
        if _, err := b.s.Send(msg); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

func (b *Bot) getUserSystemPrompt(userID int64) string <span class="cov6" title="9">{
        b.userSysMu.RLock()
        sp, ok := b.userSystemPrompt[userID]
        b.userSysMu.RUnlock()
        if !ok || sp == "" </span><span class="cov5" title="6">{
                return b.systemPrompt
        }</span>
        <span class="cov3" title="3">return sp</span>
}

func (b *Bot) addUserSystemPrompt(userID int64, addition string) <span class="cov3" title="3">{
        b.addUserSystemPromptInternal(userID, addition, true)
}</span>

func (b *Bot) addUserSystemPromptInternal(userID int64, addition string, persist bool) <span class="cov3" title="3">{
        if strings.TrimSpace(addition) == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="3">b.userSysMu.Lock()
        if b.userSystemPrompt == nil </span><span class="cov3" title="3">{
                b.userSystemPrompt = make(map[int64]string)
        }</span>
        <span class="cov3" title="3">current := b.userSystemPrompt[userID]
        if current == "" </span><span class="cov3" title="3">{
                current = b.systemPrompt
        }</span>
        <span class="cov3" title="3">if !strings.Contains(current, addition) </span><span class="cov3" title="3">{
                if current != "" </span><span class="cov2" title="2">{
                        current = current + "\n\n" + addition
                }</span> else<span class="cov1" title="1"> {
                        current = addition
                }</span>
                <span class="cov3" title="3">b.userSystemPrompt[userID] = current</span>
        }
        <span class="cov3" title="3">b.userSysMu.Unlock()
        if persist &amp;&amp; b.recorder != nil </span><span class="cov0" title="0">{
                f := false
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: time.Now().UTC(), UserID: userID, UserMessage: spUpdateMarker, AssistantResponse: addition, CanUse: &amp;f})
        }</span>
}

// --- TZ helpers ---

func (b *Bot) setTZMode(userID int64, on bool) <span class="cov4" title="4">{
        b.tzMu.Lock()
        if b.tzMode == nil </span><span class="cov4" title="4">{
                b.tzMode = make(map[int64]bool)
        }</span>
        <span class="cov4" title="4">b.tzMode[userID] = on
        b.tzMu.Unlock()</span>
}
func (b *Bot) isTZMode(userID int64) bool <span class="cov10" title="46">{
        b.tzMu.RLock()
        v := false
        if b.tzMode != nil </span><span class="cov8" title="22">{
                v = b.tzMode[userID]
        }</span>
        <span class="cov10" title="46">b.tzMu.RUnlock()
        return v</span>
}

func (b *Bot) setTZRemaining(userID int64, steps int) <span class="cov4" title="4">{
        b.tzMu.Lock()
        if b.tzRemaining == nil </span><span class="cov4" title="4">{
                b.tzRemaining = make(map[int64]int)
        }</span>
        <span class="cov4" title="4">b.tzRemaining[userID] = steps
        b.tzMu.Unlock()</span>
}
func (b *Bot) getTZRemaining(userID int64) int <span class="cov5" title="6">{
        b.tzMu.RLock()
        v := 0
        if b.tzRemaining != nil </span><span class="cov5" title="6">{
                v = b.tzRemaining[userID]
        }</span>
        <span class="cov5" title="6">b.tzMu.RUnlock()
        return v</span>
}
func (b *Bot) decTZRemaining(userID int64) int <span class="cov2" title="2">{
        b.tzMu.Lock()
        if b.tzRemaining == nil </span><span class="cov0" title="0">{
                b.tzRemaining = make(map[int64]int)
        }</span>
        <span class="cov2" title="2">left := b.tzRemaining[userID]
        if left &gt; 0 </span><span class="cov2" title="2">{
                left--
                b.tzRemaining[userID] = left
        }</span>
        <span class="cov2" title="2">b.tzMu.Unlock()
        return left</span>
}
func (b *Bot) clearTZState(userID int64) <span class="cov3" title="3">{
        b.tzMu.Lock()
        if b.tzMode != nil </span><span class="cov3" title="3">{
                delete(b.tzMode, userID)
        }</span>
        <span class="cov3" title="3">if b.tzRemaining != nil </span><span class="cov3" title="3">{
                delete(b.tzRemaining, userID)
        }</span>
        <span class="cov3" title="3">b.tzMu.Unlock()</span>
}

// Building context with overflow protection

func (b *Bot) produceFinalTS(ctx context.Context, userID int64) (llmJSON, llm.Response, bool) <span class="cov1" title="1">{
        msgs := b.buildContextWithOverflow(ctx, userID)
        finalInstr := "Сформируй итоговое техническое задание (ТЗ) по собранным данным. Ответ строго в JSON со схемой {title, answer, compressed_context, status}. В 'answer' помести полноценное, структурированное ТЗ. Установи status='final'."
        msgs = append([]llm.Message{{Role: "system", Content: finalInstr}}, msgs...)
        b.logLLMRequest(userID, "tz_finalize", msgs)
        resp, err := b.getLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                return llmJSON{}, llm.Response{}, false
        }</span>
        <span class="cov1" title="1">p, ok := parseLLMJSON(resp.Content)
        if !ok </span><span class="cov0" title="0">{
                if p2, ok2 := b.reformatToSchema(ctx, userID, resp.Content); ok2 </span><span class="cov0" title="0">{
                        return p2, resp, true
                }</span>
                <span class="cov0" title="0">return llmJSON{}, llm.Response{}, false</span>
        }
        <span class="cov1" title="1">return p, resp, true</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package telegram

import (
        "context"
        "fmt"
        "log"
        "strconv"
        "strings"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

        "ai-chatter/internal/auth"
        "ai-chatter/internal/llm"
        "ai-chatter/internal/storage"
)

// handleCommand
func (b *Bot) handleCommand(msg *tgbotapi.Message) <span class="cov4" title="2">{
        if msg.Command() == "provider" || msg.Command() == "model" || msg.Command() == "model2" </span><span class="cov0" title="0">{
                b.handleAdminConfigCommands(msg)
                return
        }</span>
        // Notion commands
        <span class="cov4" title="2">if msg.Command() == "notion_save" </span><span class="cov0" title="0">{
                b.handleNotionSave(msg)
                return
        }</span>
        <span class="cov4" title="2">if msg.Command() == "notion_search" </span><span class="cov0" title="0">{
                b.handleNotionSearch(msg)
                return
        }</span>
        <span class="cov4" title="2">if msg.Command() == "tz" </span><span class="cov4" title="2">{
                if !b.authSvc.IsAllowed(msg.From.ID) </span><span class="cov0" title="0">{
                        return
                }</span>
                // Reset previous context for this user (do not delete logs, just mark not used)
                <span class="cov4" title="2">b.history.DisableAll(msg.From.ID)
                if b.recorder != nil </span><span class="cov0" title="0">{
                        _ = b.recorder.SetAllCanUse(msg.From.ID, false)
                }</span>

                <span class="cov4" title="2">topic := strings.TrimSpace(msg.CommandArguments())
                addition := "Requirements elicitation mode (Technical Specification). Your job is to iteratively clarify and assemble a complete TS in Russian for the topic: '" + topic + "'. " +
                        "Ask up to 5 highly targeted questions per turn until you are confident the TS is complete. Focus on: scope/goals, user roles, environment, constraints (budget/time/tech), functional and non-functional requirements, data and integrations, dependencies, acceptance criteria, risks/mitigations, deliverables and plan. " +
                        "When asking questions, prefer concrete options (multiple-choice) and short free-form fields; personalize questions to the user’s previous answers (e.g., preferred and unwanted ingredients, platforms, APIs, performance targets). " +
                        "Always respond strictly in JSON {title, answer, compressed_context, status}. Set status='continue' while clarifying. When the TS is fully ready, set status='final'. If your context window is &gt;= 80% full, include 'compressed_context' with a compact string summary of essential facts/decisions to continue without previous messages. You have at most 15 messages to clarify before finalization. " +
                        "VERY IMPORTANT: Present your questions as a numbered list (1., 2., 3., ...) with each question on its own new line. Do not merge questions into a single paragraph."
                b.addUserSystemPrompt(msg.From.ID, addition)
                b.setTZMode(msg.From.ID, true)
                b.setTZRemaining(msg.From.ID, tzMaxSteps)
                seed := "Тема ТЗ: " + topic
                b.history.AppendUser(msg.From.ID, seed)
                if b.recorder != nil </span><span class="cov0" title="0">{
                        tru := true
                        _ = b.recorder.AppendInteraction(storage.Event{Timestamp: b.nowUTC(), UserID: msg.From.ID, UserMessage: seed, CanUse: &amp;tru})
                }</span>
                <span class="cov4" title="2">ctx := context.Background()
                contextMsgs := b.buildContextWithOverflow(ctx, msg.From.ID)
                if b.isTZMode(msg.From.ID) </span><span class="cov4" title="2">{
                        left := b.getTZRemaining(msg.From.ID)
                        if left &gt; 0 &amp;&amp; left &lt;= 2 </span><span class="cov0" title="0">{
                                accel := "Осталось очень мало сообщений для уточнений (&lt;=2). Сократи количество вопросов и постарайся завершить формирование ТЗ как можно скорее. Если возможно — финализируй уже в этом ответе (status='final')."
                                contextMsgs = append([]llm.Message{{Role: "system", Content: accel}}, contextMsgs...)
                        }</span>
                }
                <span class="cov4" title="2">b.logLLMRequest(msg.From.ID, "tz_bootstrap", contextMsgs)
                resp, err := b.getLLMClient().Generate(ctx, contextMsgs)
                if err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Не удалось стартовать режим ТЗ, попробуйте ещё раз.")
                        log.Println(err)
                        return
                }</span>
                <span class="cov4" title="2">b.processLLMAndRespond(ctx, msg.Chat.ID, msg.From.ID, resp)
                return</span>
        }
        // admin-only commands
        <span class="cov0" title="0">if msg.From.ID != b.adminUserID </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "Команда доступна только администратору")
                return
        }</span>
        <span class="cov0" title="0">switch msg.Command() </span>{
        case "allowlist":<span class="cov0" title="0">
                var bld strings.Builder
                bld.WriteString("Allowlist:\n")
                for _, u := range b.authSvc.List() </span><span class="cov0" title="0">{
                        bld.WriteString(fmt.Sprintf("- id=%d, @%s %s %s\n", u.ID, u.Username, u.FirstName, u.LastName))
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, bld.String())</span>
        case "remove":<span class="cov0" title="0">
                args := strings.Fields(msg.CommandArguments())
                if len(args) != 1 </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Usage: /remove &lt;user_id&gt;")
                        return
                }</span>
                <span class="cov0" title="0">uid, err := strconv.ParseInt(args[0], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Некорректный user_id")
                        return
                }</span>
                <span class="cov0" title="0">if err := b.authSvc.Remove(uid); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Ошибка удаления: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, fmt.Sprintf("Пользователь %d удален из allowlist", uid))</span>
        case "pending":<span class="cov0" title="0">
                var bld strings.Builder
                bld.WriteString("Pending заявки:\n")
                for _, u := range b.pending </span><span class="cov0" title="0">{
                        bld.WriteString(fmt.Sprintf("- id=%d, @%s %s %s\n", u.ID, u.Username, u.FirstName, u.LastName))
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, bld.String())</span>
        case "approve":<span class="cov0" title="0">
                args := strings.Fields(msg.CommandArguments())
                if len(args) != 1 </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Usage: /approve &lt;user_id&gt;")
                        return
                }</span>
                <span class="cov0" title="0">uid, err := strconv.ParseInt(args[0], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Некорректный user_id")
                        return
                }</span>
                <span class="cov0" title="0">b.approveUser(uid)</span>
        case "deny":<span class="cov0" title="0">
                args := strings.Fields(msg.CommandArguments())
                if len(args) != 1 </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Usage: /deny &lt;user_id&gt;")
                        return
                }</span>
                <span class="cov0" title="0">uid, err := strconv.ParseInt(args[0], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Некорректный user_id")
                        return
                }</span>
                <span class="cov0" title="0">b.denyUser(uid)</span>
        }
}

// handleIncomingMessage
func (b *Bot) handleIncomingMessage(ctx context.Context, msg *tgbotapi.Message) <span class="cov10" title="6">{
        if !b.authSvc.IsAllowed(msg.From.ID) </span><span class="cov0" title="0">{
                log.Printf("Unauthorized access attempt by user ID: %d, username: @%s", msg.From.ID, msg.From.UserName)
                if _, ok := b.pending[msg.From.ID]; ok </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Ваш запрос на доступ уже отправлен администратору. Пожалуйста, ожидайте подтверждения. Как только доступ будет предоставлен, я уведомлю вас.")
                        return
                }</span>
                <span class="cov0" title="0">b.pending[msg.From.ID] = auth.User{ID: msg.From.ID, Username: msg.From.UserName, FirstName: msg.From.FirstName, LastName: msg.From.LastName}
                if b.pendingRepo != nil </span><span class="cov0" title="0">{
                        _ = b.pendingRepo.Upsert(b.pending[msg.From.ID])
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, "Запрос на доступ отправлен администратору. Как только он подтвердит, вы получите уведомление.")
                b.notifyAdminRequest(msg.From.ID, msg.From.UserName)
                return</span>
        }
        <span class="cov10" title="6">log.Printf("Incoming message from %d (@%s): %q", msg.From.ID, msg.From.UserName, msg.Text)
        b.history.AppendUser(msg.From.ID, msg.Text)
        if b.recorder != nil </span><span class="cov0" title="0">{
                tru := true
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: b.nowUTC(), UserID: msg.From.ID, UserMessage: msg.Text, CanUse: &amp;tru})
        }</span>

        <span class="cov10" title="6">if b.isTZMode(msg.From.ID) &amp;&amp; b.getTZRemaining(msg.From.ID) &lt;= 0 </span><span class="cov0" title="0">{
                if pFinal, respFinal, okFinal := b.produceFinalTS(ctx, msg.From.ID); okFinal </span><span class="cov0" title="0">{
                        b.sendFinalTS(msg.Chat.ID, msg.From.ID, pFinal, respFinal)
                        return
                }</span>
        }

        <span class="cov10" title="6">contextMsgs := b.buildContextWithOverflow(ctx, msg.From.ID)
        if b.isTZMode(msg.From.ID) </span><span class="cov4" title="2">{
                left := b.getTZRemaining(msg.From.ID)
                if left &gt; 0 &amp;&amp; left &lt;= 2 </span><span class="cov4" title="2">{
                        accel := "Осталось очень мало сообщений для уточнений (&lt;=2). Сократи количество вопросов и постарайся завершить формирование ТЗ как можно скорее. Если возможно — финализируй уже в этом ответе (status='final')."
                        contextMsgs = append([]llm.Message{{Role: "system", Content: accel}}, contextMsgs...)
                }</span>
        }
        <span class="cov10" title="6">b.logLLMRequest(msg.From.ID, "chat", contextMsgs)

        // Используем инструменты Notion только если клиент настроен и не в режиме ТЗ
        var resp llm.Response
        var err error
        if b.mcpClient != nil &amp;&amp; !b.isTZMode(msg.From.ID) </span><span class="cov0" title="0">{
                tools := llm.GetNotionTools()
                resp, err = b.getLLMClient().GenerateWithTools(ctx, contextMsgs, tools)
        }</span> else<span class="cov10" title="6"> {
                resp, err = b.getLLMClient().Generate(ctx, contextMsgs)
        }</span>

        <span class="cov10" title="6">if err != nil </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "Sorry, something went wrong.")
                return
        }</span>
        <span class="cov10" title="6">b.processLLMAndRespond(ctx, msg.Chat.ID, msg.From.ID, resp)</span>
}

// notifyAdminRequest
func (b *Bot) notifyAdminRequest(userID int64, username string) <span class="cov1" title="1">{
        if b.adminUserID == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">text := fmt.Sprintf("Пользователь @%s с id %d хочет пользоваться ботом", username, userID)
        kb := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("разрешить", approvePrefix+strconv.FormatInt(userID, 10)),
                        tgbotapi.NewInlineKeyboardButtonData("запретить", denyPrefix+strconv.FormatInt(userID, 10)),
                ),
        )
        msg := tgbotapi.NewMessage(b.adminUserID, b.escapeIfNeeded(text))
        msg.ParseMode = b.parseModeValue()
        msg.ReplyMarkup = kb
        _, _ = b.s.Send(msg)</span>
}

// handleCallback
func (b *Bot) handleCallback(ctx context.Context, cb *tgbotapi.CallbackQuery) <span class="cov0" title="0">{
        switch </span>{
        case cb.Data == resetCmd:<span class="cov0" title="0">
                b.history.DisableAll(cb.From.ID)
                if b.recorder != nil </span><span class="cov0" title="0">{
                        _ = b.recorder.SetAllCanUse(cb.From.ID, false)
                }</span>
                <span class="cov0" title="0">msg := tgbotapi.NewMessage(cb.Message.Chat.ID, b.escapeIfNeeded("Контекст очищен"))
                msg.ParseMode = b.parseModeValue()
                msg.ReplyMarkup = b.menuKeyboard()
                if _, err := b.s.Send(msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to send reset confirmation: %v", err)
                }</span>
        case cb.Data == summaryCmd:<span class="cov0" title="0">
                b.handleSummary(ctx, cb)</span>
        default:<span class="cov0" title="0">
                switch </span>{
                case strings.HasPrefix(cb.Data, approvePrefix):<span class="cov0" title="0">
                        idStr := strings.TrimPrefix(cb.Data, approvePrefix)
                        id, _ := strconv.ParseInt(idStr, 10, 64)
                        b.approveUser(id)</span>
                case strings.HasPrefix(cb.Data, denyPrefix):<span class="cov0" title="0">
                        idStr := strings.TrimPrefix(cb.Data, denyPrefix)
                        id, _ := strconv.ParseInt(idStr, 10, 64)
                        b.denyUser(id)</span>
                }
        }
}

// handleSummary
func (b *Bot) handleSummary(ctx context.Context, cb *tgbotapi.CallbackQuery) <span class="cov0" title="0">{
        h := b.history.Get(cb.From.ID)
        if len(h) == 0 </span><span class="cov0" title="0">{
                m := tgbotapi.NewMessage(cb.Message.Chat.ID, b.escapeIfNeeded("История пуста"))
                m.ParseMode = b.parseModeValue()
                _, _ = b.s.Send(m)
                return
        }</span>
        <span class="cov0" title="0">msgs := b.buildContextWithOverflow(ctx, cb.From.ID)
        msgs = append([]llm.Message{{Role: "system", Content: "Суммируй переписку. Ответ строго в JSON со схемой {title, answer, compressed_context}."}}, msgs...)
        b.logLLMRequest(cb.From.ID, "summary", msgs)
        resp, err := b.getLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                m := tgbotapi.NewMessage(cb.Message.Chat.ID, b.escapeIfNeeded("Не удалось собрать саммари"))
                m.ParseMode = b.parseModeValue()
                _, _ = b.s.Send(m)
                return
        }</span>
        <span class="cov0" title="0">parsed, ok := parseLLMJSON(resp.Content)
        if !ok </span><span class="cov0" title="0">{
                if p2, ok2 := b.reformatToSchema(ctx, cb.From.ID, resp.Content); ok2 </span><span class="cov0" title="0">{
                        parsed = p2
                        ok = true
                }</span>
        }
        <span class="cov0" title="0">if ok &amp;&amp; strings.TrimSpace(parsed.CompressedContext) != "" </span><span class="cov0" title="0">{
                b.addUserSystemPrompt(cb.From.ID, parsed.CompressedContext)
                b.history.DisableAll(cb.From.ID)
        }</span>
        <span class="cov0" title="0">answerToSend := resp.Content
        if ok &amp;&amp; parsed.Answer != "" </span><span class="cov0" title="0">{
                answerToSend = parsed.Answer
        }</span>
        <span class="cov0" title="0">b.history.AppendAssistantWithUsed(cb.From.ID, answerToSend, true)
        if b.recorder != nil </span><span class="cov0" title="0">{
                tru := true
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: b.nowUTC(), UserID: cb.From.ID, AssistantResponse: answerToSend, CanUse: &amp;tru})
        }</span>
        <span class="cov0" title="0">metaLine := fmt.Sprintf("[model=%s, tokens: prompt=%d, completion=%d, total=%d]", resp.Model, resp.PromptTokens, resp.CompletionTokens, resp.TotalTokens)
        metaEsc := b.escapeIfNeeded(metaLine)
        body := answerToSend
        if ok &amp;&amp; parsed.Title != "" </span><span class="cov0" title="0">{
                body = b.formatTitleAnswer(parsed.Title, answerToSend)
        }</span>
        <span class="cov0" title="0">final := metaEsc + "\n\n" + body
        m := tgbotapi.NewMessage(cb.Message.Chat.ID, final)
        m.ParseMode = b.parseModeValue()
        m.ReplyMarkup = b.menuKeyboard()
        _, _ = b.s.Send(m)</span>
}

// handleNotionSave сохраняет диалог в Notion
func (b *Bot) handleNotionSave(msg *tgbotapi.Message) <span class="cov0" title="0">{
        if !b.authSvc.IsAllowed(msg.From.ID) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if b.mcpClient == nil </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "Notion интеграция не настроена. Установите NOTION_TOKEN в конфигурации.")
                return
        }</span>

        <span class="cov0" title="0">args := strings.TrimSpace(msg.CommandArguments())
        if args == "" </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "Использование: /notion_save &lt;название страницы&gt;")
                return
        }</span>

        // Собираем контекст диалога
        <span class="cov0" title="0">history := b.history.Get(msg.From.ID)
        if len(history) == 0 </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "История диалога пуста, нечего сохранять.")
                return
        }</span>

        // Формируем содержимое страницы
        <span class="cov0" title="0">var content strings.Builder
        for _, msg := range history </span><span class="cov0" title="0">{
                if msg.Role == "user" </span><span class="cov0" title="0">{
                        content.WriteString(fmt.Sprintf("**Пользователь:** %s\n\n", msg.Content))
                }</span> else<span class="cov0" title="0"> if msg.Role == "assistant" </span><span class="cov0" title="0">{
                        content.WriteString(fmt.Sprintf("**Ассистент:** %s\n\n", msg.Content))
                }</span>
        }

        <span class="cov0" title="0">ctx := context.Background()

        // Проверяем настройку parent page
        if b.notionParentPage == "" </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "❌ Не настроен NOTION_PARENT_PAGE_ID. Настройте переменную окружения с ID страницы из Notion.")
                return
        }</span>

        <span class="cov0" title="0">result := b.mcpClient.CreateDialogSummary(
                ctx,
                args, // title
                content.String(),
                fmt.Sprintf("%d", msg.From.ID),
                msg.From.UserName,
                "dialog_summary",
                b.notionParentPage,
        )

        if result.Success </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, fmt.Sprintf("✅ Диалог успешно сохранен в Notion!\n\n%s", result.Message))
        }</span> else<span class="cov0" title="0"> {
                b.sendMessage(msg.Chat.ID, fmt.Sprintf("❌ Ошибка сохранения в Notion: %s", result.Message))
        }</span>
}

// handleNotionSearch ищет в Notion
func (b *Bot) handleNotionSearch(msg *tgbotapi.Message) <span class="cov0" title="0">{
        if !b.authSvc.IsAllowed(msg.From.ID) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if b.mcpClient == nil </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "Notion интеграция не настроена. Установите NOTION_TOKEN в конфигурации.")
                return
        }</span>

        <span class="cov0" title="0">args := strings.TrimSpace(msg.CommandArguments())
        if args == "" </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "Использование: /notion_search &lt;поисковый запрос&gt;")
                return
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        result := b.mcpClient.SearchDialogSummaries(
                ctx,
                args,
                fmt.Sprintf("%d", msg.From.ID),
                "dialog_summary",
        )

        if result.Success </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, fmt.Sprintf("🔍 Результаты поиска в Notion:\n\n%s", result.Message))
        }</span> else<span class="cov0" title="0"> {
                b.sendMessage(msg.Chat.ID, fmt.Sprintf("❌ Ошибка поиска в Notion: %s", result.Message))
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package telegram

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "strings"
        "time"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

        "ai-chatter/internal/llm"
        "ai-chatter/internal/storage"
)

// moved types live in bot.go currently; keep helpers here only if not duplicated
type llmJSON struct {
        Title             string `json:"title"`
        Answer            string `json:"answer"`
        CompressedContext string `json:"compressed_context"`
        Status            string `json:"status"`
}

type llmJSONFlexible struct {
        Title             string          `json:"title"`
        Answer            string          `json:"answer"`
        CompressedContext json.RawMessage `json:"compressed_context"`
        Status            string          `json:"status"`
}

// Checker response from model2
type checkerJSON struct {
        Status string `json:"status"`
        Msg    string `json:"msg"`
}

func parseCheckerJSON(s string) (checkerJSON, bool) <span class="cov5" title="4">{
        var c checkerJSON
        if err := json.Unmarshal([]byte(s), &amp;c); err != nil </span><span class="cov0" title="0">{
                return checkerJSON{}, false
        }</span>
        <span class="cov5" title="4">if c.Status == "ok" || c.Status == "fail" </span><span class="cov1" title="1">{
                return c, true
        }</span>
        <span class="cov4" title="3">return checkerJSON{}, false</span>
}

func buildCheckerPrompt() string <span class="cov5" title="4">{
        return "Ты — модель-проверяющий статуса другой модели в режиме составления ТЗ. " +
                "Тебе передают только два поля из ответа: 'answer' и 'status'. " +
                "'status' может быть 'continue' или 'final'. Статус 'continue' должен содержать в себе" +
                "уточняющие вопросы, статус 'final' – итоговое ТЗ. " +
                "Проверь, соответствует ли выбранный статус " +
                "здравому смыслу, исходя из информативности/конкретности сообщения (например, 'continue' " +
                "всегда должен содержать вопросы, 'final' – итоговое ТЗ). " +
                "Верни строго JSON {\"status\": \"ok|fail\", \"msg\": \"если fail — кратко что " +
                "исправить (например: 'уточнить требования'), иначе пусто\"}. Не использую какого-либо форматирования, только JSON" +
                " чистым текстом"
}</span>

func buildCheckerInput(answer, status string) string <span class="cov5" title="4">{
        return fmt.Sprintf("answer: %s\nstatus: %s", strings.TrimSpace(answer), strings.TrimSpace(status))
}</span>

func (b *Bot) runTZChecker(ctx context.Context, userID int64, lastPrimary string) (checkerJSON, llm.Response, error) <span class="cov5" title="4">{
        msgs := []llm.Message{
                {Role: "system", Content: buildCheckerPrompt()},
                {Role: "user", Content: lastPrimary},
        }
        b.logLLMRequest(userID, "tz_check", msgs)
        resp, err := b.getSecondLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                return checkerJSON{}, llm.Response{}, err
        }</span>
        <span class="cov5" title="4">b.logResponse(resp)
        cj, ok := parseCheckerJSON(resp.Content)
        // Persist checker response for audit (not used in context)
        if b.recorder != nil </span><span class="cov0" title="0">{
                f := false
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: time.Now().UTC(), UserID: userID, UserMessage: "[tz_check]", AssistantResponse: resp.Content, CanUse: &amp;f})
        }</span>
        <span class="cov5" title="4">if !ok </span><span class="cov4" title="3">{
                return checkerJSON{}, resp, fmt.Errorf("checker returned invalid schema")
        }</span>
        <span class="cov1" title="1">return cj, resp, nil</span>
}

func (b *Bot) correctPrimaryWithMsg(ctx context.Context, userID int64, original string, msg string) (llmJSON, llm.Response, error) <span class="cov1" title="1">{
        instr := "Исправь предыдущий ответ согласно замечаниям: " + msg + ". Сохрани строгую JSON-схему {title, answer, compressed_context, status}."
        // Persist correction request intent
        if b.recorder != nil </span><span class="cov0" title="0">{
                f := false
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: time.Now().UTC(), UserID: userID, UserMessage: "[tz_correct_req]", AssistantResponse: msg, CanUse: &amp;f})
        }</span>
        <span class="cov1" title="1">msgs := []llm.Message{{Role: "system", Content: instr}, {Role: "user", Content: original}}
        b.logLLMRequest(userID, "tz_correct", msgs)
        resp, err := b.getLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                return llmJSON{}, llm.Response{}, err
        }</span>
        <span class="cov1" title="1">p, ok := parseLLMJSON(resp.Content)
        if !ok </span><span class="cov0" title="0">{
                return llmJSON{}, resp, fmt.Errorf("primary returned invalid JSON on correction")
        }</span>
        <span class="cov1" title="1">return p, resp, nil</span>
}

func compactJSON(raw json.RawMessage) (string, bool) <span class="cov0" title="0">{
        if len(raw) == 0 || string(raw) == "null" </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">var s string
        if err := json.Unmarshal(raw, &amp;s); err == nil </span><span class="cov0" title="0">{
                return s, true
        }</span>
        <span class="cov0" title="0">var anyJson interface{}
        if err := json.Unmarshal(raw, &amp;anyJson); err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">b, err := json.Marshal(anyJson)
        if err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">return string(b), true</span>
}

func parseLLMJSON(s string) (llmJSON, bool) <span class="cov9" title="13">{
        var v llmJSON
        if err := json.Unmarshal([]byte(s), &amp;v); err == nil </span><span class="cov9" title="13">{
                if v.Title != "" || v.Answer != "" || v.CompressedContext != "" || v.Status != "" </span><span class="cov9" title="13">{
                        return v, true
                }</span>
        }
        <span class="cov0" title="0">var f llmJSONFlexible
        if err := json.Unmarshal([]byte(s), &amp;f); err != nil </span><span class="cov0" title="0">{
                return llmJSON{}, false
        }</span>
        <span class="cov0" title="0">cc, _ := compactJSON(f.CompressedContext)
        return llmJSON{Title: f.Title, Answer: f.Answer, CompressedContext: cc, Status: f.Status}, true</span>
}

// Auto-numbering for questions in TZ mode when status=continue
func isNumberedLine(s string) bool <span class="cov3" title="2">{
        ss := strings.TrimSpace(s)
        if ss == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        // scan leading digits
        <span class="cov3" title="2">i := 0
        for i &lt; len(ss) &amp;&amp; ss[i] &gt;= '0' &amp;&amp; ss[i] &lt;= '9' </span><span class="cov3" title="2">{
                i++
        }</span>
        <span class="cov3" title="2">if i == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="2">if i &lt; len(ss) &amp;&amp; ss[i] == '.' </span><span class="cov3" title="2">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func enforceNumberedListIfNeeded(answer string) string <span class="cov3" title="2">{
        lines := strings.Split(answer, "\n")
        var content []string
        for _, ln := range lines </span><span class="cov4" title="3">{
                l := strings.TrimSpace(ln)
                if l != "" </span><span class="cov4" title="3">{
                        content = append(content, l)
                }</span>
        }
        <span class="cov3" title="2">if len(content) &lt; 2 </span><span class="cov1" title="1">{
                return answer
        }</span>
        // if already has 2+ numbered lines, keep as is
        <span class="cov1" title="1">num := 0
        for _, l := range content </span><span class="cov3" title="2">{
                if isNumberedLine(l) </span><span class="cov3" title="2">{
                        num++
                }</span>
        }
        <span class="cov1" title="1">if num &gt;= 2 </span><span class="cov1" title="1">{
                return answer
        }</span>
        // produce numbered
        <span class="cov0" title="0">var out []string
        for i, l := range content </span><span class="cov0" title="0">{
                out = append(out, fmt.Sprintf("%d. %s", i+1, l))
        }</span>
        <span class="cov0" title="0">return strings.Join(out, "\n")</span>
}

// reformatToSchema is defined in bot.go (single owner)

// buildContextWithOverflow is defined in bot.go

func (b *Bot) processLLMAndRespond(ctx context.Context, chatID int64, userID int64, resp llm.Response) <span class="cov7" title="8">{
        // log inbound
        b.logResponse(resp)

        // Обрабатываем function calls если они есть
        if len(resp.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                b.handleFunctionCalls(ctx, chatID, userID, resp.ToolCalls)
                return
        }</span>

        <span class="cov7" title="8">parsed, ok := parseLLMJSON(resp.Content)
        if !ok </span><span class="cov0" title="0">{
                if p2, ok2 := b.reformatToSchema(ctx, userID, resp.Content); ok2 </span><span class="cov0" title="0">{
                        parsed = p2
                        ok = true
                }</span>
        }

        <span class="cov7" title="8">compressed := false
        if ok &amp;&amp; strings.TrimSpace(parsed.CompressedContext) != "" </span><span class="cov1" title="1">{
                b.addUserSystemPrompt(userID, parsed.CompressedContext)
                b.history.DisableAll(userID)
                compressed = true
        }</span>
        <span class="cov7" title="8">answerToSend := resp.Content
        if ok &amp;&amp; parsed.Answer != "" </span><span class="cov7" title="8">{
                answerToSend = parsed.Answer
        }</span>
        <span class="cov7" title="8">status := ""
        if ok </span><span class="cov7" title="8">{
                status = strings.ToLower(strings.TrimSpace(parsed.Status))
        }</span>

        // Checker and possible correction: provide only title+status
        <span class="cov7" title="8">if b.isTZMode(userID) </span><span class="cov5" title="4">{
                checkerInput := buildCheckerInput(parsed.Answer, parsed.Status)
                if cj, _, err := b.runTZChecker(ctx, userID, checkerInput); err == nil </span><span class="cov1" title="1">{
                        if strings.ToLower(cj.Status) == "fail" &amp;&amp; strings.TrimSpace(cj.Msg) != "" </span><span class="cov1" title="1">{
                                if pFix, _, errFix := b.correctPrimaryWithMsg(ctx, userID, answerToSend, cj.Msg); errFix == nil </span><span class="cov1" title="1">{
                                        parsed = pFix
                                        answerToSend = pFix.Answer
                                        status = strings.ToLower(strings.TrimSpace(pFix.Status))
                                        if strings.TrimSpace(pFix.CompressedContext) != "" </span><span class="cov0" title="0">{
                                                b.addUserSystemPrompt(userID, pFix.CompressedContext)
                                                b.history.DisableAll(userID)
                                                compressed = true
                                        }</span>
                                }
                        }
                }
        }

        // Enforce numbered list for questions while clarifying TZ
        <span class="cov7" title="8">if b.isTZMode(userID) &amp;&amp; status != "final" </span><span class="cov3" title="2">{
                answerToSend = enforceNumberedListIfNeeded(answerToSend)
        }</span>

        // TZ steps control in both paths
        <span class="cov7" title="8">if b.isTZMode(userID) &amp;&amp; status != "final" </span><span class="cov3" title="2">{
                left := b.decTZRemaining(userID)
                if left &lt;= 0 </span><span class="cov1" title="1">{
                        if pFinal, respFinal, okFinal := b.produceFinalTS(ctx, userID); okFinal </span><span class="cov1" title="1">{
                                b.sendFinalTS(chatID, userID, pFinal, respFinal)
                                return
                        }</span>
                }
        }

        // Unified final handling: send via sendFinalTS and stop
        <span class="cov7" title="7">if b.isTZMode(userID) &amp;&amp; status == "final" </span><span class="cov3" title="2">{
                b.sendFinalTS(chatID, userID, parsed, resp)
                return
        }</span>

        <span class="cov6" title="5">used := !compressed
        b.history.AppendAssistantWithUsed(userID, answerToSend, used)
        if b.recorder != nil </span><span class="cov0" title="0">{
                tru := true
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: time.Now().UTC(), UserID: userID, AssistantResponse: answerToSend, CanUse: &amp;tru})
        }</span>

        <span class="cov6" title="5">metaLine := fmt.Sprintf("[model=%s, tokens: prompt=%d, completion=%d, total=%d]", resp.Model, resp.PromptTokens, resp.CompletionTokens, resp.TotalTokens)
        metaEsc := b.escapeIfNeeded(metaLine)
        body := answerToSend
        if ok &amp;&amp; parsed.Title != "" </span><span class="cov6" title="5">{
                body = b.formatTitleAnswer(parsed.Title, answerToSend)
        }</span>
        <span class="cov6" title="5">final := metaEsc + "\n\n" + body
        msgOut := tgbotapi.NewMessage(chatID, final)
        msgOut.ReplyMarkup = b.menuKeyboard()
        msgOut.ParseMode = b.parseModeValue()
        _, _ = b.s.Send(msgOut)</span>
}

func (b *Bot) sendFinalTS(chatID, userID int64, p llmJSON, resp llm.Response) <span class="cov4" title="3">{
        answerToSend := p.Answer
        if p.Title != "" </span><span class="cov4" title="3">{
                answerToSend = b.formatTitleAnswer(p.Title, p.Answer)
        }</span>
        <span class="cov4" title="3">b.history.AppendAssistantWithUsed(userID, answerToSend, true)
        if b.recorder != nil </span><span class="cov0" title="0">{
                tru := true
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: time.Now().UTC(), UserID: userID, AssistantResponse: answerToSend, CanUse: &amp;tru})
        }</span>
        <span class="cov4" title="3">metaLine := fmt.Sprintf("[model=%s, tokens: prompt=%d, completion=%d, total=%d]", resp.Model, resp.PromptTokens, resp.CompletionTokens, resp.TotalTokens)
        metaEsc := b.escapeIfNeeded(metaLine)
        pm := strings.ToLower(b.parseModeValue())
        var header string
        switch pm </span>{
        case strings.ToLower(tgbotapi.ModeHTML):<span class="cov4" title="3">
                header = "&lt;b&gt;ТЗ Готово&lt;/b&gt;"</span>
        case strings.ToLower(tgbotapi.ModeMarkdownV2):<span class="cov0" title="0">
                header = escapeMarkdownV2("ТЗ Готово")</span>
        default:<span class="cov0" title="0">
                header = "**ТЗ Готово**"</span>
        }
        <span class="cov4" title="3">final := metaEsc + "\n\n" + header + "\n\n" + answerToSend
        msgOut := tgbotapi.NewMessage(chatID, final)
        msgOut.ReplyMarkup = b.menuKeyboard()
        msgOut.ParseMode = b.parseModeValue()
        _, _ = b.s.Send(msgOut)

        log.Println("Готовим инструкцию")
        // Announce instruction preparation
        prep := tgbotapi.NewMessage(chatID, b.escapeIfNeeded("Готовлю инструкцию по итоговому ТЗ…"))
        prep.ParseMode = b.parseModeValue()
        _, _ = b.s.Send(prep)

        // Call secondary model to generate actionable instructions
        ctx := context.Background()
        instructionPrompt := buildInstructionPrompt(p)
        msgs := []llm.Message{{Role: "system", Content: instructionPrompt}}
        b.logLLMRequest(userID, "tz_instructions", msgs)
        resp2, err := b.getSecondLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("second model error: %v", err)
                errMsg := tgbotapi.NewMessage(chatID, b.escapeIfNeeded("Не удалось подготовить инструкцию. Попробуйте ещё раз."))
                errMsg.ParseMode = b.parseModeValue()
                _, _ = b.s.Send(errMsg)
                b.clearTZState(userID)
                return
        }</span>
        <span class="cov4" title="3">b.logResponse(resp2)
        // Try to parse as our JSON; if not, send as is
        if p2, ok := parseLLMJSON(resp2.Content); ok &amp;&amp; strings.TrimSpace(p2.Answer) != "" </span><span class="cov4" title="3">{
                inst := p2.Answer
                if p2.Title != "" </span><span class="cov4" title="3">{
                        inst = b.formatTitleAnswer(p2.Title, p2.Answer)
                }</span>
                <span class="cov4" title="3">msg2 := tgbotapi.NewMessage(chatID, inst)
                msg2.ParseMode = b.parseModeValue()
                msg2.ReplyMarkup = b.menuKeyboard()
                _, _ = b.s.Send(msg2)</span>
        } else<span class="cov0" title="0"> {
                msg2 := tgbotapi.NewMessage(chatID, resp2.Content)
                msg2.ParseMode = b.parseModeValue()
                msg2.ReplyMarkup = b.menuKeyboard()
                _, _ = b.s.Send(msg2)
        }</span>
        <span class="cov4" title="3">b.clearTZState(userID)</span>
}

func buildInstructionPrompt(ts llmJSON) string <span class="cov4" title="3">{
        // Keep it simple and provider-agnostic; instruction in Russian
        return "Ты получаешь итоговое техническое задание (ТЗ). На его основе составь детальную пошаговую инструкцию действий для пользователя в русском языке." +
                " Наример, если это кулинарный рецепт — выдай полный рецепт с этапами и ингредиентами;" +
                " если это разработка — выдай рекомендуемый стек, этапы работ, приоритеты и зависимости; и так далее" +
                " Будь конкретным: нумеруй шаги, пиши каждый шаг с новой строки. Не добавляй лишний контент, не обсуждай сам процесс составления ТЗ." +
                " Ответ верни в понятном человеку виде без JSON формата " +
                "\n\nИтоговое ТЗ:\n" + ts.Answer
}</span>

func (b *Bot) logResponse(resp llm.Response) <span class="cov10" title="15">{
        log.Printf("LLM response [model=%s, tokens: prompt=%d, completion=%d, total=%d]: %q", resp.Model, resp.PromptTokens, resp.CompletionTokens, resp.TotalTokens, resp.Content)
}</span>

func (b *Bot) nowUTC() time.Time <span class="cov0" title="0">{ return time.Now().UTC() }</span>

// handleFunctionCalls обрабатывает вызовы функций от LLM
func (b *Bot) handleFunctionCalls(ctx context.Context, chatID, userID int64, toolCalls []llm.ToolCall) <span class="cov0" title="0">{
        if b.mcpClient == nil </span><span class="cov0" title="0">{
                b.sendMessage(chatID, "Notion интеграция не настроена.")
                return
        }</span>

        // Собираем результаты всех tool calls
        <span class="cov0" title="0">toolResults := make([]llm.ToolCallResult, 0, len(toolCalls))

        for _, tc := range toolCalls </span><span class="cov0" title="0">{
                switch tc.Function.Name </span>{
                case "save_dialog_to_notion":<span class="cov0" title="0">
                        // Отправляем уведомление о начале операции
                        b.sendMessage(chatID, "💾 Сохраняю диалог в Notion...")
                        
                        title, ok := tc.Function.Arguments["title"].(string)
                        if !ok || title == "" </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "Ошибка: не указано название страницы",
                                })
                                continue</span>
                        }

                        // Собираем контекст диалога
                        <span class="cov0" title="0">history := b.history.Get(userID)
                        if len(history) == 0 </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "Ошибка: история диалога пуста",
                                })
                                continue</span>
                        }

                        // Формируем содержимое страницы
                        <span class="cov0" title="0">var content strings.Builder
                        for _, msg := range history </span><span class="cov0" title="0">{
                                if msg.Role == "user" </span><span class="cov0" title="0">{
                                        content.WriteString(fmt.Sprintf("**Пользователь:** %s\n\n", msg.Content))
                                }</span> else<span class="cov0" title="0"> if msg.Role == "assistant" </span><span class="cov0" title="0">{
                                        content.WriteString(fmt.Sprintf("**Ассистент:** %s\n\n", msg.Content))
                                }</span>
                        }

                        // Проверяем настройку parent page
                        <span class="cov0" title="0">if b.notionParentPage == "" </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "Ошибка: не настроен NOTION_PARENT_PAGE_ID",
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">result := b.mcpClient.CreateDialogSummary(
                                ctx, title, content.String(),
                                fmt.Sprintf("%d", userID),
                                getUsernameFromID(userID),
                                "dialog_summary",
                                b.notionParentPage,
                        )

                        if result.Success </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("Диалог успешно сохранён в Notion под названием '%s'. Page ID: %s", title, result.PageID),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("Ошибка сохранения: %s", result.Message),
                                })
                        }</span>

                case "search_notion":<span class="cov0" title="0">
                        // Отправляем уведомление о начале поиска
                        b.sendMessage(chatID, "🔍 Ищу в Notion...")
                        
                        query, ok := tc.Function.Arguments["query"].(string)
                        if !ok || query == "" </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "Ошибка: не указан поисковый запрос",
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">result := b.mcpClient.SearchDialogSummaries(
                                ctx, query,
                                fmt.Sprintf("%d", userID),
                                "dialog_summary",
                        )

                        if result.Success </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("Результаты поиска по запросу '%s': %s", query, result.Message),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("Ошибка поиска: %s", result.Message),
                                })
                        }</span>

                case "create_notion_page":<span class="cov0" title="0">
                        // Отправляем уведомление о начале создания
                        b.sendMessage(chatID, "📝 Создаю страницу в Notion...")
                        
                        title, ok := tc.Function.Arguments["title"].(string)
                        if !ok || title == "" </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "Ошибка: не указано название страницы",
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">content, ok := tc.Function.Arguments["content"].(string)
                        if !ok || content == "" </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "Ошибка: не указано содержимое страницы",
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">parentPage, _ := tc.Function.Arguments["parent_page"].(string)

                        // Если не указан parent_page, используем default
                        if parentPage == "" </span><span class="cov0" title="0">{
                                if b.notionParentPage == "" </span><span class="cov0" title="0">{
                                        toolResults = append(toolResults, llm.ToolCallResult{
                                                ToolCallID: tc.ID,
                                                Content:    "Ошибка: не настроен NOTION_PARENT_PAGE_ID",
                                        })
                                        continue</span>
                                }
                                <span class="cov0" title="0">parentPage = b.notionParentPage</span>
                        }

                        <span class="cov0" title="0">result := b.mcpClient.CreateFreeFormPage(ctx, title, content, parentPage, nil)

                        if result.Success </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("Страница '%s' успешно создана в Notion. Page ID: %s", title, result.PageID),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("Ошибка создания страницы: %s", result.Message),
                                })
                        }</span>

                default:<span class="cov0" title="0">
                        toolResults = append(toolResults, llm.ToolCallResult{
                                ToolCallID: tc.ID,
                                Content:    fmt.Sprintf("Неизвестная функция: %s", tc.Function.Name),
                        })
                        log.Printf("Unknown function call: %s", tc.Function.Name)</span>
                }
        }

        // Теперь отправляем результаты обратно в LLM для формирования ответа
        <span class="cov0" title="0">if len(toolResults) &gt; 0 </span><span class="cov0" title="0">{
                b.continueConversationWithToolResults(ctx, chatID, userID, toolResults)
        }</span>
}

// continueConversationWithToolResults продолжает диалог с результатами tool calls
func (b *Bot) continueConversationWithToolResults(ctx context.Context, chatID, userID int64, toolResults []llm.ToolCallResult) <span class="cov0" title="0">{
        // Получаем текущий контекст
        contextMsgs := b.buildContextWithOverflow(ctx, userID)
        
        // Добавляем результаты tool calls
        for _, result := range toolResults </span><span class="cov0" title="0">{
                contextMsgs = append(contextMsgs, llm.Message{
                        Role:       "tool",
                        Content:    result.Content,
                        ToolCallID: result.ToolCallID,
                })
        }</span>

        // Добавляем инструкцию для LLM
        <span class="cov0" title="0">contextMsgs = append(contextMsgs, llm.Message{
                Role: "system", 
                Content: "Проанализируй результаты выполненных действий и сформулируй краткий ответ пользователю. Сообщи о статусе выполнения, но не дублируй всю техническую информацию.",
        })

        b.logLLMRequest(userID, "tool_response", contextMsgs)

        // Получаем ответ от LLM
        resp, err := b.getLLMClient().Generate(ctx, contextMsgs)
        if err != nil </span><span class="cov0" title="0">{
                b.sendMessage(chatID, "Действия выполнены, но произошла ошибка формирования ответа.")
                return
        }</span>

        // Обрабатываем ответ как обычно
        <span class="cov0" title="0">b.processLLMAndRespond(ctx, chatID, userID, resp)</span>
}

// getUsernameFromID возвращает имя пользователя по ID (упрощённая версия)
func getUsernameFromID(userID int64) string <span class="cov0" title="0">{
        return fmt.Sprintf("user_%d", userID)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

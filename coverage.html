
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bot: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">ai-chatter/cmd/bot/main.go (0.0%)</option>
				
				<option value="file1">ai-chatter/cmd/notion-mcp-server/main.go (0.0%)</option>
				
				<option value="file2">ai-chatter/cmd/test-custom-mcp/main.go (0.0%)</option>
				
				<option value="file3">ai-chatter/internal/auth/auth.go (91.7%)</option>
				
				<option value="file4">ai-chatter/internal/auth/file_repo.go (0.0%)</option>
				
				<option value="file5">ai-chatter/internal/config/config.go (0.0%)</option>
				
				<option value="file6">ai-chatter/internal/history/history.go (60.6%)</option>
				
				<option value="file7">ai-chatter/internal/llm/factory.go (0.0%)</option>
				
				<option value="file8">ai-chatter/internal/llm/openai.go (0.0%)</option>
				
				<option value="file9">ai-chatter/internal/llm/tools.go (0.0%)</option>
				
				<option value="file10">ai-chatter/internal/llm/yandex.go (0.0%)</option>
				
				<option value="file11">ai-chatter/internal/notion/mcp.go (0.0%)</option>
				
				<option value="file12">ai-chatter/internal/pending/file_repo.go (82.3%)</option>
				
				<option value="file13">ai-chatter/internal/storage/file.go (45.3%)</option>
				
				<option value="file14">ai-chatter/internal/telegram/api.go (0.0%)</option>
				
				<option value="file15">ai-chatter/internal/telegram/bot.go (43.0%)</option>
				
				<option value="file16">ai-chatter/internal/telegram/handlers.go (22.0%)</option>
				
				<option value="file17">ai-chatter/internal/telegram/process.go (51.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log"
        "os"
        "strings"

        "github.com/joho/godotenv"

        "ai-chatter/internal/auth"
        "ai-chatter/internal/config"
        "ai-chatter/internal/llm"
        "ai-chatter/internal/notion"
        "ai-chatter/internal/pending"
        "ai-chatter/internal/storage"
        "ai-chatter/internal/telegram"
)

func main() <span class="cov0" title="0">{
        // Try several common locations for .env
        if err := godotenv.Load(".env" /*, "../.env", "cmd/bot/.env"*/); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: .env file not found: %v", err)
        }</span>

        <span class="cov0" title="0">cfg := config.New()

        var allowRepo auth.Repository
        if cfg.AllowlistFilePath != "" </span><span class="cov0" title="0">{
                repo, err := auth.NewFileRepository(cfg.AllowlistFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to init allowlist repo: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        allowRepo = repo
                }</span>
        }

        <span class="cov0" title="0">authSvc, err := auth.NewWithRepo(allowRepo, cfg.AllowedUsers)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to init auth: %v", err)
        }</span>

        // Resolve provider/model with overrides
        <span class="cov0" title="0">prov := string(cfg.LLMProvider)
        if s := readTrim(cfg.ProviderFilePath); s != "" </span><span class="cov0" title="0">{
                prov = s
        }</span>
        <span class="cov0" title="0">model := cfg.OpenAIModel
        if s := readTrim(cfg.ModelFilePath); s != "" </span><span class="cov0" title="0">{
                model = s
        }</span>

        <span class="cov0" title="0">llmFactory := llm.NewFactory(cfg)
        llmClient, err := llmFactory.CreateClient(prov, model)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to create llm client: %v", err)
        }</span>

        <span class="cov0" title="0">systemPrompt := readSystemPrompt(cfg.SystemPromptPath)

        var rec storage.Recorder
        if cfg.LogFilePath != "" </span><span class="cov0" title="0">{
                fr, err := storage.NewFileRecorder(cfg.LogFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to init file recorder: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        rec = fr
                }</span>
        }

        <span class="cov0" title="0">var pRepo pending.Repository
        if cfg.PendingFilePath != "" </span><span class="cov0" title="0">{
                pr, err := pending.NewFileRepository(cfg.PendingFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to init pending repo: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        pRepo = pr
                }</span>
        }

        // Initialize Notion MCP client
        <span class="cov0" title="0">var mcpClient *notion.MCPClient
        if cfg.NotionToken != "" </span><span class="cov0" title="0">{
                mcpClient = notion.NewMCPClient(cfg.NotionToken)

                // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ MCP —Å–µ—Ä–≤–µ—Ä—É
                ctx := context.Background()
                if err := mcpClient.Connect(ctx, cfg.NotionToken); err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è Failed to connect to Notion MCP server: %v", err)
                        log.Printf("Notion functionality will be disabled")
                        mcpClient = nil
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("‚úÖ Notion MCP client connected successfully")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("NOTION_TOKEN not set, Notion functionality disabled")
        }</span>

        <span class="cov0" title="0">bot, err := telegram.New(
                cfg.TelegramBotToken,
                authSvc,
                llmClient,
                llmFactory,
                systemPrompt,
                rec,
                cfg.AdminUserID,
                pRepo,
                cfg.MessageParseMode,
                prov,
                model,
                mcpClient,
                cfg.NotionParentPage,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to create bot: %v", err)
        }</span>

        <span class="cov0" title="0">bot.Start(context.Background())</span>
}

func readSystemPrompt(path string) string <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("system prompt file not found or unreadable at %s: %v", path, err)
                return ""
        }</span>
        <span class="cov0" title="0">return string(data)</span>
}

func readTrim(path string) string <span class="cov0" title="0">{
        b, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(b))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "time"

        "github.com/joho/godotenv"
        "github.com/modelcontextprotocol/go-sdk/mcp"
)

// CreatePageParams –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã –≤ Notion
type CreatePageParams struct {
        Title        string                 `json:"title" mcp:"the title of the page to create"`
        Content      string                 `json:"content" mcp:"the content of the page in markdown format"`
        Properties   map[string]interface{} `json:"properties,omitempty" mcp:"page properties (Type, User, etc.)"`
        ParentPageID string                 `json:"parent_page_id" mcp:"parent page ID (required - get from Notion workspace)"`
}

// SaveDialogParams –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∏–∞–ª–æ–≥–∞
type SaveDialogParams struct {
        Title        string `json:"title" mcp:"the title for the dialog summary"`
        Content      string `json:"content" mcp:"the dialog content to save"`
        UserID       string `json:"user_id" mcp:"ID of the user"`
        Username     string `json:"username" mcp:"username of the user"`
        DialogType   string `json:"dialog_type,omitempty" mcp:"Type of dialog (e.g., 'support', 'chat')"`
        ParentPageID string `json:"parent_page_id" mcp:"parent page ID (required - get from Notion workspace)"`
}

// SearchParams –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ Notion
type SearchParams struct {
        Query    string                 `json:"query" mcp:"search query to find pages"`
        Filter   map[string]interface{} `json:"filter,omitempty" mcp:"optional filter for search"`
        PageSize int                    `json:"page_size,omitempty" mcp:"number of results to return (default: 20)"`
}

// NotionMCPServer –∫–∞—Å—Ç–æ–º–Ω—ã–π MCP —Å–µ—Ä–≤–µ—Ä –¥–ª—è Notion
type NotionMCPServer struct {
        notionClient *NotionAPIClient
}

// NotionAPIClient –∫–ª–∏–µ–Ω—Ç –¥–ª—è –ø—Ä—è–º–æ–π —Ä–∞–±–æ—Ç—ã —Å Notion REST API
type NotionAPIClient struct {
        token      string
        baseURL    string
        apiVersion string
        httpClient *http.Client
}

// NewNotionAPIClient —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç Notion API
func NewNotionAPIClient(token string) *NotionAPIClient <span class="cov0" title="0">{
        return &amp;NotionAPIClient{
                token:      token,
                baseURL:    "https://api.notion.com/v1",
                apiVersion: "2022-06-28",
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
        }
}</span>

// doNotionRequest –≤—ã–ø–æ–ª–Ω—è–µ—Ç HTTP –∑–∞–ø—Ä–æ—Å –∫ Notion API
func (c *NotionAPIClient) doNotionRequest(ctx context.Context, method, endpoint string, body interface{}) ([]byte, error) <span class="cov0" title="0">{
        var reqBody io.Reader
        if body != nil </span><span class="cov0" title="0">{
                bodyBytes, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov0" title="0">reqBody = bytes.NewReader(bodyBytes)</span>
        }

        <span class="cov0" title="0">url := c.baseURL + endpoint
        req, err := http.NewRequestWithContext(ctx, method, url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+c.token)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Notion-Version", c.apiVersion)

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Notion API error %d: %s", resp.StatusCode, string(respBody))
        }</span>

        <span class="cov0" title="0">return respBody, nil</span>
}

// createPage —Å–æ–∑–¥–∞–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤ Notion
func (c *NotionAPIClient) createPage(ctx context.Context, title, content, parentPageID string, properties map[string]interface{}) (string, error) <span class="cov0" title="0">{
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å–æ–≥–ª–∞—Å–Ω–æ Notion API
        pageData := map[string]interface{}{
                "parent": map[string]interface{}{
                        "type":    "page_id",
                        "page_id": parentPageID,
                },
                "properties": map[string]interface{}{
                        "title": map[string]interface{}{
                                "title": []map[string]interface{}{
                                        {
                                                "text": map[string]interface{}{
                                                        "content": title,
                                                },
                                        },
                                },
                        },
                },
                "children": []map[string]interface{}{
                        {
                                "object": "block",
                                "type":   "paragraph",
                                "paragraph": map[string]interface{}{
                                        "rich_text": []map[string]interface{}{
                                                {
                                                        "type": "text",
                                                        "text": map[string]interface{}{
                                                                "content": content,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }

        respBody, err := c.doNotionRequest(ctx, "POST", "/pages", pageData)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(respBody, &amp;result); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">if id, ok := result["id"].(string); ok </span><span class="cov0" title="0">{
                return id, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("no page ID in response")</span>
}

// searchPages –∏—â–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã –≤ Notion
func (c *NotionAPIClient) searchPages(ctx context.Context, query string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        searchData := map[string]interface{}{
                "query":     query,
                "page_size": 20,
        }

        respBody, err := c.doNotionRequest(ctx, "POST", "/search", searchData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(respBody, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">if results, ok := result["results"].([]interface{}); ok </span><span class="cov0" title="0">{
                var pages []map[string]interface{}
                for _, r := range results </span><span class="cov0" title="0">{
                        if page, ok := r.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                pages = append(pages, page)
                        }</span>
                }
                <span class="cov0" title="0">return pages, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no results in response")</span>
}

// NewNotionMCPServer —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π MCP —Å–µ—Ä–≤–µ—Ä –¥–ª—è Notion
func NewNotionMCPServer(notionToken string) *NotionMCPServer <span class="cov0" title="0">{
        return &amp;NotionMCPServer{
                notionClient: NewNotionAPIClient(notionToken),
        }
}</span>

// CreatePage —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤ Notion —á–µ—Ä–µ–∑ MCP
func (s *NotionMCPServer) CreatePage(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[CreatePageParams]) (*mcp.CallToolResultFor[any], error) <span class="cov0" title="0">{
        args := params.Arguments

        log.Printf("üìù MCP Server: Creating Notion page '%s' in parent %s", args.Title, args.ParentPageID)

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π parent_page_id
        if args.ParentPageID == "" </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResultFor[any]{
                        IsError: true,
                        Content: []mcp.Content{
                                &amp;mcp.TextContent{Text: "‚ùå parent_page_id is required - get it from your Notion workspace"},
                        },
                }, nil
        }</span>

        // –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É —á–µ—Ä–µ–∑ –ø—Ä—è–º–æ–π API –≤—ã–∑–æ–≤
        <span class="cov0" title="0">pageID, err := s.notionClient.createPage(ctx, args.Title, args.Content, args.ParentPageID, args.Properties)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResultFor[any]{
                        IsError: true,
                        Content: []mcp.Content{
                                &amp;mcp.TextContent{Text: fmt.Sprintf("‚ùå Failed to create page: %v", err)},
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[any]{
                Content: []mcp.Content{
                        &amp;mcp.TextContent{Text: fmt.Sprintf("‚úÖ Successfully created page '%s' in Notion", args.Title)},
                },
                Meta: map[string]interface{}{
                        "page_id": pageID,
                        "title":   args.Title,
                        "success": true,
                },
        }, nil</span>
}

// SearchPages –∏—â–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã –≤ Notion —á–µ—Ä–µ–∑ MCP
func (s *NotionMCPServer) SearchPages(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[SearchParams]) (*mcp.CallToolResultFor[any], error) <span class="cov0" title="0">{
        args := params.Arguments

        log.Printf("üîç MCP Server: Searching Notion for '%s'", args.Query)

        // –ò—â–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—ã —á–µ—Ä–µ–∑ –ø—Ä—è–º–æ–π API –≤—ã–∑–æ–≤
        pages, err := s.notionClient.searchPages(ctx, args.Query)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResultFor[any]{
                        IsError: true,
                        Content: []mcp.Content{
                                &amp;mcp.TextContent{Text: fmt.Sprintf("‚ùå Search failed: %v", err)},
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">resultMessage := fmt.Sprintf("‚úÖ Found %d pages for query '%s'", len(pages), args.Query)
        for i, page := range pages </span><span class="cov0" title="0">{
                if i &gt;= 5 </span><span class="cov0" title="0">{ // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 5 —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                        break</span>
                }
                <span class="cov0" title="0">if title, ok := page["properties"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if titleProp, ok := title["title"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if titleArray, ok := titleProp["title"].([]interface{}); ok &amp;&amp; len(titleArray) &gt; 0 </span><span class="cov0" title="0">{
                                        if titleText, ok := titleArray[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if text, ok := titleText["text"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                        if content, ok := text["content"].(string); ok </span><span class="cov0" title="0">{
                                                                resultMessage += fmt.Sprintf("\n- %s", content)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[any]{
                Content: []mcp.Content{
                        &amp;mcp.TextContent{Text: resultMessage},
                },
                Meta: map[string]interface{}{
                        "query":      args.Query,
                        "page_count": len(pages),
                        "success":    true,
                },
        }, nil</span>
}

// SaveDialog —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–∏–∞–ª–æ–≥ –≤ Notion —á–µ—Ä–µ–∑ MCP
func (s *NotionMCPServer) SaveDialog(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[SaveDialogParams]) (*mcp.CallToolResultFor[any], error) <span class="cov0" title="0">{
        args := params.Arguments

        log.Printf("üíæ MCP Server: Saving dialog '%s' for user %s in parent %s", args.Title, args.Username, args.ParentPageID)

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π parent_page_id
        if args.ParentPageID == "" </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResultFor[any]{
                        IsError: true,
                        Content: []mcp.Content{
                                &amp;mcp.TextContent{Text: "‚ùå parent_page_id is required for saving dialogs - get it from your Notion workspace"},
                        },
                }, nil
        }</span>

        // –§–æ—Ä–º–∏—Ä—É–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –¥–∏–∞–ª–æ–≥–∞
        <span class="cov0" title="0">dialogContent := fmt.Sprintf("# %s\n\n**User:** %s\n**Type:** %s\n**Date:** %s\n\n## Content\n\n%s",
                args.Title, args.Username, args.DialogType, time.Now().Format("2006-01-02 15:04:05"), args.Content)

        // –°–æ–∑–¥–∞–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        properties := map[string]interface{}{
                "Type":       "Dialog",
                "User":       args.Username,
                "UserID":     args.UserID,
                "DialogType": args.DialogType,
                "Created":    time.Now().Format("2006-01-02"),
        }

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∏–∞–ª–æ–≥ –∫–∞–∫ —Å—Ç—Ä–∞–Ω–∏—Ü—É
        pageID, err := s.notionClient.createPage(ctx, args.Title, dialogContent, args.ParentPageID, properties)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResultFor[any]{
                        IsError: true,
                        Content: []mcp.Content{
                                &amp;mcp.TextContent{Text: fmt.Sprintf("‚ùå Failed to save dialog: %v", err)},
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[any]{
                Content: []mcp.Content{
                        &amp;mcp.TextContent{Text: fmt.Sprintf("‚úÖ Dialog '%s' saved to Notion", args.Title)},
                },
                Meta: map[string]interface{}{
                        "page_id":     pageID,
                        "title":       args.Title,
                        "user":        args.Username,
                        "dialog_type": args.DialogType,
                        "success":     true,
                },
        }, nil</span>
}

// getProperty –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Å–≤–æ–π—Å—Ç–≤–æ –∏–∑ –∫–∞—Ä—Ç—ã —Å fallback –∑–Ω–∞—á–µ–Ω–∏–µ–º
func getProperty(props map[string]interface{}, key, defaultValue string) string <span class="cov0" title="0">{
        if props == nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">if val, ok := props[key].(string); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func main() <span class="cov0" title="0">{
        if err := godotenv.Load(".env" /*, "../.env", "cmd/bot/.env"*/); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: .env file not found: %v", err)
        }</span>
        // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω Notion –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è
        <span class="cov0" title="0">notionToken := os.Getenv("NOTION_TOKEN")
        if notionToken == "" </span><span class="cov0" title="0">{
                log.Fatal("‚ùå NOTION_TOKEN environment variable is required")
        }</span>

        <span class="cov0" title="0">log.Printf("üöÄ Starting Custom Notion MCP Server")
        log.Printf("üîë Using Notion token: %s...%s", notionToken[:10], notionToken[len(notionToken)-5:])

        // –°–æ–∑–¥–∞–µ–º MCP —Å–µ—Ä–≤–µ—Ä
        server := mcp.NewServer(&amp;mcp.Implementation{
                Name:    "ai-chatter-notion-mcp",
                Version: "1.0.0",
        }, nil)

        // –°–æ–∑–¥–∞–µ–º –Ω–∞—à Notion —Å–µ—Ä–≤–µ—Ä
        notionServer := NewNotionMCPServer(notionToken)

        // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
        mcp.AddTool(server, &amp;mcp.Tool{
                Name:        "create_page",
                Description: "Creates a new page in Notion with the specified title and content",
        }, notionServer.CreatePage)

        mcp.AddTool(server, &amp;mcp.Tool{
                Name:        "search_pages",
                Description: "Searches for pages in Notion workspace",
        }, notionServer.SearchPages)

        mcp.AddTool(server, &amp;mcp.Tool{
                Name:        "save_dialog_to_notion",
                Description: "Saves a dialog conversation to Notion as a summary page",
        }, notionServer.SaveDialog)

        log.Printf("üìã Registered %d tools: create_page, search_pages, save_dialog_to_notion", 3)
        log.Printf("üîó Starting server on stdin/stdout...")

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–µ—Ä —á–µ—Ä–µ–∑ stdin/stdout
        transport := mcp.NewStdioTransport()
        if err := server.Run(context.Background(), transport); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Server failed: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"

        "ai-chatter/internal/notion"

        "github.com/joho/godotenv"
)

func main() <span class="cov0" title="0">{
        if err := godotenv.Load(".env" /*, "../.env", "cmd/bot/.env"*/); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: .env file not found: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("üß™ Testing Custom Notion MCP Server")
        fmt.Println("===================================")

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ç–æ–∫–µ–Ω–∞
        notionToken := os.Getenv("NOTION_TOKEN")
        if notionToken == "" </span><span class="cov0" title="0">{
                fmt.Println("‚ùå NOTION_TOKEN environment variable is required")
                fmt.Println("üí° Please set it with your Notion integration token:")
                fmt.Println("   export NOTION_TOKEN=secret_xxxxx")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ NOTION_TOKEN is set: %s...%s\n", notionToken[:10], notionToken[len(notionToken)-5:])

        // –°–æ–∑–¥–∞–µ–º MCP –∫–ª–∏–µ–Ω—Ç
        mcpClient := notion.NewMCPClient(notionToken)

        ctx := context.Background()

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∫–∞—Å—Ç–æ–º–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É
        fmt.Println("\nüîó Connecting to custom MCP server...")
        fmt.Println("üí° Make sure the server binary is built:")
        fmt.Println("   go build -o notion-mcp-server cmd/notion-mcp-server/main.go")
        fmt.Println("")

        err := mcpClient.Connect(ctx, notionToken)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Connection failed: %v\n", err)
                fmt.Println("\nüí° Please ensure:")
                fmt.Println("   1. MCP server is built: go build -o notion-mcp-server cmd/notion-mcp-server/main.go")
                fmt.Println("   2. NOTION_TOKEN is valid")
                fmt.Println("   3. Notion integration has access to pages")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Connected successfully!")

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∏–∞–ª–æ–≥–∞
        fmt.Println("\nüíæ Testing dialog saving...")

        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–µ–π–∫–æ–≤—ã–π parent page ID –¥–ª—è —Ç–µ—Å—Ç–∞ (–≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–µ–Ω –Ω–∞—Å—Ç–æ—è—â–∏–π)
        testPageID := os.Getenv("NOTION_TEST_PAGE_ID")

        dialogResult := mcpClient.CreateDialogSummary(
                ctx,
                "Test Dialog from Custom MCP",
                "This is a test dialog created through our custom MCP server.",
                "test_user_123",
                "TestUser",
                "test",
                testPageID,
        )

        if !dialogResult.Success </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Dialog save failed: %s\n", dialogResult.Message)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("‚úÖ Dialog saved: %s\n", dialogResult.Message)
                if dialogResult.PageID != "" </span><span class="cov0" title="0">{
                        fmt.Printf("üìÑ Page ID: %s\n", dialogResult.PageID)
                }</span>
        }

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        <span class="cov0" title="0">fmt.Println("\nüìÑ Testing free-form page creation...")

        pageResult := mcpClient.CreateFreeFormPage(
                ctx,
                "Custom MCP Test Page",
                "# Custom MCP Integration Test\n\nThis page was created using our custom Notion MCP server built with Go and the official MCP SDK.\n\n## Features\n- Direct Notion API integration\n- MCP protocol compliance\n- Go-based implementation\n- Official SDK usage",
                testPageID,
                []string{"test", "mcp", "custom"},
        )

        if !pageResult.Success </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Page creation failed: %s\n", pageResult.Message)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("‚úÖ Page created: %s\n", pageResult.Message)
                if pageResult.PageID != "" </span><span class="cov0" title="0">{
                        fmt.Printf("üìÑ Page ID: %s\n", pageResult.PageID)
                }</span>
        }

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–∏—Å–∫
        <span class="cov0" title="0">fmt.Println("\nüîç Testing search functionality...")

        searchResult := mcpClient.SearchDialogSummaries(ctx, "AI", "", "")

        if !searchResult.Success </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Search failed: %s\n", searchResult.Message)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("‚úÖ Search completed: %s\n", searchResult.Message)
        }</span>

        // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        <span class="cov0" title="0">mcpClient.Close()

        fmt.Println("\nüéâ Custom MCP Server integration test completed!")
        fmt.Println("üèóÔ∏è Custom MCP server is working correctly")
        fmt.Println("üìã Benefits of custom approach:")
        fmt.Println("   ‚úÖ Full control over MCP implementation")
        fmt.Println("   ‚úÖ Direct Notion API access")
        fmt.Println("   ‚úÖ Official MCP SDK compliance")
        fmt.Println("   ‚úÖ Go-based end-to-end solution")
        fmt.Println("   ‚úÖ Easy debugging and customization")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

type User struct {
        ID        int64  `json:"id"`
        Username  string `json:"username"`
        FirstName string `json:"first_name"`
        LastName  string `json:"last_name"`
}

type Repository interface {
        LoadAll() ([]User, error)
        Upsert(user User) error
        Remove(userID int64) error
}

type Service struct {
        repo         Repository
        allowedUsers map[int64]User
}

func NewWithRepo(repo Repository, initial []int64) (*Service, error) <span class="cov1" title="1">{
        s := &amp;Service{repo: repo, allowedUsers: make(map[int64]User)}
        // preload from repo
        if repo != nil </span><span class="cov1" title="1">{
                users, err := repo.LoadAll()
                if err == nil </span><span class="cov1" title="1">{
                        for _, u := range users </span><span class="cov1" title="1">{
                                s.allowedUsers[u.ID] = u
                        }</span>
                }
        }
        // merge initial IDs (from env) without usernames
        <span class="cov1" title="1">for _, id := range initial </span><span class="cov1" title="1">{
                if _, ok := s.allowedUsers[id]; !ok </span><span class="cov1" title="1">{
                        s.allowedUsers[id] = User{ID: id}
                }</span>
        }
        <span class="cov1" title="1">return s, nil</span>
}

func (s *Service) IsAllowed(userID int64) bool <span class="cov10" title="5">{
        _, ok := s.allowedUsers[userID]
        return ok
}</span>

func (s *Service) Upsert(user User) error <span class="cov1" title="1">{
        s.allowedUsers[user.ID] = user
        if s.repo != nil </span><span class="cov1" title="1">{
                return s.repo.Upsert(user)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Service) Remove(userID int64) error <span class="cov1" title="1">{
        delete(s.allowedUsers, userID)
        if s.repo != nil </span><span class="cov1" title="1">{
                return s.repo.Remove(userID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Service) List() []User <span class="cov1" title="1">{
        out := make([]User, 0, len(s.allowedUsers))
        for _, u := range s.allowedUsers </span><span class="cov4" title="2">{
                out = append(out, u)
        }</span>
        <span class="cov1" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
)

type FileRepository struct {
        path string
        mu   sync.Mutex
}

func NewFileRepository(path string) (*FileRepository, error) <span class="cov0" title="0">{
        if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ensure dir: %w", err)
        }</span>
        // Touch file if not exists
        <span class="cov0" title="0">f, err := os.OpenFile(path, os.O_CREATE, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("touch file: %w", err)
        }</span>
        <span class="cov0" title="0">_ = f.Close()
        return &amp;FileRepository{path: path}, nil</span>
}

func (r *FileRepository) LoadAll() ([]User, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open: %w", err)
        }</span>
        <span class="cov0" title="0">defer func(f *os.File) </span><span class="cov0" title="0">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov0" title="0">var users []User
        dec := json.NewDecoder(f)
        if err := dec.Decode(&amp;users); err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return []User{}, nil
                }</span>
                // empty or malformed -&gt; start fresh
                <span class="cov0" title="0">return []User{}, nil</span>
        }
        <span class="cov0" title="0">return users, nil</span>
}

func (r *FileRepository) Upsert(user User) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        users, _ := r.loadUnlocked()
        updated := false
        for i, u := range users </span><span class="cov0" title="0">{
                if u.ID == user.ID </span><span class="cov0" title="0">{
                        users[i] = user
                        updated = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !updated </span><span class="cov0" title="0">{
                users = append(users, user)
        }</span>
        <span class="cov0" title="0">return r.saveUnlocked(users)</span>
}

func (r *FileRepository) Remove(userID int64) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        users, _ := r.loadUnlocked()
        var out []User
        for _, u := range users </span><span class="cov0" title="0">{
                if u.ID != userID </span><span class="cov0" title="0">{
                        out = append(out, u)
                }</span>
        }
        <span class="cov0" title="0">return r.saveUnlocked(out)</span>
}

func (r *FileRepository) loadUnlocked() ([]User, error) <span class="cov0" title="0">{
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func(f *os.File) </span><span class="cov0" title="0">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov0" title="0">var users []User
        dec := json.NewDecoder(f)
        if err := dec.Decode(&amp;users); err != nil </span><span class="cov0" title="0">{
                return []User{}, nil
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

func (r *FileRepository) saveUnlocked(users []User) error <span class="cov0" title="0">{
        f, err := os.OpenFile(r.path, os.O_TRUNC|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(f *os.File) </span><span class="cov0" title="0">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov0" title="0">enc := json.NewEncoder(f)
        enc.SetIndent("", "  ")
        return enc.Encode(users)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "log"

        "github.com/caarlos0/env/v6"
)

type LLMProvider string

const (
        ProviderOpenAI LLMProvider = "openai"
        ProviderYandex LLMProvider = "yandex"
)

type Config struct {
        TelegramBotToken string  `env:"TELEGRAM_BOT_TOKEN,required"`
        AllowedUsers     []int64 `env:"ALLOWED_USERS" envSeparator:":"`
        AdminUserID      int64   `env:"ADMIN_USER"`

        // LLM settings
        LLMProvider      LLMProvider `env:"LLM_PROVIDER" envDefault:"openai"`
        OpenAIAPIKey     string      `env:"OPENAI_API_KEY"`
        OpenAIBaseURL    string      `env:"OPENAI_BASE_URL"`
        OpenAIModel      string      `env:"OPENAI_MODEL" envDefault:"gpt-3.5-turbo"`
        YandexOAuthToken string      `env:"YANDEX_OAUTH_TOKEN"`
        YandexFolderID   string      `env:"YANDEX_FOLDER_ID"`

        // OpenRouter (optional)
        OpenRouterReferrer string `env:"OPENROUTER_REFERRER"`
        OpenRouterTitle    string `env:"OPENROUTER_TITLE"`

        // Prompts
        SystemPromptPath string `env:"SYSTEM_PROMPT_PATH" envDefault:"prompts/system_prompt.txt"`

        // Storage
        LogFilePath       string `env:"LOG_FILE_PATH" envDefault:"logs/log.jsonl"`
        AllowlistFilePath string `env:"ALLOWLIST_FILE_PATH" envDefault:"data/allowlist.json"`
        PendingFilePath   string `env:"PENDING_FILE_PATH" envDefault:"data/pending.json"`

        // Overrides persistence
        ProviderFilePath string `env:"PROVIDER_FILE_PATH" envDefault:"data/provider.txt"`
        ModelFilePath    string `env:"MODEL_FILE_PATH" envDefault:"data/model.txt"`
        Model2FilePath   string `env:"MODEL2_FILE_PATH" envDefault:"data/model2.txt"`

        // Formatting
        MessageParseMode string `env:"MESSAGE_PARSE_MODE" envDefault:"HTML"`

        // Notion integration
        NotionToken      string `env:"NOTION_TOKEN"`
        NotionParentPage string `env:"NOTION_PARENT_PAGE_ID"`
}

func New() *Config <span class="cov0" title="0">{
        cfg := &amp;Config{}
        if err := env.Parse(cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to parse config: %v", err)
        }</span>
        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package history

import (
        "sync"

        "ai-chatter/internal/llm"
)

type entry struct {
        msg  llm.Message
        used bool
}

type Manager struct {
        mu       sync.RWMutex
        sessions map[int64][]entry
}

func NewManager() *Manager <span class="cov1" title="1">{
        return &amp;Manager{sessions: make(map[int64][]entry)}
}</span>

func (m *Manager) Reset(userID int64) <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        delete(m.sessions, userID)
}</span>

func (m *Manager) DisableAll(userID int64) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        entries := m.sessions[userID]
        for i := range entries </span><span class="cov0" title="0">{
                entries[i].used = false
        }</span>
        <span class="cov0" title="0">m.sessions[userID] = entries</span>
}

func (m *Manager) AppendUser(userID int64, content string) <span class="cov4" title="2">{
        m.AppendUserWithUsed(userID, content, true)
}</span>
func (m *Manager) AppendAssistant(userID int64, content string) <span class="cov4" title="2">{
        m.AppendAssistantWithUsed(userID, content, true)
}</span>

func (m *Manager) AppendUserWithUsed(userID int64, content string, used bool) <span class="cov4" title="2">{
        m.append(userID, llm.Message{Role: "user", Content: content}, used)
}</span>

func (m *Manager) AppendAssistantWithUsed(userID int64, content string, used bool) <span class="cov4" title="2">{
        m.append(userID, llm.Message{Role: "assistant", Content: content}, used)
}</span>

func (m *Manager) append(userID int64, msg llm.Message, used bool) <span class="cov7" title="4">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.sessions[userID] = append(m.sessions[userID], entry{msg: msg, used: used})
}</span>

// Get returns only messages that are marked as used in context (backward-compatible behavior)
func (m *Manager) Get(userID int64) []llm.Message <span class="cov7" title="5">{ return m.GetUsed(userID) }</span>

func (m *Manager) GetUsed(userID int64) []llm.Message <span class="cov7" title="5">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        es := m.sessions[userID]
        var out []llm.Message
        for _, e := range es </span><span class="cov10" title="8">{
                if e.used </span><span class="cov10" title="8">{
                        out = append(out, e.msg)
                }</span>
        }
        <span class="cov7" title="5">return out</span>
}

func (m *Manager) GetAll(userID int64) []llm.Message <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        es := m.sessions[userID]
        out := make([]llm.Message, 0, len(es))
        for _, e := range es </span><span class="cov0" title="0">{
                out = append(out, e.msg)
        }</span>
        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package llm

import (
        "fmt"
        "strings"

        "ai-chatter/internal/config"
)

const (
        ProviderOpenAI = "openai"
        ProviderYandex = "yandex"
)

var AllowedModels = map[string]bool{
        "openai/gpt-5-nano":              true,
        "openai/gpt-oss-20b:free":        true,
        "qwen/qwen3-coder":               true,
        "z-ai/glm-4.5-air:free":          true,
        "qwen/qwen3-coder:free":          true,
        "google/gemini-2.5-flash-lite":   true,
        "deepseek/deepseek-r1-0528:free": true,
}

// Factory creates LLM clients with consistent logic
type Factory struct {
        OpenaiAPIKey       string
        OpenaiBaseURL      string
        OpenRouterReferrer string
        OpenRouterTitle    string
        YandexOAuthToken   string
        YandexFolderID     string
}

func NewFactory(cfg *config.Config) *Factory <span class="cov0" title="0">{
        return &amp;Factory{
                OpenaiAPIKey:       cfg.OpenAIAPIKey,
                OpenaiBaseURL:      cfg.OpenAIBaseURL,
                OpenRouterReferrer: cfg.OpenRouterReferrer,
                OpenRouterTitle:    cfg.OpenRouterTitle,
                YandexOAuthToken:   cfg.YandexOAuthToken,
                YandexFolderID:     cfg.YandexFolderID,
        }
}</span>

func (f *Factory) CreateClient(provider, model string) (Client, error) <span class="cov0" title="0">{
        switch strings.ToLower(provider) </span>{
        case ProviderOpenAI:<span class="cov0" title="0">
                return NewOpenAI(f.OpenaiAPIKey, f.OpenaiBaseURL, model, f.OpenRouterReferrer, f.OpenRouterTitle), nil</span>
        case ProviderYandex:<span class="cov0" title="0">
                return NewYandex(f.YandexOAuthToken, f.YandexFolderID)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown llm provider: %s", provider)</span>
        }
}

func IsModelAllowed(model string) bool <span class="cov0" title="0">{
        return AllowedModels[model]
}</span>

func GetAllowedModels() []string <span class="cov0" title="0">{
        models := make([]string, 0, len(AllowedModels))
        for model := range AllowedModels </span><span class="cov0" title="0">{
                models = append(models, model)
        }</span>
        <span class="cov0" title="0">return models</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package llm

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/sashabaranov/go-openai"
)

type OpenAIClient struct {
        client *openai.Client
        model  string
}

type headerTransport struct {
        rt      http.RoundTripper
        headers http.Header
}

func (t headerTransport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        // Clone request to avoid mutating the original
        cl := req.Clone(req.Context())
        for k, vs := range t.headers </span><span class="cov0" title="0">{
                for _, v := range vs </span><span class="cov0" title="0">{
                        cl.Header.Add(k, v)
                }</span>
        }
        <span class="cov0" title="0">return t.rt.RoundTrip(cl)</span>
}

func NewOpenAI(apiKey, baseURL, model, referrer, title string) *OpenAIClient <span class="cov0" title="0">{
        config := openai.DefaultConfig(apiKey)
        if baseURL != "" </span><span class="cov0" title="0">{
                config.BaseURL = baseURL
        }</span>
        // Inject optional headers (useful for OpenRouter)
        <span class="cov0" title="0">if referrer != "" || title != "" </span><span class="cov0" title="0">{
                h := http.Header{}
                if referrer != "" </span><span class="cov0" title="0">{
                        h.Set("HTTP-Referer", referrer)
                }</span>
                <span class="cov0" title="0">if title != "" </span><span class="cov0" title="0">{
                        h.Set("X-Title", title)
                }</span>
                <span class="cov0" title="0">base := http.DefaultTransport
                config.HTTPClient = &amp;http.Client{Transport: headerTransport{rt: base, headers: h}}</span>
        }
        <span class="cov0" title="0">return &amp;OpenAIClient{
                client: openai.NewClientWithConfig(config),
                model:  model,
        }</span>
}

func (c *OpenAIClient) Generate(ctx context.Context, messages []Message) (Response, error) <span class="cov0" title="0">{
        return c.GenerateWithTools(ctx, messages, nil)
}</span>

func (c *OpenAIClient) GenerateWithTools(ctx context.Context, messages []Message, tools []Tool) (Response, error) <span class="cov0" title="0">{
        var oaMsgs []openai.ChatCompletionMessage
        for _, m := range messages </span><span class="cov0" title="0">{
                msg := openai.ChatCompletionMessage{Role: m.Role, Content: m.Content}
                // –î–ª—è tool response —Å–æ–æ–±—â–µ–Ω–∏–π –¥–æ–±–∞–≤–ª—è–µ–º ToolCallID
                if m.Role == "tool" &amp;&amp; m.ToolCallID != "" </span><span class="cov0" title="0">{
                        msg.ToolCallID = m.ToolCallID
                }</span>
                <span class="cov0" title="0">oaMsgs = append(oaMsgs, msg)</span>
        }

        <span class="cov0" title="0">req := openai.ChatCompletionRequest{
                Model:    c.model,
                Messages: oaMsgs,
        }

        // –î–æ–±–∞–≤–ª—è–µ–º tools –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
        if len(tools) &gt; 0 </span><span class="cov0" title="0">{
                var oaTools []openai.Tool
                for _, tool := range tools </span><span class="cov0" title="0">{
                        oaTools = append(oaTools, openai.Tool{
                                Type: openai.ToolTypeFunction,
                                Function: &amp;openai.FunctionDefinition{
                                        Name:        tool.Function.Name,
                                        Description: tool.Function.Description,
                                        Parameters:  tool.Function.Parameters,
                                },
                        })
                }</span>
                <span class="cov0" title="0">req.Tools = oaTools
                req.ToolChoice = "auto"</span> // LLM —Ä–µ—à–∞–µ—Ç —Å–∞–º–∞ –∫–æ–≥–¥–∞ –≤—ã–∑—ã–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏
        }

        <span class="cov0" title="0">resp, err := c.client.CreateChatCompletion(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return Response{}, fmt.Errorf("failed to create chat completion: %w", err)
        }</span>

        <span class="cov0" title="0">out := Response{
                Content: resp.Choices[0].Message.Content,
                Model:   c.model,
        }
        out.PromptTokens = resp.Usage.PromptTokens
        out.CompletionTokens = resp.Usage.CompletionTokens
        out.TotalTokens = resp.Usage.TotalTokens

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º tool calls –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
        if len(resp.Choices[0].Message.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                for _, tc := range resp.Choices[0].Message.ToolCalls </span><span class="cov0" title="0">{
                        out.ToolCalls = append(out.ToolCalls, ToolCall{
                                ID:   tc.ID,
                                Type: string(tc.Type),
                                Function: FunctionCall{
                                        Name:      tc.Function.Name,
                                        Arguments: parseJSONArgs(tc.Function.Arguments),
                                },
                        })
                }</span>
        }

        <span class="cov0" title="0">return out, nil</span>
}

// parseJSONArgs –ø–∞—Ä—Å–∏—Ç –∞—Ä–≥—É–º–µ–Ω—Ç—ã —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ JSON —Å—Ç—Ä–æ–∫–∏
func parseJSONArgs(args string) map[string]interface{} <span class="cov0" title="0">{
        var result map[string]interface{}
        if err := json.Unmarshal([]byte(args), &amp;result); err != nil </span><span class="cov0" title="0">{
                return make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package llm

// GetNotionTools –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ Notion –¥–ª—è LLM
func GetNotionTools() []Tool <span class="cov0" title="0">{
        return []Tool{
                {
                        Type: "function",
                        Function: Function{
                                Name:        "save_dialog_to_notion",
                                Description: "–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–µ–∫—É—â–∏–π –¥–∏–∞–ª–æ–≥ –≤ Notion. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–æ—Å–∏—Ç —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –±–µ—Å–µ–¥—É, –∑–∞–ø–æ–º–Ω–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –∑–∞–º–µ—Ç–∫—É.",
                                Parameters: map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "title": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "–ù–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –≤ Notion (–∫—Ä–∞—Ç–∫–æ–µ –∏ –ø–æ–Ω—è—Ç–Ω–æ–µ)",
                                                },
                                        },
                                        "required": []string{"title"},
                                },
                        },
                },
                {
                        Type: "function",
                        Function: Function{
                                Name:        "search_notion",
                                Description: "–ò—â–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ —Ä–∞–Ω–µ–µ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –¥–∏–∞–ª–æ–≥–∞—Ö –≤ Notion. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç –ø—Ä–æ –ø—Ä–æ—à–ª—ã–µ –±–µ—Å–µ–¥—ã –∏–ª–∏ –Ω—É–∂–Ω–æ –Ω–∞–π—Ç–∏ —Ä–∞–Ω–µ–µ –æ–±—Å—É–∂–¥—ë–Ω–Ω—ã–µ —Ç–µ–º—ã.",
                                Parameters: map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "query": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "–ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ Notion",
                                                },
                                        },
                                        "required": []string{"query"},
                                },
                        },
                },
                {
                        Type: "function",
                        Function: Function{
                                Name:        "create_notion_page",
                                Description: "–°–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤ Notion —Å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–º —Å–æ–¥–µ—Ä–∂–∏–º—ã–º. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–º–µ—Ç–æ–∫, –ø–ª–∞–Ω–æ–≤, –∏–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.",
                                Parameters: map[string]interface{}{
                                        "type": "object",
                                        "properties": map[string]interface{}{
                                                "title": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "–ù–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã",
                                                },
                                                "content": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "–°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –≤ —Ñ–æ—Ä–º–∞—Ç–µ Markdown",
                                                },
                                                "parent_page": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "–ù–∞–∑–≤–∞–Ω–∏–µ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)",
                                                },
                                        },
                                        "required": []string{"title", "content"},
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package llm

import (
        "context"
        "fmt"

        "github.com/Morwran/yagpt"
)

type YandexClient struct {
        ya       yagpt.YaGPTFace
        iamToken string
}

func NewYandex(oauthToken, folderID string) (*YandexClient, error) <span class="cov0" title="0">{
        // Create IAM token from OAuth token
        iam, err := yagpt.NewYaIam(oauthToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to init yandex iam: %w", err)
        }</span>
        <span class="cov0" title="0">resp, err := iam.Create()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create iam token: %w", err)
        }</span>

        // Create YaGPT client for a folder
        <span class="cov0" title="0">ya, err := yagpt.NewYagpt(folderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to init yagpt: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;YandexClient{
                ya:       ya,
                iamToken: resp.IamToken,
        }, nil</span>
}

func (c *YandexClient) Generate(ctx context.Context, messages []Message) (Response, error) <span class="cov0" title="0">{
        return c.GenerateWithTools(ctx, messages, nil)
}</span>

func (c *YandexClient) GenerateWithTools(ctx context.Context, messages []Message, tools []Tool) (Response, error) <span class="cov0" title="0">{
        // YandexGPT –ø–æ–∫–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç function calling
        // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º tools –∏ –¥–µ–ª–∞–µ–º –æ–±—ã—á–Ω—ã–π –∑–∞–ø—Ä–æ—Å
        var yaMsgs []yagpt.Message
        for _, m := range messages </span><span class="cov0" title="0">{
                yaMsgs = append(yaMsgs, yagpt.Message{Role: m.Role, Content: m.Content})
        }</span>

        <span class="cov0" title="0">resp, err := c.ya.CompletionWithCtx(ctx, c.iamToken, yaMsgs)
        if err != nil </span><span class="cov0" title="0">{
                return Response{}, fmt.Errorf("yagpt completion failed: %w", err)
        }</span>
        <span class="cov0" title="0">if resp == nil || len(resp.Alternatives) == 0 </span><span class="cov0" title="0">{
                return Response{}, fmt.Errorf("yagpt returned empty response")
        }</span>
        <span class="cov0" title="0">out := Response{Content: resp.Alternatives[0].Message.Content, Model: yagpt.YaModelLite}
        out.PromptTokens = int(resp.Usage.InputTextTokens)
        out.CompletionTokens = int(resp.Usage.CompletionTokens)
        out.TotalTokens = int(resp.Usage.TotalTokens)
        // YandexGPT –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç tool calls
        out.ToolCalls = nil
        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package notion

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "os/exec"
        "time"

        "github.com/modelcontextprotocol/go-sdk/mcp"
)

// MCPClient –∫–ª–∏–µ–Ω—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫–∞—Å—Ç–æ–º–Ω—ã–º Notion MCP —Å–µ—Ä–≤–µ—Ä–æ–º
type MCPClient struct {
        client  *mcp.Client
        session *mcp.ClientSession
}

// NewMCPClient —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π MCP –∫–ª–∏–µ–Ω—Ç –¥–ª—è Notion
func NewMCPClient(token string) *MCPClient <span class="cov0" title="0">{
        return &amp;MCPClient{}
}</span>

// Connect –ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫ –∫–∞—Å—Ç–æ–º–Ω–æ–º—É Notion MCP —Å–µ—Ä–≤–µ—Ä—É —á–µ—Ä–µ–∑ stdio
func (m *MCPClient) Connect(ctx context.Context, notionToken string) error <span class="cov0" title="0">{
        log.Printf("üîó Connecting to custom Notion MCP server via stdio")

        // –°–æ–∑–¥–∞–µ–º MCP –∫–ª–∏–µ–Ω—Ç
        m.client = mcp.NewClient(&amp;mcp.Implementation{
                Name:    "ai-chatter-bot",
                Version: "1.0.0",
        }, nil)

        // –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–∞—à –∫–∞—Å—Ç–æ–º–Ω—ã–π MCP —Å–µ—Ä–≤–µ—Ä –∫–∞–∫ –ø–æ–¥–ø—Ä–æ—Ü–µ—Å—Å
        serverPath := "./notion-mcp-server"
        if customPath := os.Getenv("NOTION_MCP_SERVER_PATH"); customPath != "" </span><span class="cov0" title="0">{
                serverPath = customPath
        }</span>

        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, serverPath)
        cmd.Env = append(os.Environ(), fmt.Sprintf("NOTION_TOKEN=%s", notionToken))

        transport := mcp.NewCommandTransport(cmd)

        session, err := m.client.Connect(ctx, transport)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to custom MCP server: %w", err)
        }</span>

        <span class="cov0" title="0">m.session = session
        log.Printf("‚úÖ Connected to custom Notion MCP server")
        return nil</span>
}

// Close –∑–∞–∫—Ä—ã–≤–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å MCP —Å–µ—Ä–≤–µ—Ä–æ–º
func (m *MCPClient) Close() error <span class="cov0" title="0">{
        if m.session != nil </span><span class="cov0" title="0">{
                return m.session.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateDialogSummary —Å–æ–∑–¥–∞–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –¥–∏–∞–ª–æ–≥–∞ —á–µ—Ä–µ–∑ –∫–∞—Å—Ç–æ–º–Ω—ã–π MCP
func (m *MCPClient) CreateDialogSummary(ctx context.Context, title, content, userID, username, dialogType, parentPageID string) MCPResult <span class="cov0" title="0">{
        if m.session == nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "MCP session not connected"}
        }</span>

        <span class="cov0" title="0">log.Printf("üìù Creating Notion page via custom MCP: %s", title)

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π parent_page_id
        if parentPageID == "" </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "parent_page_id is required - get it from your Notion workspace"}
        }</span>

        // –í—ã–∑—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç save_dialog_to_notion
        <span class="cov0" title="0">result, err := m.session.CallTool(ctx, &amp;mcp.CallToolParams{
                Name: "save_dialog_to_notion",
                Arguments: map[string]any{
                        "title":          title,
                        "content":        content,
                        "user_id":        userID,
                        "username":       username,
                        "dialog_type":    dialogType,
                        "parent_page_id": parentPageID,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ùå MCP save_dialog error: %v", err)
                return MCPResult{Success: false, Message: fmt.Sprintf("MCP error: %v", err)}
        }</span>

        <span class="cov0" title="0">if result.IsError </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "Tool returned error"}
        }</span>

        // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        <span class="cov0" title="0">var responseText string
        for _, content := range result.Content </span><span class="cov0" title="0">{
                if textContent, ok := content.(*mcp.TextContent); ok </span><span class="cov0" title="0">{
                        responseText += textContent.Text
                }</span>
        }

        <span class="cov0" title="0">var pageID string
        if result.Meta != nil </span><span class="cov0" title="0">{
                if id, ok := result.Meta["page_id"].(string); ok </span><span class="cov0" title="0">{
                        pageID = id
                }</span>
        }

        <span class="cov0" title="0">return MCPResult{
                Success: true,
                Message: responseText,
                PageID:  pageID,
                Data:    formatResultMeta(result.Meta),
        }</span>
}

// SearchDialogSummaries –∏—â–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∏–∞–ª–æ–≥–∏ —á–µ—Ä–µ–∑ –∫–∞—Å—Ç–æ–º–Ω—ã–π MCP
func (m *MCPClient) SearchDialogSummaries(ctx context.Context, query, userID, dialogType string) MCPResult <span class="cov0" title="0">{
        if m.session == nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "MCP session not connected"}
        }</span>

        <span class="cov0" title="0">log.Printf("üîç Searching Notion via custom MCP: query='%s'", query)

        // –í—ã–∑—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç search_pages
        result, err := m.session.CallTool(ctx, &amp;mcp.CallToolParams{
                Name: "search_pages",
                Arguments: map[string]any{
                        "query": query,
                        "filter": map[string]any{
                                "property": "Type",
                                "select": map[string]any{
                                        "equals": "Dialog",
                                },
                        },
                        "page_size": 20,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ùå MCP search error: %v", err)
                return MCPResult{Success: false, Message: fmt.Sprintf("MCP search error: %v", err)}
        }</span>

        <span class="cov0" title="0">if result.IsError </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "Tool returned error"}
        }</span>

        // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        <span class="cov0" title="0">var responseText string
        for _, content := range result.Content </span><span class="cov0" title="0">{
                if textContent, ok := content.(*mcp.TextContent); ok </span><span class="cov0" title="0">{
                        responseText += textContent.Text
                }</span>
        }

        <span class="cov0" title="0">return MCPResult{
                Success: true,
                Message: responseText,
                Data:    formatResultMeta(result.Meta),
        }</span>
}

// CreateFreeFormPage —Å–æ–∑–¥–∞–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É —á–µ—Ä–µ–∑ –∫–∞—Å—Ç–æ–º–Ω—ã–π MCP
func (m *MCPClient) CreateFreeFormPage(ctx context.Context, title, content, parentPageId string, tags []string) MCPResult <span class="cov0" title="0">{
        if m.session == nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "MCP session not connected"}
        }</span>

        <span class="cov0" title="0">log.Printf("üìÑ Creating free-form page via custom MCP: %s", title)

        // –í—ã–∑—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç create_page
        args := map[string]any{
                "title":   title,
                "content": content,
                "properties": map[string]any{
                        "Type":    "Free-form",
                        "Created": time.Now().Format("2006-01-02"),
                },
        }

        if parentPageId == "" </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "parent_page_id is required - get it from your Notion workspace"}
        }</span>

        <span class="cov0" title="0">args["parent_page_id"] = parentPageId

        if len(tags) &gt; 0 </span><span class="cov0" title="0">{
                args["properties"].(map[string]any)["Tags"] = tags
        }</span>

        <span class="cov0" title="0">result, err := m.session.CallTool(ctx, &amp;mcp.CallToolParams{
                Name:      "create_page",
                Arguments: args,
        })

        if err != nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: fmt.Sprintf("MCP error: %v", err)}
        }</span>

        <span class="cov0" title="0">if result.IsError </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: fmt.Sprintf("Tool returned error: %v", result.Content)}
        }</span>

        // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        <span class="cov0" title="0">var responseText string
        for _, content := range result.Content </span><span class="cov0" title="0">{
                if textContent, ok := content.(*mcp.TextContent); ok </span><span class="cov0" title="0">{
                        responseText += textContent.Text
                }</span>
        }

        <span class="cov0" title="0">var pageID string
        if result.Meta != nil </span><span class="cov0" title="0">{
                if id, ok := result.Meta["page_id"].(string); ok </span><span class="cov0" title="0">{
                        pageID = id
                }</span>
        }

        <span class="cov0" title="0">return MCPResult{
                Success: true,
                Message: responseText,
                PageID:  pageID,
                Data:    formatResultMeta(result.Meta),
        }</span>
}

// SearchWorkspace –≤—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –ø–æ workspace —á–µ—Ä–µ–∑ –∫–∞—Å—Ç–æ–º–Ω—ã–π MCP
func (m *MCPClient) SearchWorkspace(ctx context.Context, query, pageType string, tags []string) MCPResult <span class="cov0" title="0">{
        if m.session == nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "MCP session not connected"}
        }</span>

        <span class="cov0" title="0">args := map[string]any{
                "query":     query,
                "page_size": 50,
        }

        // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∏–ª—å—Ç—Ä –ø–æ —Ç–∏–ø—É –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω
        if pageType != "" </span><span class="cov0" title="0">{
                args["filter"] = map[string]any{
                        "property": "Type",
                        "select": map[string]any{
                                "equals": pageType,
                        },
                }
        }</span>

        <span class="cov0" title="0">result, err := m.session.CallTool(ctx, &amp;mcp.CallToolParams{
                Name:      "search_pages",
                Arguments: args,
        })

        if err != nil </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: fmt.Sprintf("MCP search error: %v", err)}
        }</span>

        <span class="cov0" title="0">if result.IsError </span><span class="cov0" title="0">{
                return MCPResult{Success: false, Message: "Tool returned error"}
        }</span>

        // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        <span class="cov0" title="0">var responseText string
        for _, content := range result.Content </span><span class="cov0" title="0">{
                if textContent, ok := content.(*mcp.TextContent); ok </span><span class="cov0" title="0">{
                        responseText += textContent.Text
                }</span>
        }

        <span class="cov0" title="0">return MCPResult{
                Success: true,
                Message: responseText,
                Data:    formatResultMeta(result.Meta),
        }</span>
}

// formatResultMeta —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤ JSON —Å—Ç—Ä–æ–∫—É
func formatResultMeta(meta any) string <span class="cov0" title="0">{
        if meta == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(meta)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return string(data)</span>
}

// MCPResult –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç MCP –≤—ã–∑–æ–≤–∞
type MCPResult struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
        Data    string `json:"data,omitempty"`
        PageID  string `json:"page_id,omitempty"`
}

// MCPCreatePagesResult —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü —á–µ—Ä–µ–∑ MCP
type MCPCreatePagesResult struct {
        Pages []MCPPageInfo `json:"pages"`
}

// MCPPageInfo –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–æ–∑–¥–∞–Ω–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
type MCPPageInfo struct {
        ID  string `json:"id"`
        URL string `json:"url"`
}

// MCPSearchResult —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞ —á–µ—Ä–µ–∑ MCP
type MCPSearchResult struct {
        Results []MCPSearchItem `json:"results"`
        Type    string          `json:"type"`
}

// MCPSearchItem —ç–ª–µ–º–µ–Ω—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–æ–∏—Å–∫–∞
type MCPSearchItem struct {
        Title     string `json:"title"`
        URL       string `json:"url"`
        Type      string `json:"type"`
        Highlight string `json:"highlight"`
        Timestamp string `json:"timestamp"`
        ID        string `json:"id"`
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package pending

import (
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"

        "ai-chatter/internal/auth"
)

type Repository interface {
        LoadAll() ([]auth.User, error)
        Upsert(user auth.User) error
        Remove(userID int64) error
}

type FileRepository struct {
        path string
        mu   sync.Mutex
}

func NewFileRepository(path string) (*FileRepository, error) <span class="cov1" title="1">{
        if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ensure dir: %w", err)
        }</span>
        <span class="cov1" title="1">f, err := os.OpenFile(path, os.O_CREATE, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("touch file: %w", err)
        }</span>
        <span class="cov1" title="1">_ = f.Close()
        return &amp;FileRepository{path: path}, nil</span>
}

func (r *FileRepository) LoadAll() ([]auth.User, error) <span class="cov6" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open: %w", err)
        }</span>
        <span class="cov6" title="2">defer func(f *os.File) </span><span class="cov6" title="2">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov6" title="2">var users []auth.User
        dec := json.NewDecoder(f)
        if err := dec.Decode(&amp;users); err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return []auth.User{}, nil
                }</span>
                <span class="cov0" title="0">return []auth.User{}, nil</span>
        }
        <span class="cov6" title="2">return users, nil</span>
}

func (r *FileRepository) Upsert(user auth.User) error <span class="cov6" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()
        users, _ := r.loadUnlocked()
        updated := false
        for i, u := range users </span><span class="cov1" title="1">{
                if u.ID == user.ID </span><span class="cov0" title="0">{
                        users[i] = user
                        updated = true
                        break</span>
                }
        }
        <span class="cov6" title="2">if !updated </span><span class="cov6" title="2">{
                users = append(users, user)
        }</span>
        <span class="cov6" title="2">return r.saveUnlocked(users)</span>
}

func (r *FileRepository) Remove(userID int64) error <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        users, _ := r.loadUnlocked()
        var out []auth.User
        for _, u := range users </span><span class="cov6" title="2">{
                if u.ID != userID </span><span class="cov1" title="1">{
                        out = append(out, u)
                }</span>
        }
        <span class="cov1" title="1">return r.saveUnlocked(out)</span>
}

func (r *FileRepository) loadUnlocked() ([]auth.User, error) <span class="cov10" title="3">{
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">defer func(f *os.File) </span><span class="cov10" title="3">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov10" title="3">var users []auth.User
        dec := json.NewDecoder(f)
        if err := dec.Decode(&amp;users); err != nil </span><span class="cov1" title="1">{
                return []auth.User{}, nil
        }</span>
        <span class="cov6" title="2">return users, nil</span>
}

func (r *FileRepository) saveUnlocked(users []auth.User) error <span class="cov10" title="3">{
        f, err := os.OpenFile(r.path, os.O_TRUNC|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="3">defer func(f *os.File) </span><span class="cov10" title="3">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov10" title="3">enc := json.NewEncoder(f)
        enc.SetIndent("", "  ")
        return enc.Encode(users)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package storage

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sync"
)

type FileRecorder struct {
        path string
        mu   sync.Mutex
}

func NewFileRecorder(path string) (*FileRecorder, error) <span class="cov1" title="1">{
        if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ensure log dir: %w", err)
        }</span>
        <span class="cov1" title="1">f, err := os.OpenFile(path, os.O_CREATE, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to init log file: %w", err)
        }</span>
        <span class="cov1" title="1">_ = f.Close()
        return &amp;FileRecorder{path: path}, nil</span>
}

func (r *FileRecorder) AppendInteraction(event Event) error <span class="cov10" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()
        f, err := os.OpenFile(r.path, os.O_APPEND|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open append: %w", err)
        }</span>
        <span class="cov10" title="2">defer func(f *os.File) </span><span class="cov10" title="2">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov10" title="2">enc := json.NewEncoder(f)
        if err := enc.Encode(event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("encode append: %w", err)
        }</span>
        <span class="cov10" title="2">return nil</span>
}

func (r *FileRecorder) LoadInteractions() ([]Event, error) <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open read: %w", err)
        }</span>
        <span class="cov1" title="1">defer func(f *os.File) </span><span class="cov1" title="1">{
                err := f.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(f)
        <span class="cov1" title="1">s := bufio.NewScanner(f)
        buf := make([]byte, 0, 1024*1024)
        s.Buffer(buf, 10*1024*1024)
        var events []Event
        for s.Scan() </span><span class="cov10" title="2">{
                line := s.Bytes()
                if len(line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="2">var ev Event
                if err := json.Unmarshal(line, &amp;ev); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="2">events = append(events, ev)</span>
        }
        <span class="cov1" title="1">if err := s.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scan: %w", err)
        }</span>
        <span class="cov1" title="1">return events, nil</span>
}

func (r *FileRecorder) SetAllCanUse(userID int64, canUse bool) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        // read all
        f, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open read: %w", err)
        }</span>
        <span class="cov0" title="0">var events []Event
        s := bufio.NewScanner(f)
        buf := make([]byte, 0, 1024*1024)
        s.Buffer(buf, 10*1024*1024)
        for s.Scan() </span><span class="cov0" title="0">{
                line := s.Bytes()
                if len(line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var ev Event
                if err := json.Unmarshal(line, &amp;ev); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if ev.UserID == userID </span><span class="cov0" title="0">{
                        ev.CanUse = &amp;canUse
                }</span>
                <span class="cov0" title="0">events = append(events, ev)</span>
        }
        <span class="cov0" title="0">_ = f.Close()
        if err := s.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("scan: %w", err)
        }</span>
        // rewrite file
        <span class="cov0" title="0">wf, err := os.OpenFile(r.path, os.O_TRUNC|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open write: %w", err)
        }</span>
        <span class="cov0" title="0">defer func(wf *os.File) </span><span class="cov0" title="0">{
                err := wf.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(wf)
        <span class="cov0" title="0">enc := json.NewEncoder(wf)
        for _, ev := range events </span><span class="cov0" title="0">{
                if err := enc.Encode(ev); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("encode: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package telegram

import tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

type sender interface {
        Send(c tgbotapi.Chattable) (tgbotapi.Message, error)
}

type botAPISender struct{ api *tgbotapi.BotAPI }

func (s botAPISender) Send(c tgbotapi.Chattable) (tgbotapi.Message, error) <span class="cov0" title="0">{
        return s.api.Send(c)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package telegram

import (
        "context"
        "fmt"
        "html"
        "log"
        "os"
        "strings"
        "sync"
        "time"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

        "ai-chatter/internal/auth"
        "ai-chatter/internal/history"
        "ai-chatter/internal/llm"
        "ai-chatter/internal/notion"
        "ai-chatter/internal/pending"
        "ai-chatter/internal/storage"
)

const (
        resetCmd       = "reset_ctx"
        summaryCmd     = "summary_ctx"
        approvePrefix  = "approve:"
        denyPrefix     = "deny:"
        spUpdateMarker = "[system_prompt_update]"
        // TZ conversation limit (assistant clarification turns)
        tzMaxSteps = 15
)

type Bot struct {
        api          *tgbotapi.BotAPI
        s            sender
        authSvc      *auth.Service
        systemPrompt string
        llmClient    llm.Client
        llmMu        sync.RWMutex
        history      *history.Manager
        recorder     storage.Recorder
        adminUserID  int64
        pending      map[int64]auth.User
        pendingRepo  pending.Repository
        parseMode    string
        provider     string
        model        string
        // secondary model for post-TS instruction
        model2           string
        llmClient2       llm.Client
        llmFactory       *llm.Factory
        userSysMu        sync.RWMutex
        userSystemPrompt map[int64]string
        tzMu             sync.RWMutex
        tzMode           map[int64]bool
        // per-user remaining steps in TZ mode
        tzRemaining map[int64]int
        // Notion MCP client
        mcpClient        *notion.MCPClient
        notionParentPage string
}

func New(
        botToken string,
        authSvc *auth.Service,
        llmClient llm.Client,
        llmFactory *llm.Factory,
        systemPrompt string,
        rec storage.Recorder,
        adminUserID int64,
        pendingRepo pending.Repository,
        parseMode string,
        provider string,
        model string,
        mcpClient *notion.MCPClient,
        notionParentPage string,
) (*Bot, error) <span class="cov0" title="0">{
        api, err := tgbotapi.NewBotAPI(botToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">b := &amp;Bot{
                api:              api,
                s:                botAPISender{api: api},
                authSvc:          authSvc,
                systemPrompt:     systemPrompt,
                history:          history.NewManager(),
                recorder:         rec,
                adminUserID:      adminUserID,
                pending:          make(map[int64]auth.User),
                pendingRepo:      pendingRepo,
                parseMode:        parseMode,
                provider:         provider,
                model:            model,
                llmFactory:       llmFactory,
                userSystemPrompt: make(map[int64]string),
                tzMode:           make(map[int64]bool),
                tzRemaining:      make(map[int64]int),
                mcpClient:        mcpClient,
                notionParentPage: notionParentPage,
        }
        // Try to preload model2 from file if present
        if data, err := os.ReadFile("data/model2.txt"); err == nil </span><span class="cov0" title="0">{
                m2 := strings.TrimSpace(string(data))
                if m2 != "" </span><span class="cov0" title="0">{
                        b.model2 = m2
                }</span>
        }
        <span class="cov0" title="0">b.setLLMClient(llmClient)
        if rec != nil </span><span class="cov0" title="0">{
                if events, err := rec.LoadInteractions(); err == nil </span><span class="cov0" title="0">{
                        for _, ev := range events </span><span class="cov0" title="0">{
                                if ev.UserID == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if ev.UserMessage == spUpdateMarker &amp;&amp; ev.AssistantResponse != "" </span><span class="cov0" title="0">{
                                        b.addUserSystemPromptInternal(ev.UserID, ev.AssistantResponse, false)
                                        continue</span>
                                }
                                <span class="cov0" title="0">used := true
                                if ev.CanUse != nil </span><span class="cov0" title="0">{
                                        used = *ev.CanUse
                                }</span>
                                <span class="cov0" title="0">if ev.UserMessage != "" </span><span class="cov0" title="0">{
                                        b.history.AppendUserWithUsed(ev.UserID, ev.UserMessage, used)
                                }</span>
                                <span class="cov0" title="0">if ev.AssistantResponse != "" </span><span class="cov0" title="0">{
                                        b.history.AppendAssistantWithUsed(ev.UserID, ev.AssistantResponse, used)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">if b.pendingRepo != nil </span><span class="cov0" title="0">{
                if items, err := b.pendingRepo.LoadAll(); err == nil </span><span class="cov0" title="0">{
                        for _, u := range items </span><span class="cov0" title="0">{
                                b.pending[u.ID] = u
                        }</span>
                }
        }
        <span class="cov0" title="0">return b, nil</span>
}

func (b *Bot) getLLMClient() llm.Client <span class="cov6" title="12">{
        b.llmMu.RLock()
        defer b.llmMu.RUnlock()
        return b.llmClient
}</span>

func (b *Bot) setLLMClient(c llm.Client) <span class="cov0" title="0">{
        b.llmMu.Lock()
        defer b.llmMu.Unlock()
        b.llmClient = c
}</span>

func (b *Bot) getSecondLLMClient() llm.Client <span class="cov5" title="7">{
        b.llmMu.RLock()
        cli := b.llmClient2
        b.llmMu.RUnlock()
        if cli != nil </span><span class="cov4" title="5">{
                return cli
        }</span>

        <span class="cov2" title="2">desiredModel := b.model
        if strings.TrimSpace(b.model2) != "" </span><span class="cov0" title="0">{
                desiredModel = b.model2
        }</span>

        <span class="cov2" title="2">newCli, err := b.llmFactory.CreateClient(b.provider, desiredModel)
        if err != nil </span><span class="cov2" title="2">{
                // Fallback to primary client
                newCli = b.getLLMClient()
        }</span>

        <span class="cov2" title="2">b.llmMu.Lock()
        if b.llmClient2 == nil </span><span class="cov2" title="2">{
                b.llmClient2 = newCli
                cli = newCli
        }</span> else<span class="cov0" title="0"> {
                cli = b.llmClient2
        }</span>
        <span class="cov2" title="2">b.llmMu.Unlock()
        return cli</span>
}

func (b *Bot) reloadLLMClient() error <span class="cov0" title="0">{
        newCli, err := b.llmFactory.CreateClient(b.provider, b.model)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">b.setLLMClient(newCli)
        b.llmMu.Lock()
        b.llmClient2 = nil
        b.llmMu.Unlock()
        return nil</span>
}

func (b *Bot) escapeIfNeeded(s string) string <span class="cov7" title="14">{
        pm := strings.ToLower(b.parseModeValue())
        switch pm </span>{
        case strings.ToLower(tgbotapi.ModeMarkdownV2):<span class="cov0" title="0">
                return escapeMarkdownV2(s)</span>
        case strings.ToLower(tgbotapi.ModeHTML):<span class="cov6" title="12">
                return html.EscapeString(s)</span>
        default:<span class="cov2" title="2">
                return s</span>
        }
}

func escapeMarkdownV2(s string) string <span class="cov0" title="0">{
        repl := strings.NewReplacer(
                "_", "\\_",
                "*", "\\*",
                "[", "\\[",
                "]", "\\]",
                "(", "\\(",
                ")", "\\)",
                "~", "\\~",
                "`", "\\`",
                "&gt;", "\\&gt;",
                "#", "\\#",
                "+", "\\+",
                "-", "\\-",
                "=", "\\=",
                "|", "\\|",
                "{", "\\{",
                "}", "\\}",
                ".", "\\.",
                "!", "\\!",
        )
        return repl.Replace(s)
}</span>

func (b *Bot) parseModeValue() string <span class="cov9" title="45">{
        s := strings.ToLower(b.parseMode)
        switch s </span>{
        case strings.ToLower(tgbotapi.ModeMarkdown), strings.ToLower(tgbotapi.ModeMarkdownV2), strings.ToLower(tgbotapi.ModeHTML):<span class="cov9" title="43">
                return b.parseMode</span>
        default:<span class="cov2" title="2">
                return tgbotapi.ModeMarkdown</span>
        }
}

func (b *Bot) Start(ctx context.Context) <span class="cov0" title="0">{
        u := tgbotapi.NewUpdate(0)
        u.Timeout = 60

        log.Printf("Bot started")
        if b.adminUserID != 0 </span><span class="cov0" title="0">{
                info := fmt.Sprintf("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ. –ü—Ä–æ–≤–∞–π–¥–µ—Ä: %s, –º–æ–¥–µ–ª—å: %s.", b.provider, b.model)
                b.sendMessage(b.adminUserID, info)
        }</span>

        <span class="cov0" title="0">updates := b.api.GetUpdatesChan(u)

        for update := range updates </span><span class="cov0" title="0">{
                if update.Message != nil </span><span class="cov0" title="0">{
                        if update.Message.IsCommand() </span><span class="cov0" title="0">{
                                if update.Message.Command() == "start" </span><span class="cov0" title="0">{
                                        b.handleStart(update.Message)
                                        continue</span>
                                }
                                <span class="cov0" title="0">b.handleCommand(update.Message)
                                continue</span>
                        }
                        <span class="cov0" title="0">b.handleIncomingMessage(ctx, update.Message)
                        continue</span>
                }
                <span class="cov0" title="0">if update.CallbackQuery != nil </span><span class="cov0" title="0">{
                        b.handleCallback(ctx, update.CallbackQuery)
                        continue</span>
                }
        }
}

func (b *Bot) handleStart(msg *tgbotapi.Message) <span class="cov0" title="0">{
        welcome := "–ü—Ä–∏–≤–µ—Ç! –Ø LLM-–±–æ—Ç. –û—Ç–≤–µ—á–∞—é –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã —Å —É—á—ë—Ç–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞. –ü–æ–¥ –∫–∞–∂–¥—ã–º –æ—Ç–≤–µ—Ç–æ–º –µ—Å—Ç—å –∫–Ω–æ–ø–∫–∏: ‚Äò–ò—Å—Ç–æ—Ä–∏—è‚Äô (—Å–∞–º–º–∞—Ä–∏ –¥–∏–∞–ª–æ–≥–∞) –∏ ‚Äò–°–±—Ä–æ—Å–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç‚Äô."
        if b.authSvc.IsAllowed(msg.From.ID) </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, welcome+"\n\n–î–æ—Å—Ç—É–ø —É–∂–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω. –ú–æ–∂–µ—Ç–µ –ø–∏—Å–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ.")
                return
        }</span>
        // Not allowed: cache and request admin
        <span class="cov0" title="0">b.pending[msg.From.ID] = auth.User{ID: msg.From.ID, Username: msg.From.UserName, FirstName: msg.From.FirstName, LastName: msg.From.LastName}
        b.notifyAdminRequest(msg.From.ID, msg.From.UserName)
        b.sendMessage(msg.Chat.ID, welcome+"\n\n–ó–∞–ø—Ä–æ—Å –Ω–∞ –¥–æ—Å—Ç—É–ø –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É. –ö–∞–∫ —Ç–æ–ª—å–∫–æ –æ–Ω –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç, –≤—ã –ø–æ–ª—É—á–∏—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ.")</span>
}

// handleCommand is implemented in handlers.go

func (b *Bot) handleAdminConfigCommands(msg *tgbotapi.Message) <span class="cov1" title="1">{
        if msg.From.ID != b.adminUserID </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "–ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
                return
        }</span>
        <span class="cov1" title="1">cmd := msg.Command()
        args := strings.Fields(msg.CommandArguments())
        switch cmd </span>{
        case "provider":<span class="cov0" title="0">
                if len(args) != 1 </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Usage: /provider &lt;openai|yandex&gt;")
                        return
                }</span>
                <span class="cov0" title="0">prov := strings.ToLower(args[0])
                if prov != "openai" &amp;&amp; prov != "yandex" </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è: openai, yandex")
                        return
                }</span>
                <span class="cov0" title="0">if err := os.WriteFile("data/provider.txt", []byte(prov), 0o644); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.provider = prov
                if err := b.reloadLLMClient(); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏ –∫–ª–∏–µ–Ω—Ç–∞: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, fmt.Sprintf("–ü—Ä–æ–≤–∞–π–¥–µ—Ä —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏ –ø—Ä–∏–º–µ–Ω—ë–Ω: %s", prov))</span>
        case "model":<span class="cov0" title="0">
                if len(args) != 1 </span><span class="cov0" title="0">{
                        allowedModels := strings.Join(llm.GetAllowedModels(), "|")
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Usage: /model &lt;%s&gt;", allowedModels))
                        return
                }</span>
                <span class="cov0" title="0">model := args[0]
                if !llm.IsModelAllowed(model) </span><span class="cov0" title="0">{
                        allowedModels := strings.Join(llm.GetAllowedModels(), ", ")
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–∞—è –º–æ–¥–µ–ª—å. –î–æ—Å—Ç—É–ø–Ω—ã–µ: %s", allowedModels))
                        return
                }</span>
                <span class="cov0" title="0">if err := os.WriteFile("data/model.txt", []byte(model), 0o644); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.model = model
                if err := b.reloadLLMClient(); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏ –∫–ª–∏–µ–Ω—Ç–∞: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, fmt.Sprintf("–ú–æ–¥–µ–ª—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∞: %s", model))</span>
        case "model2":<span class="cov1" title="1">
                if len(args) != 1 </span><span class="cov0" title="0">{
                        allowedModels := strings.Join(llm.GetAllowedModels(), "|")
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("Usage: /model2 &lt;%s&gt;", allowedModels))
                        return
                }</span>
                <span class="cov1" title="1">model := args[0]
                if !llm.IsModelAllowed(model) </span><span class="cov1" title="1">{
                        allowedModels := strings.Join(llm.GetAllowedModels(), ", ")
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–∞—è –º–æ–¥–µ–ª—å. –î–æ—Å—Ç—É–ø–Ω—ã–µ: %s", allowedModels))
                        return
                }</span>
                <span class="cov0" title="0">if err := os.WriteFile("data/model2.txt", []byte(model), 0o644); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.model2 = model
                b.llmMu.Lock()
                b.llmClient2 = nil
                b.llmMu.Unlock()
                b.sendMessage(msg.Chat.ID, fmt.Sprintf("–í—Ç–æ—Ä–∞—è –º–æ–¥–µ–ª—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: %s", model))</span>
        }
}

// JSON parsing moved to process.go

func (b *Bot) formatTitleAnswer(title, answer string) string <span class="cov6" title="11">{
        pm := strings.ToLower(b.parseModeValue())
        switch pm </span>{
        case strings.ToLower(tgbotapi.ModeHTML):<span class="cov6" title="11">
                // Preserve answer formatting as-is; escape only title
                return fmt.Sprintf("&lt;b&gt;%s&lt;/b&gt;\n\n%s", html.EscapeString(title), answer)</span>
        case strings.ToLower(tgbotapi.ModeMarkdownV2):<span class="cov0" title="0">
                // Preserve answer; escape title
                return fmt.Sprintf("%s\n\n%s", escapeMarkdownV2(title), answer)</span>
        default:<span class="cov0" title="0"> // Markdown
                return fmt.Sprintf("%s\n\n%s", title, answer)</span>
        }
}

// Context management

func sizeOfMessages(msgs []llm.Message) int <span class="cov0" title="0">{
        t := 0
        for _, m := range msgs </span><span class="cov0" title="0">{
                t += len(m.Content)
        }</span>
        <span class="cov0" title="0">return t</span>
}

func truncateForLog(s string, limit int) string <span class="cov9" title="32">{
        if len(s) &lt;= limit </span><span class="cov9" title="32">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:limit] + "‚Ä¶"</span>
}

func (b *Bot) logLLMRequest(userID int64, purpose string, msgs []llm.Message) <span class="cov7" title="17">{
        var bld strings.Builder
        bld.WriteString(fmt.Sprintf("LLM request | user=%d | purpose=%s | provider=%s | model=%s | messages=%d\n", userID, purpose, b.provider, b.model, len(msgs)))
        for i, m := range msgs </span><span class="cov9" title="32">{
                content := truncateForLog(m.Content, 1500)
                bld.WriteString(fmt.Sprintf("  [%d] role=%s len=%d\n      %s\n", i, m.Role, len(m.Content), content))
        }</span>
        <span class="cov7" title="17">log.Print(bld.String())</span>
}

// Retry to conform to schema
func (b *Bot) reformatToSchema(ctx context.Context, userID int64, raw string) (llmJSON, bool) <span class="cov0" title="0">{
        instr := "You are a formatter. Reformat the previous output strictly into a JSON object with exactly these fields: {title, answer, compressed_context, status}. Values: status must be one of ['continue','final']. Do not add other top-level keys. Do not change content, only structure."
        msgs := []llm.Message{{Role: "system", Content: instr}, {Role: "user", Content: raw}}
        b.logLLMRequest(userID, "reformat_to_schema", msgs)
        resp, err := b.getLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                return llmJSON{}, false
        }</span>
        <span class="cov0" title="0">p, ok := parseLLMJSON(resp.Content)
        return p, ok</span>
}

// Context build no longer proactively compresses
func (b *Bot) buildContextWithOverflow(ctx context.Context, userID int64) []llm.Message <span class="cov6" title="9">{
        var msgs []llm.Message
        sys := b.getUserSystemPrompt(userID)
        if sys != "" </span><span class="cov5" title="7">{
                msgs = append(msgs, llm.Message{Role: "system", Content: sys})
        }</span>
        <span class="cov6" title="9">msgs = append(msgs, b.history.Get(userID)...)
        _ = ctx
        return msgs</span>
}

// Command handling additions

// moved: handlers in handlers.go

func (b *Bot) approveUser(id int64) <span class="cov0" title="0">{
        u := b.pending[id]
        if u.ID == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">delete(b.pending, id)
        if b.pendingRepo != nil </span><span class="cov0" title="0">{
                _ = b.pendingRepo.Remove(id)
        }</span>
        <span class="cov0" title="0">_ = b.authSvc.Upsert(u)
        msg := tgbotapi.NewMessage(b.adminUserID, b.escapeIfNeeded(fmt.Sprintf("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @%s (%d) –¥–æ–±–∞–≤–ª–µ–Ω –≤ allowlist", u.Username, u.ID)))
        msg.ParseMode = b.parseModeValue()
        if _, err := b.s.Send(msg); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to notify approval: %v", err)
        }</span>
        <span class="cov0" title="0">msg2 := tgbotapi.NewMessage(u.ID, b.escapeIfNeeded("–í–∞—à –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω. –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!"))
        msg2.ParseMode = b.parseModeValue()
        if _, err := b.s.Send(msg2); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to notify user approval: %v", err)
        }</span>
}

func (b *Bot) denyUser(id int64) <span class="cov0" title="0">{
        u := b.pending[id]
        if u.ID == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">delete(b.pending, id)
        if b.pendingRepo != nil </span><span class="cov0" title="0">{
                _ = b.pendingRepo.Remove(id)
        }</span>
        <span class="cov0" title="0">msg := tgbotapi.NewMessage(b.adminUserID, b.escapeIfNeeded(fmt.Sprintf("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é @%s (%d) –æ—Ç–∫–∞–∑–∞–Ω–æ –≤ –¥–æ—Å—Ç—É–ø–µ", u.Username, u.ID)))
        msg.ParseMode = b.parseModeValue()
        if _, err := b.s.Send(msg); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to notify denial: %v", err)
        }</span>
}

func (b *Bot) menuKeyboard() tgbotapi.InlineKeyboardMarkup <span class="cov6" title="11">{
        return tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("–°–±—Ä–æ—Å–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç", resetCmd),
                        tgbotapi.NewInlineKeyboardButtonData("–ò—Å—Ç–æ—Ä–∏—è", summaryCmd),
                ),
        )
}</span>

func (b *Bot) sendMessage(chatID int64, text string) <span class="cov2" title="2">{
        msg := tgbotapi.NewMessage(chatID, b.escapeIfNeeded(text))
        msg.ParseMode = b.parseModeValue()
        if _, err := b.s.Send(msg); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

func (b *Bot) getUserSystemPrompt(userID int64) string <span class="cov6" title="9">{
        b.userSysMu.RLock()
        sp, ok := b.userSystemPrompt[userID]
        b.userSysMu.RUnlock()
        if !ok || sp == "" </span><span class="cov5" title="6">{
                return b.systemPrompt
        }</span>
        <span class="cov3" title="3">return sp</span>
}

func (b *Bot) addUserSystemPrompt(userID int64, addition string) <span class="cov3" title="3">{
        b.addUserSystemPromptInternal(userID, addition, true)
}</span>

func (b *Bot) addUserSystemPromptInternal(userID int64, addition string, persist bool) <span class="cov3" title="3">{
        if strings.TrimSpace(addition) == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="3">b.userSysMu.Lock()
        if b.userSystemPrompt == nil </span><span class="cov3" title="3">{
                b.userSystemPrompt = make(map[int64]string)
        }</span>
        <span class="cov3" title="3">current := b.userSystemPrompt[userID]
        if current == "" </span><span class="cov3" title="3">{
                current = b.systemPrompt
        }</span>
        <span class="cov3" title="3">if !strings.Contains(current, addition) </span><span class="cov3" title="3">{
                if current != "" </span><span class="cov2" title="2">{
                        current = current + "\n\n" + addition
                }</span> else<span class="cov1" title="1"> {
                        current = addition
                }</span>
                <span class="cov3" title="3">b.userSystemPrompt[userID] = current</span>
        }
        <span class="cov3" title="3">b.userSysMu.Unlock()
        if persist &amp;&amp; b.recorder != nil </span><span class="cov0" title="0">{
                f := false
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: time.Now().UTC(), UserID: userID, UserMessage: spUpdateMarker, AssistantResponse: addition, CanUse: &amp;f})
        }</span>
}

// --- TZ helpers ---

func (b *Bot) setTZMode(userID int64, on bool) <span class="cov4" title="4">{
        b.tzMu.Lock()
        if b.tzMode == nil </span><span class="cov4" title="4">{
                b.tzMode = make(map[int64]bool)
        }</span>
        <span class="cov4" title="4">b.tzMode[userID] = on
        b.tzMu.Unlock()</span>
}
func (b *Bot) isTZMode(userID int64) bool <span class="cov10" title="46">{
        b.tzMu.RLock()
        v := false
        if b.tzMode != nil </span><span class="cov8" title="22">{
                v = b.tzMode[userID]
        }</span>
        <span class="cov10" title="46">b.tzMu.RUnlock()
        return v</span>
}

func (b *Bot) setTZRemaining(userID int64, steps int) <span class="cov4" title="4">{
        b.tzMu.Lock()
        if b.tzRemaining == nil </span><span class="cov4" title="4">{
                b.tzRemaining = make(map[int64]int)
        }</span>
        <span class="cov4" title="4">b.tzRemaining[userID] = steps
        b.tzMu.Unlock()</span>
}
func (b *Bot) getTZRemaining(userID int64) int <span class="cov5" title="6">{
        b.tzMu.RLock()
        v := 0
        if b.tzRemaining != nil </span><span class="cov5" title="6">{
                v = b.tzRemaining[userID]
        }</span>
        <span class="cov5" title="6">b.tzMu.RUnlock()
        return v</span>
}
func (b *Bot) decTZRemaining(userID int64) int <span class="cov2" title="2">{
        b.tzMu.Lock()
        if b.tzRemaining == nil </span><span class="cov0" title="0">{
                b.tzRemaining = make(map[int64]int)
        }</span>
        <span class="cov2" title="2">left := b.tzRemaining[userID]
        if left &gt; 0 </span><span class="cov2" title="2">{
                left--
                b.tzRemaining[userID] = left
        }</span>
        <span class="cov2" title="2">b.tzMu.Unlock()
        return left</span>
}
func (b *Bot) clearTZState(userID int64) <span class="cov3" title="3">{
        b.tzMu.Lock()
        if b.tzMode != nil </span><span class="cov3" title="3">{
                delete(b.tzMode, userID)
        }</span>
        <span class="cov3" title="3">if b.tzRemaining != nil </span><span class="cov3" title="3">{
                delete(b.tzRemaining, userID)
        }</span>
        <span class="cov3" title="3">b.tzMu.Unlock()</span>
}

// Building context with overflow protection

func (b *Bot) produceFinalTS(ctx context.Context, userID int64) (llmJSON, llm.Response, bool) <span class="cov1" title="1">{
        msgs := b.buildContextWithOverflow(ctx, userID)
        finalInstr := "–°—Ñ–æ—Ä–º–∏—Ä—É–π –∏—Ç–æ–≥–æ–≤–æ–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ –∑–∞–¥–∞–Ω–∏–µ (–¢–ó) –ø–æ —Å–æ–±—Ä–∞–Ω–Ω—ã–º –¥–∞–Ω–Ω—ã–º. –û—Ç–≤–µ—Ç —Å—Ç—Ä–æ–≥–æ –≤ JSON —Å–æ —Å—Ö–µ–º–æ–π {title, answer, compressed_context, status}. –í 'answer' –ø–æ–º–µ—Å—Ç–∏ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–µ, —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¢–ó. –£—Å—Ç–∞–Ω–æ–≤–∏ status='final'."
        msgs = append([]llm.Message{{Role: "system", Content: finalInstr}}, msgs...)
        b.logLLMRequest(userID, "tz_finalize", msgs)
        resp, err := b.getLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                return llmJSON{}, llm.Response{}, false
        }</span>
        <span class="cov1" title="1">p, ok := parseLLMJSON(resp.Content)
        if !ok </span><span class="cov0" title="0">{
                if p2, ok2 := b.reformatToSchema(ctx, userID, resp.Content); ok2 </span><span class="cov0" title="0">{
                        return p2, resp, true
                }</span>
                <span class="cov0" title="0">return llmJSON{}, llm.Response{}, false</span>
        }
        <span class="cov1" title="1">return p, resp, true</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package telegram

import (
        "context"
        "fmt"
        "log"
        "strconv"
        "strings"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

        "ai-chatter/internal/auth"
        "ai-chatter/internal/llm"
        "ai-chatter/internal/storage"
)

// handleCommand
func (b *Bot) handleCommand(msg *tgbotapi.Message) <span class="cov4" title="2">{
        if msg.Command() == "provider" || msg.Command() == "model" || msg.Command() == "model2" </span><span class="cov0" title="0">{
                b.handleAdminConfigCommands(msg)
                return
        }</span>
        // Notion commands
        <span class="cov4" title="2">if msg.Command() == "notion_save" </span><span class="cov0" title="0">{
                b.handleNotionSave(msg)
                return
        }</span>
        <span class="cov4" title="2">if msg.Command() == "notion_search" </span><span class="cov0" title="0">{
                b.handleNotionSearch(msg)
                return
        }</span>
        <span class="cov4" title="2">if msg.Command() == "tz" </span><span class="cov4" title="2">{
                if !b.authSvc.IsAllowed(msg.From.ID) </span><span class="cov0" title="0">{
                        return
                }</span>
                // Reset previous context for this user (do not delete logs, just mark not used)
                <span class="cov4" title="2">b.history.DisableAll(msg.From.ID)
                if b.recorder != nil </span><span class="cov0" title="0">{
                        _ = b.recorder.SetAllCanUse(msg.From.ID, false)
                }</span>

                <span class="cov4" title="2">topic := strings.TrimSpace(msg.CommandArguments())
                addition := "Requirements elicitation mode (Technical Specification). Your job is to iteratively clarify and assemble a complete TS in Russian for the topic: '" + topic + "'. " +
                        "Ask up to 5 highly targeted questions per turn until you are confident the TS is complete. Focus on: scope/goals, user roles, environment, constraints (budget/time/tech), functional and non-functional requirements, data and integrations, dependencies, acceptance criteria, risks/mitigations, deliverables and plan. " +
                        "When asking questions, prefer concrete options (multiple-choice) and short free-form fields; personalize questions to the user‚Äôs previous answers (e.g., preferred and unwanted ingredients, platforms, APIs, performance targets). " +
                        "Always respond strictly in JSON {title, answer, compressed_context, status}. Set status='continue' while clarifying. When the TS is fully ready, set status='final'. If your context window is &gt;= 80% full, include 'compressed_context' with a compact string summary of essential facts/decisions to continue without previous messages. You have at most 15 messages to clarify before finalization. " +
                        "VERY IMPORTANT: Present your questions as a numbered list (1., 2., 3., ...) with each question on its own new line. Do not merge questions into a single paragraph."
                b.addUserSystemPrompt(msg.From.ID, addition)
                b.setTZMode(msg.From.ID, true)
                b.setTZRemaining(msg.From.ID, tzMaxSteps)
                seed := "–¢–µ–º–∞ –¢–ó: " + topic
                b.history.AppendUser(msg.From.ID, seed)
                if b.recorder != nil </span><span class="cov0" title="0">{
                        tru := true
                        _ = b.recorder.AppendInteraction(storage.Event{Timestamp: b.nowUTC(), UserID: msg.From.ID, UserMessage: seed, CanUse: &amp;tru})
                }</span>
                <span class="cov4" title="2">ctx := context.Background()
                contextMsgs := b.buildContextWithOverflow(ctx, msg.From.ID)
                if b.isTZMode(msg.From.ID) </span><span class="cov4" title="2">{
                        left := b.getTZRemaining(msg.From.ID)
                        if left &gt; 0 &amp;&amp; left &lt;= 2 </span><span class="cov0" title="0">{
                                accel := "–û—Å—Ç–∞–ª–æ—Å—å –æ—á–µ–Ω—å –º–∞–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏–π (&lt;=2). –°–æ–∫—Ä–∞—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–ø—Ä–æ—Å–æ–≤ –∏ –ø–æ—Å—Ç–∞—Ä–∞–π—Å—è –∑–∞–≤–µ—Ä—à–∏—Ç—å —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –¢–ó –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ. –ï—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ ‚Äî —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä—É–π —É–∂–µ –≤ —ç—Ç–æ–º –æ—Ç–≤–µ—Ç–µ (status='final')."
                                contextMsgs = append([]llm.Message{{Role: "system", Content: accel}}, contextMsgs...)
                        }</span>
                }
                <span class="cov4" title="2">b.logLLMRequest(msg.From.ID, "tz_bootstrap", contextMsgs)
                resp, err := b.getLLMClient().Generate(ctx, contextMsgs)
                if err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "–ù–µ —É–¥–∞–ª–æ—Å—å —Å—Ç–∞—Ä—Ç–æ–≤–∞—Ç—å —Ä–µ–∂–∏–º –¢–ó, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
                        log.Println(err)
                        return
                }</span>
                <span class="cov4" title="2">b.processLLMAndRespond(ctx, msg.Chat.ID, msg.From.ID, resp)
                return</span>
        }
        // admin-only commands
        <span class="cov0" title="0">if msg.From.ID != b.adminUserID </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "–ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
                return
        }</span>
        <span class="cov0" title="0">switch msg.Command() </span>{
        case "allowlist":<span class="cov0" title="0">
                var bld strings.Builder
                bld.WriteString("Allowlist:\n")
                for _, u := range b.authSvc.List() </span><span class="cov0" title="0">{
                        bld.WriteString(fmt.Sprintf("- id=%d, @%s %s %s\n", u.ID, u.Username, u.FirstName, u.LastName))
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, bld.String())</span>
        case "remove":<span class="cov0" title="0">
                args := strings.Fields(msg.CommandArguments())
                if len(args) != 1 </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Usage: /remove &lt;user_id&gt;")
                        return
                }</span>
                <span class="cov0" title="0">uid, err := strconv.ParseInt(args[0], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π user_id")
                        return
                }</span>
                <span class="cov0" title="0">if err := b.authSvc.Remove(uid); err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, fmt.Sprintf("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, fmt.Sprintf("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å %d —É–¥–∞–ª–µ–Ω –∏–∑ allowlist", uid))</span>
        case "pending":<span class="cov0" title="0">
                var bld strings.Builder
                bld.WriteString("Pending –∑–∞—è–≤–∫–∏:\n")
                for _, u := range b.pending </span><span class="cov0" title="0">{
                        bld.WriteString(fmt.Sprintf("- id=%d, @%s %s %s\n", u.ID, u.Username, u.FirstName, u.LastName))
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, bld.String())</span>
        case "approve":<span class="cov0" title="0">
                args := strings.Fields(msg.CommandArguments())
                if len(args) != 1 </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Usage: /approve &lt;user_id&gt;")
                        return
                }</span>
                <span class="cov0" title="0">uid, err := strconv.ParseInt(args[0], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π user_id")
                        return
                }</span>
                <span class="cov0" title="0">b.approveUser(uid)</span>
        case "deny":<span class="cov0" title="0">
                args := strings.Fields(msg.CommandArguments())
                if len(args) != 1 </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "Usage: /deny &lt;user_id&gt;")
                        return
                }</span>
                <span class="cov0" title="0">uid, err := strconv.ParseInt(args[0], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π user_id")
                        return
                }</span>
                <span class="cov0" title="0">b.denyUser(uid)</span>
        }
}

// handleIncomingMessage
func (b *Bot) handleIncomingMessage(ctx context.Context, msg *tgbotapi.Message) <span class="cov10" title="6">{
        if !b.authSvc.IsAllowed(msg.From.ID) </span><span class="cov0" title="0">{
                log.Printf("Unauthorized access attempt by user ID: %d, username: @%s", msg.From.ID, msg.From.UserName)
                if _, ok := b.pending[msg.From.ID]; ok </span><span class="cov0" title="0">{
                        b.sendMessage(msg.Chat.ID, "–í–∞—à –∑–∞–ø—Ä–æ—Å –Ω–∞ –¥–æ—Å—Ç—É–ø —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–∂–∏–¥–∞–π—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è. –ö–∞–∫ —Ç–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø –±—É–¥–µ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω, —è —É–≤–µ–¥–æ–º–ª—é –≤–∞—Å.")
                        return
                }</span>
                <span class="cov0" title="0">b.pending[msg.From.ID] = auth.User{ID: msg.From.ID, Username: msg.From.UserName, FirstName: msg.From.FirstName, LastName: msg.From.LastName}
                if b.pendingRepo != nil </span><span class="cov0" title="0">{
                        _ = b.pendingRepo.Upsert(b.pending[msg.From.ID])
                }</span>
                <span class="cov0" title="0">b.sendMessage(msg.Chat.ID, "–ó–∞–ø—Ä–æ—Å –Ω–∞ –¥–æ—Å—Ç—É–ø –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É. –ö–∞–∫ —Ç–æ–ª—å–∫–æ –æ–Ω –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç, –≤—ã –ø–æ–ª—É—á–∏—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ.")
                b.notifyAdminRequest(msg.From.ID, msg.From.UserName)
                return</span>
        }
        <span class="cov10" title="6">log.Printf("Incoming message from %d (@%s): %q", msg.From.ID, msg.From.UserName, msg.Text)
        b.history.AppendUser(msg.From.ID, msg.Text)
        if b.recorder != nil </span><span class="cov0" title="0">{
                tru := true
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: b.nowUTC(), UserID: msg.From.ID, UserMessage: msg.Text, CanUse: &amp;tru})
        }</span>

        <span class="cov10" title="6">if b.isTZMode(msg.From.ID) &amp;&amp; b.getTZRemaining(msg.From.ID) &lt;= 0 </span><span class="cov0" title="0">{
                if pFinal, respFinal, okFinal := b.produceFinalTS(ctx, msg.From.ID); okFinal </span><span class="cov0" title="0">{
                        b.sendFinalTS(msg.Chat.ID, msg.From.ID, pFinal, respFinal)
                        return
                }</span>
        }

        <span class="cov10" title="6">contextMsgs := b.buildContextWithOverflow(ctx, msg.From.ID)
        if b.isTZMode(msg.From.ID) </span><span class="cov4" title="2">{
                left := b.getTZRemaining(msg.From.ID)
                if left &gt; 0 &amp;&amp; left &lt;= 2 </span><span class="cov4" title="2">{
                        accel := "–û—Å—Ç–∞–ª–æ—Å—å –æ—á–µ–Ω—å –º–∞–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏–π (&lt;=2). –°–æ–∫—Ä–∞—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–ø—Ä–æ—Å–æ–≤ –∏ –ø–æ—Å—Ç–∞—Ä–∞–π—Å—è –∑–∞–≤–µ—Ä—à–∏—Ç—å —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –¢–ó –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ. –ï—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ ‚Äî —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä—É–π —É–∂–µ –≤ —ç—Ç–æ–º –æ—Ç–≤–µ—Ç–µ (status='final')."
                        contextMsgs = append([]llm.Message{{Role: "system", Content: accel}}, contextMsgs...)
                }</span>
        }
        <span class="cov10" title="6">b.logLLMRequest(msg.From.ID, "chat", contextMsgs)

        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã Notion —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏ –Ω–µ –≤ —Ä–µ–∂–∏–º–µ –¢–ó
        var resp llm.Response
        var err error
        if b.mcpClient != nil &amp;&amp; !b.isTZMode(msg.From.ID) </span><span class="cov0" title="0">{
                tools := llm.GetNotionTools()
                resp, err = b.getLLMClient().GenerateWithTools(ctx, contextMsgs, tools)
        }</span> else<span class="cov10" title="6"> {
                resp, err = b.getLLMClient().Generate(ctx, contextMsgs)
        }</span>

        <span class="cov10" title="6">if err != nil </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "Sorry, something went wrong.")
                return
        }</span>
        <span class="cov10" title="6">b.processLLMAndRespond(ctx, msg.Chat.ID, msg.From.ID, resp)</span>
}

// notifyAdminRequest
func (b *Bot) notifyAdminRequest(userID int64, username string) <span class="cov1" title="1">{
        if b.adminUserID == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">text := fmt.Sprintf("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @%s —Å id %d —Ö–æ—á–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º", username, userID)
        kb := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("—Ä–∞–∑—Ä–µ—à–∏—Ç—å", approvePrefix+strconv.FormatInt(userID, 10)),
                        tgbotapi.NewInlineKeyboardButtonData("–∑–∞–ø—Ä–µ—Ç–∏—Ç—å", denyPrefix+strconv.FormatInt(userID, 10)),
                ),
        )
        msg := tgbotapi.NewMessage(b.adminUserID, b.escapeIfNeeded(text))
        msg.ParseMode = b.parseModeValue()
        msg.ReplyMarkup = kb
        _, _ = b.s.Send(msg)</span>
}

// handleCallback
func (b *Bot) handleCallback(ctx context.Context, cb *tgbotapi.CallbackQuery) <span class="cov0" title="0">{
        switch </span>{
        case cb.Data == resetCmd:<span class="cov0" title="0">
                b.history.DisableAll(cb.From.ID)
                if b.recorder != nil </span><span class="cov0" title="0">{
                        _ = b.recorder.SetAllCanUse(cb.From.ID, false)
                }</span>
                <span class="cov0" title="0">msg := tgbotapi.NewMessage(cb.Message.Chat.ID, b.escapeIfNeeded("–ö–æ–Ω—Ç–µ–∫—Å—Ç –æ—á–∏—â–µ–Ω"))
                msg.ParseMode = b.parseModeValue()
                msg.ReplyMarkup = b.menuKeyboard()
                if _, err := b.s.Send(msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to send reset confirmation: %v", err)
                }</span>
        case cb.Data == summaryCmd:<span class="cov0" title="0">
                b.handleSummary(ctx, cb)</span>
        default:<span class="cov0" title="0">
                switch </span>{
                case strings.HasPrefix(cb.Data, approvePrefix):<span class="cov0" title="0">
                        idStr := strings.TrimPrefix(cb.Data, approvePrefix)
                        id, _ := strconv.ParseInt(idStr, 10, 64)
                        b.approveUser(id)</span>
                case strings.HasPrefix(cb.Data, denyPrefix):<span class="cov0" title="0">
                        idStr := strings.TrimPrefix(cb.Data, denyPrefix)
                        id, _ := strconv.ParseInt(idStr, 10, 64)
                        b.denyUser(id)</span>
                }
        }
}

// handleSummary
func (b *Bot) handleSummary(ctx context.Context, cb *tgbotapi.CallbackQuery) <span class="cov0" title="0">{
        h := b.history.Get(cb.From.ID)
        if len(h) == 0 </span><span class="cov0" title="0">{
                m := tgbotapi.NewMessage(cb.Message.Chat.ID, b.escapeIfNeeded("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞"))
                m.ParseMode = b.parseModeValue()
                _, _ = b.s.Send(m)
                return
        }</span>
        <span class="cov0" title="0">msgs := b.buildContextWithOverflow(ctx, cb.From.ID)
        msgs = append([]llm.Message{{Role: "system", Content: "–°—É–º–º–∏—Ä—É–π –ø–µ—Ä–µ–ø–∏—Å–∫—É. –û—Ç–≤–µ—Ç —Å—Ç—Ä–æ–≥–æ –≤ JSON —Å–æ —Å—Ö–µ–º–æ–π {title, answer, compressed_context}."}}, msgs...)
        b.logLLMRequest(cb.From.ID, "summary", msgs)
        resp, err := b.getLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                m := tgbotapi.NewMessage(cb.Message.Chat.ID, b.escapeIfNeeded("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–±—Ä–∞—Ç—å —Å–∞–º–º–∞—Ä–∏"))
                m.ParseMode = b.parseModeValue()
                _, _ = b.s.Send(m)
                return
        }</span>
        <span class="cov0" title="0">parsed, ok := parseLLMJSON(resp.Content)
        if !ok </span><span class="cov0" title="0">{
                if p2, ok2 := b.reformatToSchema(ctx, cb.From.ID, resp.Content); ok2 </span><span class="cov0" title="0">{
                        parsed = p2
                        ok = true
                }</span>
        }
        <span class="cov0" title="0">if ok &amp;&amp; strings.TrimSpace(parsed.CompressedContext) != "" </span><span class="cov0" title="0">{
                b.addUserSystemPrompt(cb.From.ID, parsed.CompressedContext)
                b.history.DisableAll(cb.From.ID)
        }</span>
        <span class="cov0" title="0">answerToSend := resp.Content
        if ok &amp;&amp; parsed.Answer != "" </span><span class="cov0" title="0">{
                answerToSend = parsed.Answer
        }</span>
        <span class="cov0" title="0">b.history.AppendAssistantWithUsed(cb.From.ID, answerToSend, true)
        if b.recorder != nil </span><span class="cov0" title="0">{
                tru := true
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: b.nowUTC(), UserID: cb.From.ID, AssistantResponse: answerToSend, CanUse: &amp;tru})
        }</span>
        <span class="cov0" title="0">metaLine := fmt.Sprintf("[model=%s, tokens: prompt=%d, completion=%d, total=%d]", resp.Model, resp.PromptTokens, resp.CompletionTokens, resp.TotalTokens)
        metaEsc := b.escapeIfNeeded(metaLine)
        body := answerToSend
        if ok &amp;&amp; parsed.Title != "" </span><span class="cov0" title="0">{
                body = b.formatTitleAnswer(parsed.Title, answerToSend)
        }</span>
        <span class="cov0" title="0">final := metaEsc + "\n\n" + body
        m := tgbotapi.NewMessage(cb.Message.Chat.ID, final)
        m.ParseMode = b.parseModeValue()
        m.ReplyMarkup = b.menuKeyboard()
        _, _ = b.s.Send(m)</span>
}

// handleNotionSave —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–∏–∞–ª–æ–≥ –≤ Notion
func (b *Bot) handleNotionSave(msg *tgbotapi.Message) <span class="cov0" title="0">{
        if !b.authSvc.IsAllowed(msg.From.ID) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if b.mcpClient == nil </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "Notion –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ NOTION_TOKEN –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.")
                return
        }</span>

        <span class="cov0" title="0">args := strings.TrimSpace(msg.CommandArguments())
        if args == "" </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /notion_save &lt;–Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã&gt;")
                return
        }</span>

        // –°–æ–±–∏—Ä–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–∏–∞–ª–æ–≥–∞
        <span class="cov0" title="0">history := b.history.Get(msg.From.ID)
        if len(history) == 0 </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "–ò—Å—Ç–æ—Ä–∏—è –¥–∏–∞–ª–æ–≥–∞ –ø—É—Å—Ç–∞, –Ω–µ—á–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å.")
                return
        }</span>

        // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        <span class="cov0" title="0">var content strings.Builder
        for _, msg := range history </span><span class="cov0" title="0">{
                if msg.Role == "user" </span><span class="cov0" title="0">{
                        content.WriteString(fmt.Sprintf("**–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:** %s\n\n", msg.Content))
                }</span> else<span class="cov0" title="0"> if msg.Role == "assistant" </span><span class="cov0" title="0">{
                        content.WriteString(fmt.Sprintf("**–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç:** %s\n\n", msg.Content))
                }</span>
        }

        <span class="cov0" title="0">ctx := context.Background()

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É parent page
        if b.notionParentPage == "" </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "‚ùå –ù–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω NOTION_PARENT_PAGE_ID. –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è —Å ID —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏–∑ Notion.")
                return
        }</span>

        <span class="cov0" title="0">result := b.mcpClient.CreateDialogSummary(
                ctx,
                args, // title
                content.String(),
                fmt.Sprintf("%d", msg.From.ID),
                msg.From.UserName,
                "dialog_summary",
                b.notionParentPage,
        )

        if result.Success </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, fmt.Sprintf("‚úÖ –î–∏–∞–ª–æ–≥ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ Notion!\n\n%s", result.Message))
        }</span> else<span class="cov0" title="0"> {
                b.sendMessage(msg.Chat.ID, fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ Notion: %s", result.Message))
        }</span>
}

// handleNotionSearch –∏—â–µ—Ç –≤ Notion
func (b *Bot) handleNotionSearch(msg *tgbotapi.Message) <span class="cov0" title="0">{
        if !b.authSvc.IsAllowed(msg.From.ID) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if b.mcpClient == nil </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "Notion –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ NOTION_TOKEN –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.")
                return
        }</span>

        <span class="cov0" title="0">args := strings.TrimSpace(msg.CommandArguments())
        if args == "" </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /notion_search &lt;–ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å&gt;")
                return
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        result := b.mcpClient.SearchDialogSummaries(
                ctx,
                args,
                fmt.Sprintf("%d", msg.From.ID),
                "dialog_summary",
        )

        if result.Success </span><span class="cov0" title="0">{
                b.sendMessage(msg.Chat.ID, fmt.Sprintf("üîç –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –≤ Notion:\n\n%s", result.Message))
        }</span> else<span class="cov0" title="0"> {
                b.sendMessage(msg.Chat.ID, fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –≤ Notion: %s", result.Message))
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package telegram

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "strings"
        "time"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

        "ai-chatter/internal/llm"
        "ai-chatter/internal/storage"
)

// moved types live in bot.go currently; keep helpers here only if not duplicated
type llmJSON struct {
        Title             string `json:"title"`
        Answer            string `json:"answer"`
        CompressedContext string `json:"compressed_context"`
        Status            string `json:"status"`
}

type llmJSONFlexible struct {
        Title             string          `json:"title"`
        Answer            string          `json:"answer"`
        CompressedContext json.RawMessage `json:"compressed_context"`
        Status            string          `json:"status"`
}

// Checker response from model2
type checkerJSON struct {
        Status string `json:"status"`
        Msg    string `json:"msg"`
}

func parseCheckerJSON(s string) (checkerJSON, bool) <span class="cov5" title="4">{
        var c checkerJSON
        if err := json.Unmarshal([]byte(s), &amp;c); err != nil </span><span class="cov0" title="0">{
                return checkerJSON{}, false
        }</span>
        <span class="cov5" title="4">if c.Status == "ok" || c.Status == "fail" </span><span class="cov1" title="1">{
                return c, true
        }</span>
        <span class="cov4" title="3">return checkerJSON{}, false</span>
}

func buildCheckerPrompt() string <span class="cov5" title="4">{
        return "–¢—ã ‚Äî –º–æ–¥–µ–ª—å-–ø—Ä–æ–≤–µ—Ä—è—é—â–∏–π —Å—Ç–∞—Ç—É—Å–∞ –¥—Ä—É–≥–æ–π –º–æ–¥–µ–ª–∏ –≤ —Ä–µ–∂–∏–º–µ —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –¢–ó. " +
                "–¢–µ–±–µ –ø–µ—Ä–µ–¥–∞—é—Ç —Ç–æ–ª—å–∫–æ –¥–≤–∞ –ø–æ–ª—è –∏–∑ –æ—Ç–≤–µ—Ç–∞: 'answer' –∏ 'status'. " +
                "'status' –º–æ–∂–µ—Ç –±—ã—Ç—å 'continue' –∏–ª–∏ 'final'. –°—Ç–∞—Ç—É—Å 'continue' –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –≤ —Å–µ–±–µ" +
                "—É—Ç–æ—á–Ω—è—é—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã, —Å—Ç–∞—Ç—É—Å 'final' ‚Äì –∏—Ç–æ–≥–æ–≤–æ–µ –¢–ó. " +
                "–ü—Ä–æ–≤–µ—Ä—å, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ª–∏ –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å " +
                "–∑–¥—Ä–∞–≤–æ–º—É —Å–º—ã—Å–ª—É, –∏—Å—Ö–æ–¥—è –∏–∑ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏/–∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—Å—Ç–∏ —Å–æ–æ–±—â–µ–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'continue' " +
                "–≤—Å–µ–≥–¥–∞ –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã, 'final' ‚Äì –∏—Ç–æ–≥–æ–≤–æ–µ –¢–ó). " +
                "–í–µ—Ä–Ω–∏ —Å—Ç—Ä–æ–≥–æ JSON {\"status\": \"ok|fail\", \"msg\": \"–µ—Å–ª–∏ fail ‚Äî –∫—Ä–∞—Ç–∫–æ —á—Ç–æ " +
                "–∏—Å–ø—Ä–∞–≤–∏—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä: '—É—Ç–æ—á–Ω–∏—Ç—å —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è'), –∏–Ω–∞—á–µ –ø—É—Å—Ç–æ\"}. –ù–µ –∏—Å–ø–æ–ª—å–∑—É—é –∫–∞–∫–æ–≥–æ-–ª–∏–±–æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, —Ç–æ–ª—å–∫–æ JSON" +
                " —á–∏—Å—Ç—ã–º —Ç–µ–∫—Å—Ç–æ–º"
}</span>

func buildCheckerInput(answer, status string) string <span class="cov5" title="4">{
        return fmt.Sprintf("answer: %s\nstatus: %s", strings.TrimSpace(answer), strings.TrimSpace(status))
}</span>

func (b *Bot) runTZChecker(ctx context.Context, userID int64, lastPrimary string) (checkerJSON, llm.Response, error) <span class="cov5" title="4">{
        msgs := []llm.Message{
                {Role: "system", Content: buildCheckerPrompt()},
                {Role: "user", Content: lastPrimary},
        }
        b.logLLMRequest(userID, "tz_check", msgs)
        resp, err := b.getSecondLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                return checkerJSON{}, llm.Response{}, err
        }</span>
        <span class="cov5" title="4">b.logResponse(resp)
        cj, ok := parseCheckerJSON(resp.Content)
        // Persist checker response for audit (not used in context)
        if b.recorder != nil </span><span class="cov0" title="0">{
                f := false
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: time.Now().UTC(), UserID: userID, UserMessage: "[tz_check]", AssistantResponse: resp.Content, CanUse: &amp;f})
        }</span>
        <span class="cov5" title="4">if !ok </span><span class="cov4" title="3">{
                return checkerJSON{}, resp, fmt.Errorf("checker returned invalid schema")
        }</span>
        <span class="cov1" title="1">return cj, resp, nil</span>
}

func (b *Bot) correctPrimaryWithMsg(ctx context.Context, userID int64, original string, msg string) (llmJSON, llm.Response, error) <span class="cov1" title="1">{
        instr := "–ò—Å–ø—Ä–∞–≤—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π –æ—Ç–≤–µ—Ç —Å–æ–≥–ª–∞—Å–Ω–æ –∑–∞–º–µ—á–∞–Ω–∏—è–º: " + msg + ". –°–æ—Ö—Ä–∞–Ω–∏ —Å—Ç—Ä–æ–≥—É—é JSON-—Å—Ö–µ–º—É {title, answer, compressed_context, status}."
        // Persist correction request intent
        if b.recorder != nil </span><span class="cov0" title="0">{
                f := false
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: time.Now().UTC(), UserID: userID, UserMessage: "[tz_correct_req]", AssistantResponse: msg, CanUse: &amp;f})
        }</span>
        <span class="cov1" title="1">msgs := []llm.Message{{Role: "system", Content: instr}, {Role: "user", Content: original}}
        b.logLLMRequest(userID, "tz_correct", msgs)
        resp, err := b.getLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                return llmJSON{}, llm.Response{}, err
        }</span>
        <span class="cov1" title="1">p, ok := parseLLMJSON(resp.Content)
        if !ok </span><span class="cov0" title="0">{
                return llmJSON{}, resp, fmt.Errorf("primary returned invalid JSON on correction")
        }</span>
        <span class="cov1" title="1">return p, resp, nil</span>
}

func compactJSON(raw json.RawMessage) (string, bool) <span class="cov0" title="0">{
        if len(raw) == 0 || string(raw) == "null" </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">var s string
        if err := json.Unmarshal(raw, &amp;s); err == nil </span><span class="cov0" title="0">{
                return s, true
        }</span>
        <span class="cov0" title="0">var anyJson interface{}
        if err := json.Unmarshal(raw, &amp;anyJson); err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">b, err := json.Marshal(anyJson)
        if err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">return string(b), true</span>
}

func parseLLMJSON(s string) (llmJSON, bool) <span class="cov9" title="13">{
        var v llmJSON
        if err := json.Unmarshal([]byte(s), &amp;v); err == nil </span><span class="cov9" title="13">{
                if v.Title != "" || v.Answer != "" || v.CompressedContext != "" || v.Status != "" </span><span class="cov9" title="13">{
                        return v, true
                }</span>
        }
        <span class="cov0" title="0">var f llmJSONFlexible
        if err := json.Unmarshal([]byte(s), &amp;f); err != nil </span><span class="cov0" title="0">{
                return llmJSON{}, false
        }</span>
        <span class="cov0" title="0">cc, _ := compactJSON(f.CompressedContext)
        return llmJSON{Title: f.Title, Answer: f.Answer, CompressedContext: cc, Status: f.Status}, true</span>
}

// Auto-numbering for questions in TZ mode when status=continue
func isNumberedLine(s string) bool <span class="cov3" title="2">{
        ss := strings.TrimSpace(s)
        if ss == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        // scan leading digits
        <span class="cov3" title="2">i := 0
        for i &lt; len(ss) &amp;&amp; ss[i] &gt;= '0' &amp;&amp; ss[i] &lt;= '9' </span><span class="cov3" title="2">{
                i++
        }</span>
        <span class="cov3" title="2">if i == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="2">if i &lt; len(ss) &amp;&amp; ss[i] == '.' </span><span class="cov3" title="2">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func enforceNumberedListIfNeeded(answer string) string <span class="cov3" title="2">{
        lines := strings.Split(answer, "\n")
        var content []string
        for _, ln := range lines </span><span class="cov4" title="3">{
                l := strings.TrimSpace(ln)
                if l != "" </span><span class="cov4" title="3">{
                        content = append(content, l)
                }</span>
        }
        <span class="cov3" title="2">if len(content) &lt; 2 </span><span class="cov1" title="1">{
                return answer
        }</span>
        // if already has 2+ numbered lines, keep as is
        <span class="cov1" title="1">num := 0
        for _, l := range content </span><span class="cov3" title="2">{
                if isNumberedLine(l) </span><span class="cov3" title="2">{
                        num++
                }</span>
        }
        <span class="cov1" title="1">if num &gt;= 2 </span><span class="cov1" title="1">{
                return answer
        }</span>
        // produce numbered
        <span class="cov0" title="0">var out []string
        for i, l := range content </span><span class="cov0" title="0">{
                out = append(out, fmt.Sprintf("%d. %s", i+1, l))
        }</span>
        <span class="cov0" title="0">return strings.Join(out, "\n")</span>
}

// reformatToSchema is defined in bot.go (single owner)

// buildContextWithOverflow is defined in bot.go

func (b *Bot) processLLMAndRespond(ctx context.Context, chatID int64, userID int64, resp llm.Response) <span class="cov7" title="8">{
        // log inbound
        b.logResponse(resp)

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º function calls –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
        if len(resp.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                b.handleFunctionCalls(ctx, chatID, userID, resp.ToolCalls)
                return
        }</span>

        <span class="cov7" title="8">parsed, ok := parseLLMJSON(resp.Content)
        if !ok </span><span class="cov0" title="0">{
                if p2, ok2 := b.reformatToSchema(ctx, userID, resp.Content); ok2 </span><span class="cov0" title="0">{
                        parsed = p2
                        ok = true
                }</span>
        }

        <span class="cov7" title="8">compressed := false
        if ok &amp;&amp; strings.TrimSpace(parsed.CompressedContext) != "" </span><span class="cov1" title="1">{
                b.addUserSystemPrompt(userID, parsed.CompressedContext)
                b.history.DisableAll(userID)
                compressed = true
        }</span>
        <span class="cov7" title="8">answerToSend := resp.Content
        if ok &amp;&amp; parsed.Answer != "" </span><span class="cov7" title="8">{
                answerToSend = parsed.Answer
        }</span>
        <span class="cov7" title="8">status := ""
        if ok </span><span class="cov7" title="8">{
                status = strings.ToLower(strings.TrimSpace(parsed.Status))
        }</span>

        // Checker and possible correction: provide only title+status
        <span class="cov7" title="8">if b.isTZMode(userID) </span><span class="cov5" title="4">{
                checkerInput := buildCheckerInput(parsed.Answer, parsed.Status)
                if cj, _, err := b.runTZChecker(ctx, userID, checkerInput); err == nil </span><span class="cov1" title="1">{
                        if strings.ToLower(cj.Status) == "fail" &amp;&amp; strings.TrimSpace(cj.Msg) != "" </span><span class="cov1" title="1">{
                                if pFix, _, errFix := b.correctPrimaryWithMsg(ctx, userID, answerToSend, cj.Msg); errFix == nil </span><span class="cov1" title="1">{
                                        parsed = pFix
                                        answerToSend = pFix.Answer
                                        status = strings.ToLower(strings.TrimSpace(pFix.Status))
                                        if strings.TrimSpace(pFix.CompressedContext) != "" </span><span class="cov0" title="0">{
                                                b.addUserSystemPrompt(userID, pFix.CompressedContext)
                                                b.history.DisableAll(userID)
                                                compressed = true
                                        }</span>
                                }
                        }
                }
        }

        // Enforce numbered list for questions while clarifying TZ
        <span class="cov7" title="8">if b.isTZMode(userID) &amp;&amp; status != "final" </span><span class="cov3" title="2">{
                answerToSend = enforceNumberedListIfNeeded(answerToSend)
        }</span>

        // TZ steps control in both paths
        <span class="cov7" title="8">if b.isTZMode(userID) &amp;&amp; status != "final" </span><span class="cov3" title="2">{
                left := b.decTZRemaining(userID)
                if left &lt;= 0 </span><span class="cov1" title="1">{
                        if pFinal, respFinal, okFinal := b.produceFinalTS(ctx, userID); okFinal </span><span class="cov1" title="1">{
                                b.sendFinalTS(chatID, userID, pFinal, respFinal)
                                return
                        }</span>
                }
        }

        // Unified final handling: send via sendFinalTS and stop
        <span class="cov7" title="7">if b.isTZMode(userID) &amp;&amp; status == "final" </span><span class="cov3" title="2">{
                b.sendFinalTS(chatID, userID, parsed, resp)
                return
        }</span>

        <span class="cov6" title="5">used := !compressed
        b.history.AppendAssistantWithUsed(userID, answerToSend, used)
        if b.recorder != nil </span><span class="cov0" title="0">{
                tru := true
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: time.Now().UTC(), UserID: userID, AssistantResponse: answerToSend, CanUse: &amp;tru})
        }</span>

        <span class="cov6" title="5">metaLine := fmt.Sprintf("[model=%s, tokens: prompt=%d, completion=%d, total=%d]", resp.Model, resp.PromptTokens, resp.CompletionTokens, resp.TotalTokens)
        metaEsc := b.escapeIfNeeded(metaLine)
        body := answerToSend
        if ok &amp;&amp; parsed.Title != "" </span><span class="cov6" title="5">{
                body = b.formatTitleAnswer(parsed.Title, answerToSend)
        }</span>
        <span class="cov6" title="5">final := metaEsc + "\n\n" + body
        msgOut := tgbotapi.NewMessage(chatID, final)
        msgOut.ReplyMarkup = b.menuKeyboard()
        msgOut.ParseMode = b.parseModeValue()
        _, _ = b.s.Send(msgOut)</span>
}

func (b *Bot) sendFinalTS(chatID, userID int64, p llmJSON, resp llm.Response) <span class="cov4" title="3">{
        answerToSend := p.Answer
        if p.Title != "" </span><span class="cov4" title="3">{
                answerToSend = b.formatTitleAnswer(p.Title, p.Answer)
        }</span>
        <span class="cov4" title="3">b.history.AppendAssistantWithUsed(userID, answerToSend, true)
        if b.recorder != nil </span><span class="cov0" title="0">{
                tru := true
                _ = b.recorder.AppendInteraction(storage.Event{Timestamp: time.Now().UTC(), UserID: userID, AssistantResponse: answerToSend, CanUse: &amp;tru})
        }</span>
        <span class="cov4" title="3">metaLine := fmt.Sprintf("[model=%s, tokens: prompt=%d, completion=%d, total=%d]", resp.Model, resp.PromptTokens, resp.CompletionTokens, resp.TotalTokens)
        metaEsc := b.escapeIfNeeded(metaLine)
        pm := strings.ToLower(b.parseModeValue())
        var header string
        switch pm </span>{
        case strings.ToLower(tgbotapi.ModeHTML):<span class="cov4" title="3">
                header = "&lt;b&gt;–¢–ó –ì–æ—Ç–æ–≤–æ&lt;/b&gt;"</span>
        case strings.ToLower(tgbotapi.ModeMarkdownV2):<span class="cov0" title="0">
                header = escapeMarkdownV2("–¢–ó –ì–æ—Ç–æ–≤–æ")</span>
        default:<span class="cov0" title="0">
                header = "**–¢–ó –ì–æ—Ç–æ–≤–æ**"</span>
        }
        <span class="cov4" title="3">final := metaEsc + "\n\n" + header + "\n\n" + answerToSend
        msgOut := tgbotapi.NewMessage(chatID, final)
        msgOut.ReplyMarkup = b.menuKeyboard()
        msgOut.ParseMode = b.parseModeValue()
        _, _ = b.s.Send(msgOut)

        log.Println("–ì–æ—Ç–æ–≤–∏–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é")
        // Announce instruction preparation
        prep := tgbotapi.NewMessage(chatID, b.escapeIfNeeded("–ì–æ—Ç–æ–≤–ª—é –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –ø–æ –∏—Ç–æ–≥–æ–≤–æ–º—É –¢–ó‚Ä¶"))
        prep.ParseMode = b.parseModeValue()
        _, _ = b.s.Send(prep)

        // Call secondary model to generate actionable instructions
        ctx := context.Background()
        instructionPrompt := buildInstructionPrompt(p)
        msgs := []llm.Message{{Role: "system", Content: instructionPrompt}}
        b.logLLMRequest(userID, "tz_instructions", msgs)
        resp2, err := b.getSecondLLMClient().Generate(ctx, msgs)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("second model error: %v", err)
                errMsg := tgbotapi.NewMessage(chatID, b.escapeIfNeeded("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑."))
                errMsg.ParseMode = b.parseModeValue()
                _, _ = b.s.Send(errMsg)
                b.clearTZState(userID)
                return
        }</span>
        <span class="cov4" title="3">b.logResponse(resp2)
        // Try to parse as our JSON; if not, send as is
        if p2, ok := parseLLMJSON(resp2.Content); ok &amp;&amp; strings.TrimSpace(p2.Answer) != "" </span><span class="cov4" title="3">{
                inst := p2.Answer
                if p2.Title != "" </span><span class="cov4" title="3">{
                        inst = b.formatTitleAnswer(p2.Title, p2.Answer)
                }</span>
                <span class="cov4" title="3">msg2 := tgbotapi.NewMessage(chatID, inst)
                msg2.ParseMode = b.parseModeValue()
                msg2.ReplyMarkup = b.menuKeyboard()
                _, _ = b.s.Send(msg2)</span>
        } else<span class="cov0" title="0"> {
                msg2 := tgbotapi.NewMessage(chatID, resp2.Content)
                msg2.ParseMode = b.parseModeValue()
                msg2.ReplyMarkup = b.menuKeyboard()
                _, _ = b.s.Send(msg2)
        }</span>
        <span class="cov4" title="3">b.clearTZState(userID)</span>
}

func buildInstructionPrompt(ts llmJSON) string <span class="cov4" title="3">{
        // Keep it simple and provider-agnostic; instruction in Russian
        return "–¢—ã –ø–æ–ª—É—á–∞–µ—à—å –∏—Ç–æ–≥–æ–≤–æ–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ –∑–∞–¥–∞–Ω–∏–µ (–¢–ó). –ù–∞ –µ–≥–æ –æ—Å–Ω–æ–≤–µ —Å–æ—Å—Ç–∞–≤—å –¥–µ—Ç–∞–ª—å–Ω—É—é –ø–æ—à–∞–≥–æ–≤—É—é –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ." +
                " –ù–∞—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ —ç—Ç–æ –∫—É–ª–∏–Ω–∞—Ä–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç ‚Äî –≤—ã–¥–∞–π –ø–æ–ª–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç —Å —ç—Ç–∞–ø–∞–º–∏ –∏ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–∞–º–∏;" +
                " –µ—Å–ª–∏ —ç—Ç–æ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞ ‚Äî –≤—ã–¥–∞–π —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π —Å—Ç–µ–∫, —ç—Ç–∞–ø—ã —Ä–∞–±–æ—Ç, –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã –∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏; –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ" +
                " –ë—É–¥—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º: –Ω—É–º–µ—Ä—É–π —à–∞–≥–∏, –ø–∏—à–∏ –∫–∞–∂–¥—ã–π —à–∞–≥ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏. –ù–µ –¥–æ–±–∞–≤–ª—è–π –ª–∏—à–Ω–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç, –Ω–µ –æ–±—Å—É–∂–¥–∞–π —Å–∞–º –ø—Ä–æ—Ü–µ—Å—Å —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –¢–ó." +
                " –û—Ç–≤–µ—Ç –≤–µ—Ä–Ω–∏ –≤ –ø–æ–Ω—è—Ç–Ω–æ–º —á–µ–ª–æ–≤–µ–∫—É –≤–∏–¥–µ –±–µ–∑ JSON —Ñ–æ—Ä–º–∞—Ç–∞ " +
                "\n\n–ò—Ç–æ–≥–æ–≤–æ–µ –¢–ó:\n" + ts.Answer
}</span>

func (b *Bot) logResponse(resp llm.Response) <span class="cov10" title="15">{
        log.Printf("LLM response [model=%s, tokens: prompt=%d, completion=%d, total=%d]: %q", resp.Model, resp.PromptTokens, resp.CompletionTokens, resp.TotalTokens, resp.Content)
}</span>

func (b *Bot) nowUTC() time.Time <span class="cov0" title="0">{ return time.Now().UTC() }</span>

// handleFunctionCalls –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–∑–æ–≤—ã —Ñ—É–Ω–∫—Ü–∏–π –æ—Ç LLM
func (b *Bot) handleFunctionCalls(ctx context.Context, chatID, userID int64, toolCalls []llm.ToolCall) <span class="cov0" title="0">{
        if b.mcpClient == nil </span><span class="cov0" title="0">{
                b.sendMessage(chatID, "Notion –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.")
                return
        }</span>

        // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—Å–µ—Ö tool calls
        <span class="cov0" title="0">toolResults := make([]llm.ToolCallResult, 0, len(toolCalls))

        for _, tc := range toolCalls </span><span class="cov0" title="0">{
                switch tc.Function.Name </span>{
                case "save_dialog_to_notion":<span class="cov0" title="0">
                        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
                        b.sendMessage(chatID, "üíæ –°–æ—Ö—Ä–∞–Ω—è—é –¥–∏–∞–ª–æ–≥ –≤ Notion...")
                        
                        title, ok := tc.Function.Arguments["title"].(string)
                        if !ok || title == "" </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "–û—à–∏–±–∫–∞: –Ω–µ —É–∫–∞–∑–∞–Ω–æ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã",
                                })
                                continue</span>
                        }

                        // –°–æ–±–∏—Ä–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–∏–∞–ª–æ–≥–∞
                        <span class="cov0" title="0">history := b.history.Get(userID)
                        if len(history) == 0 </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "–û—à–∏–±–∫–∞: –∏—Å—Ç–æ—Ä–∏—è –¥–∏–∞–ª–æ–≥–∞ –ø—É—Å—Ç–∞",
                                })
                                continue</span>
                        }

                        // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                        <span class="cov0" title="0">var content strings.Builder
                        for _, msg := range history </span><span class="cov0" title="0">{
                                if msg.Role == "user" </span><span class="cov0" title="0">{
                                        content.WriteString(fmt.Sprintf("**–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:** %s\n\n", msg.Content))
                                }</span> else<span class="cov0" title="0"> if msg.Role == "assistant" </span><span class="cov0" title="0">{
                                        content.WriteString(fmt.Sprintf("**–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç:** %s\n\n", msg.Content))
                                }</span>
                        }

                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É parent page
                        <span class="cov0" title="0">if b.notionParentPage == "" </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω NOTION_PARENT_PAGE_ID",
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">result := b.mcpClient.CreateDialogSummary(
                                ctx, title, content.String(),
                                fmt.Sprintf("%d", userID),
                                getUsernameFromID(userID),
                                "dialog_summary",
                                b.notionParentPage,
                        )

                        if result.Success </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("–î–∏–∞–ª–æ–≥ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ Notion –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º '%s'. Page ID: %s", title, result.PageID),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: %s", result.Message),
                                })
                        }</span>

                case "search_notion":<span class="cov0" title="0">
                        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –ø–æ–∏—Å–∫–∞
                        b.sendMessage(chatID, "üîç –ò—â—É –≤ Notion...")
                        
                        query, ok := tc.Function.Arguments["query"].(string)
                        if !ok || query == "" </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "–û—à–∏–±–∫–∞: –Ω–µ —É–∫–∞–∑–∞–Ω –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å",
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">result := b.mcpClient.SearchDialogSummaries(
                                ctx, query,
                                fmt.Sprintf("%d", userID),
                                "dialog_summary",
                        )

                        if result.Success </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –ø–æ –∑–∞–ø—Ä–æ—Å—É '%s': %s", query, result.Message),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: %s", result.Message),
                                })
                        }</span>

                case "create_notion_page":<span class="cov0" title="0">
                        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è
                        b.sendMessage(chatID, "üìù –°–æ–∑–¥–∞—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤ Notion...")
                        
                        title, ok := tc.Function.Arguments["title"].(string)
                        if !ok || title == "" </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "–û—à–∏–±–∫–∞: –Ω–µ —É–∫–∞–∑–∞–Ω–æ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã",
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">content, ok := tc.Function.Arguments["content"].(string)
                        if !ok || content == "" </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    "–û—à–∏–±–∫–∞: –Ω–µ —É–∫–∞–∑–∞–Ω–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã",
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">parentPage, _ := tc.Function.Arguments["parent_page"].(string)

                        // –ï—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω parent_page, –∏—Å–ø–æ–ª—å–∑—É–µ–º default
                        if parentPage == "" </span><span class="cov0" title="0">{
                                if b.notionParentPage == "" </span><span class="cov0" title="0">{
                                        toolResults = append(toolResults, llm.ToolCallResult{
                                                ToolCallID: tc.ID,
                                                Content:    "–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω NOTION_PARENT_PAGE_ID",
                                        })
                                        continue</span>
                                }
                                <span class="cov0" title="0">parentPage = b.notionParentPage</span>
                        }

                        <span class="cov0" title="0">result := b.mcpClient.CreateFreeFormPage(ctx, title, content, parentPage, nil)

                        if result.Success </span><span class="cov0" title="0">{
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("–°—Ç—Ä–∞–Ω–∏—Ü–∞ '%s' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –≤ Notion. Page ID: %s", title, result.PageID),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                toolResults = append(toolResults, llm.ToolCallResult{
                                        ToolCallID: tc.ID,
                                        Content:    fmt.Sprintf("–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã: %s", result.Message),
                                })
                        }</span>

                default:<span class="cov0" title="0">
                        toolResults = append(toolResults, llm.ToolCallResult{
                                ToolCallID: tc.ID,
                                Content:    fmt.Sprintf("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: %s", tc.Function.Name),
                        })
                        log.Printf("Unknown function call: %s", tc.Function.Name)</span>
                }
        }

        // –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ–±—Ä–∞—Ç–Ω–æ –≤ LLM –¥–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞
        <span class="cov0" title="0">if len(toolResults) &gt; 0 </span><span class="cov0" title="0">{
                b.continueConversationWithToolResults(ctx, chatID, userID, toolResults)
        }</span>
}

// continueConversationWithToolResults –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç –¥–∏–∞–ª–æ–≥ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ tool calls
func (b *Bot) continueConversationWithToolResults(ctx context.Context, chatID, userID int64, toolResults []llm.ToolCallResult) <span class="cov0" title="0">{
        // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        contextMsgs := b.buildContextWithOverflow(ctx, userID)
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã tool calls
        for _, result := range toolResults </span><span class="cov0" title="0">{
                contextMsgs = append(contextMsgs, llm.Message{
                        Role:       "tool",
                        Content:    result.Content,
                        ToolCallID: result.ToolCallID,
                })
        }</span>

        // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –¥–ª—è LLM
        <span class="cov0" title="0">contextMsgs = append(contextMsgs, llm.Message{
                Role: "system", 
                Content: "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –∏ —Å—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π –∫—Ä–∞—Ç–∫–∏–π –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é. –°–æ–æ–±—â–∏ –æ —Å—Ç–∞—Ç—É—Å–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –Ω–æ –Ω–µ –¥—É–±–ª–∏—Ä—É–π –≤—Å—é —Ç–µ—Ö–Ω–∏—á–µ—Å–∫—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é.",
        })

        b.logLLMRequest(userID, "tool_response", contextMsgs)

        // –ü–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç –æ—Ç LLM
        resp, err := b.getLLMClient().Generate(ctx, contextMsgs)
        if err != nil </span><span class="cov0" title="0">{
                b.sendMessage(chatID, "–î–µ–π—Å—Ç–≤–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω—ã, –Ω–æ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞.")
                return
        }</span>

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç –∫–∞–∫ –æ–±—ã—á–Ω–æ
        <span class="cov0" title="0">b.processLLMAndRespond(ctx, chatID, userID, resp)</span>
}

// getUsernameFromID –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ ID (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
func getUsernameFromID(userID int64) string <span class="cov0" title="0">{
        return fmt.Sprintf("user_%d", userID)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
